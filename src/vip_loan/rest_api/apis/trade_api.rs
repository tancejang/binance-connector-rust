/*
 * Binance VIP Loan REST API
 *
 * OpenAPI Specification for the Binance VIP Loan REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::vip_loan::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait TradeApi: Send + Sync {
    async fn vip_loan_borrow(
        &self,
        params: VipLoanBorrowParams,
    ) -> anyhow::Result<RestApiResponse<models::VipLoanBorrowResponse>>;
    async fn vip_loan_renew(
        &self,
        params: VipLoanRenewParams,
    ) -> anyhow::Result<RestApiResponse<models::VipLoanRenewResponse>>;
    async fn vip_loan_repay(
        &self,
        params: VipLoanRepayParams,
    ) -> anyhow::Result<RestApiResponse<models::VipLoanRepayResponse>>;
}

#[derive(Debug, Clone)]
pub struct TradeApiClient {
    configuration: ConfigurationRestApi,
}

impl TradeApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`vip_loan_borrow`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`vip_loan_borrow`](#method.vip_loan_borrow).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct VipLoanBorrowParams {
    ///
    /// The `loan_account_id` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub loan_account_id: i64,
    ///
    /// The `loan_coin` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub loan_coin: String,
    ///
    /// The `loan_amount` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub loan_amount: f32,
    /// Multiple split by `,`
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub collateral_account_id: String,
    /// Multiple split by `,`
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub collateral_coin: String,
    /// Default: TRUE. TRUE : flexible rate; FALSE: fixed rate
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub is_flexible_rate: bool,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl VipLoanBorrowParams {
    /// Create a builder for [`vip_loan_borrow`].
    ///
    /// Required parameters:
    ///
    /// * `loan_account_id` — i64
    /// * `loan_coin` — String
    /// * `loan_amount` — f32
    /// * `collateral_account_id` — Multiple split by `,`
    /// * `collateral_coin` — Multiple split by `,`
    /// * `is_flexible_rate` — Default: TRUE. TRUE : flexible rate; FALSE: fixed rate
    ///
    #[must_use]
    pub fn builder(
        loan_account_id: i64,
        loan_coin: String,
        loan_amount: f32,
        collateral_account_id: String,
        collateral_coin: String,
        is_flexible_rate: bool,
    ) -> VipLoanBorrowParamsBuilder {
        VipLoanBorrowParamsBuilder::default()
            .loan_account_id(loan_account_id)
            .loan_coin(loan_coin)
            .loan_amount(loan_amount)
            .collateral_account_id(collateral_account_id)
            .collateral_coin(collateral_coin)
            .is_flexible_rate(is_flexible_rate)
    }
}
/// Request parameters for the [`vip_loan_renew`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`vip_loan_renew`](#method.vip_loan_renew).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct VipLoanRenewParams {
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub order_id: i64,
    /// 30/60 days
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub loan_term: i64,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl VipLoanRenewParams {
    /// Create a builder for [`vip_loan_renew`].
    ///
    /// Required parameters:
    ///
    /// * `order_id` — i64
    /// * `loan_term` — 30/60 days
    ///
    #[must_use]
    pub fn builder(order_id: i64, loan_term: i64) -> VipLoanRenewParamsBuilder {
        VipLoanRenewParamsBuilder::default()
            .order_id(order_id)
            .loan_term(loan_term)
    }
}
/// Request parameters for the [`vip_loan_repay`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`vip_loan_repay`](#method.vip_loan_repay).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct VipLoanRepayParams {
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub order_id: i64,
    ///
    /// The `amount` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: f32,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl VipLoanRepayParams {
    /// Create a builder for [`vip_loan_repay`].
    ///
    /// Required parameters:
    ///
    /// * `order_id` — i64
    /// * `amount` — f32
    ///
    #[must_use]
    pub fn builder(order_id: i64, amount: f32) -> VipLoanRepayParamsBuilder {
        VipLoanRepayParamsBuilder::default()
            .order_id(order_id)
            .amount(amount)
    }
}

#[async_trait]
impl TradeApi for TradeApiClient {
    async fn vip_loan_borrow(
        &self,
        params: VipLoanBorrowParams,
    ) -> anyhow::Result<RestApiResponse<models::VipLoanBorrowResponse>> {
        let VipLoanBorrowParams {
            loan_account_id,
            loan_coin,
            loan_amount,
            collateral_account_id,
            collateral_coin,
            is_flexible_rate,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("loanAccountId".to_string(), json!(loan_account_id));

        query_params.insert("loanCoin".to_string(), json!(loan_coin));

        let loan_amount_value = Decimal::from_f32(loan_amount).unwrap_or_default();
        query_params.insert("loanAmount".to_string(), json!(loan_amount_value));

        query_params.insert(
            "collateralAccountId".to_string(),
            json!(collateral_account_id),
        );

        query_params.insert("collateralCoin".to_string(), json!(collateral_coin));

        query_params.insert("isFlexibleRate".to_string(), json!(is_flexible_rate));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::VipLoanBorrowResponse>(
            &self.configuration,
            "/sapi/v1/loan/vip/borrow",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn vip_loan_renew(
        &self,
        params: VipLoanRenewParams,
    ) -> anyhow::Result<RestApiResponse<models::VipLoanRenewResponse>> {
        let VipLoanRenewParams {
            order_id,
            loan_term,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("orderId".to_string(), json!(order_id));

        query_params.insert("loanTerm".to_string(), json!(loan_term));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::VipLoanRenewResponse>(
            &self.configuration,
            "/sapi/v1/loan/vip/renew",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn vip_loan_repay(
        &self,
        params: VipLoanRepayParams,
    ) -> anyhow::Result<RestApiResponse<models::VipLoanRepayResponse>> {
        let VipLoanRepayParams {
            order_id,
            amount,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("orderId".to_string(), json!(order_id));

        let amount_value = Decimal::from_f32(amount).unwrap_or_default();
        query_params.insert("amount".to_string(), json!(amount_value));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::VipLoanRepayResponse>(
            &self.configuration,
            "/sapi/v1/loan/vip/repay",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "vip_loan"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockTradeApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl TradeApi for MockTradeApiClient {
        async fn vip_loan_borrow(
            &self,
            _params: VipLoanBorrowParams,
        ) -> anyhow::Result<RestApiResponse<models::VipLoanBorrowResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"loanAccountId":"12345678","requestId":"12345678","loanCoin":"BTC","isFlexibleRate":"Yes","loanAmount":"100.55","collateralAccountId":"12345678,12345678,12345678","collateralCoin":"BUSD,USDT,ETH","loanTerm":"30"}"#).unwrap();
            let dummy_response: models::VipLoanBorrowResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::VipLoanBorrowResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn vip_loan_renew(
            &self,
            _params: VipLoanRenewParams,
        ) -> anyhow::Result<RestApiResponse<models::VipLoanRenewResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"loanAccountId":"12345678","loanCoin":"BTC","loanAmount":"100.55","collateralAccountId":"12345677,12345678,12345679","collateralCoin":"BUSD,USDT,ETH","loanTerm":"30"}"#).unwrap();
            let dummy_response: models::VipLoanRenewResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::VipLoanRenewResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn vip_loan_repay(
            &self,
            _params: VipLoanRepayParams,
        ) -> anyhow::Result<RestApiResponse<models::VipLoanRepayResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"loanCoin":"BUSD","repayAmount":"200.5","remainingPrincipal":"100.5","remainingInterest":"0","collateralCoin":"BNB,BTC,ETH","currentLTV":"0.25","repayStatus":"Repaid"}"#).unwrap();
            let dummy_response: models::VipLoanRepayResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::VipLoanRepayResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn vip_loan_borrow_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = VipLoanBorrowParams::builder(1,"loan_coin_example".to_string(),1.0,"1".to_string(),"collateral_coin_example".to_string(),true,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"loanAccountId":"12345678","requestId":"12345678","loanCoin":"BTC","isFlexibleRate":"Yes","loanAmount":"100.55","collateralAccountId":"12345678,12345678,12345678","collateralCoin":"BUSD,USDT,ETH","loanTerm":"30"}"#).unwrap();
            let expected_response : models::VipLoanBorrowResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::VipLoanBorrowResponse");

            let resp = client.vip_loan_borrow(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn vip_loan_borrow_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = VipLoanBorrowParams::builder(1,"loan_coin_example".to_string(),1.0,"1".to_string(),"collateral_coin_example".to_string(),true,).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"loanAccountId":"12345678","requestId":"12345678","loanCoin":"BTC","isFlexibleRate":"Yes","loanAmount":"100.55","collateralAccountId":"12345678,12345678,12345678","collateralCoin":"BUSD,USDT,ETH","loanTerm":"30"}"#).unwrap();
            let expected_response : models::VipLoanBorrowResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::VipLoanBorrowResponse");

            let resp = client.vip_loan_borrow(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn vip_loan_borrow_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = VipLoanBorrowParams::builder(
                1,
                "loan_coin_example".to_string(),
                1.0,
                "1".to_string(),
                "collateral_coin_example".to_string(),
                true,
            )
            .build()
            .unwrap();

            match client.vip_loan_borrow(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn vip_loan_renew_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = VipLoanRenewParams::builder(1,789,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"loanAccountId":"12345678","loanCoin":"BTC","loanAmount":"100.55","collateralAccountId":"12345677,12345678,12345679","collateralCoin":"BUSD,USDT,ETH","loanTerm":"30"}"#).unwrap();
            let expected_response : models::VipLoanRenewResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::VipLoanRenewResponse");

            let resp = client.vip_loan_renew(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn vip_loan_renew_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = VipLoanRenewParams::builder(1,789,).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"loanAccountId":"12345678","loanCoin":"BTC","loanAmount":"100.55","collateralAccountId":"12345677,12345678,12345679","collateralCoin":"BUSD,USDT,ETH","loanTerm":"30"}"#).unwrap();
            let expected_response : models::VipLoanRenewResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::VipLoanRenewResponse");

            let resp = client.vip_loan_renew(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn vip_loan_renew_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = VipLoanRenewParams::builder(1, 789).build().unwrap();

            match client.vip_loan_renew(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn vip_loan_repay_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = VipLoanRepayParams::builder(1,1.0,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"loanCoin":"BUSD","repayAmount":"200.5","remainingPrincipal":"100.5","remainingInterest":"0","collateralCoin":"BNB,BTC,ETH","currentLTV":"0.25","repayStatus":"Repaid"}"#).unwrap();
            let expected_response : models::VipLoanRepayResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::VipLoanRepayResponse");

            let resp = client.vip_loan_repay(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn vip_loan_repay_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = VipLoanRepayParams::builder(1,1.0,).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"loanCoin":"BUSD","repayAmount":"200.5","remainingPrincipal":"100.5","remainingInterest":"0","collateralCoin":"BNB,BTC,ETH","currentLTV":"0.25","repayStatus":"Repaid"}"#).unwrap();
            let expected_response : models::VipLoanRepayResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::VipLoanRepayResponse");

            let resp = client.vip_loan_repay(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn vip_loan_repay_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = VipLoanRepayParams::builder(1, 1.0).build().unwrap();

            match client.vip_loan_repay(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
