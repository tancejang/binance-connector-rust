/*
 * Binance Convert REST API
 *
 * OpenAPI Specification for the Binance Convert REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::convert::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait TradeApi: Send + Sync {
    async fn accept_quote(
        &self,
        params: AcceptQuoteParams,
    ) -> anyhow::Result<RestApiResponse<models::AcceptQuoteResponse>>;
    async fn cancel_limit_order(
        &self,
        params: CancelLimitOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelLimitOrderResponse>>;
    async fn get_convert_trade_history(
        &self,
        params: GetConvertTradeHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetConvertTradeHistoryResponse>>;
    async fn order_status(
        &self,
        params: OrderStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderStatusResponse>>;
    async fn place_limit_order(
        &self,
        params: PlaceLimitOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::PlaceLimitOrderResponse>>;
    async fn query_limit_open_orders(
        &self,
        params: QueryLimitOpenOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryLimitOpenOrdersResponse>>;
    async fn send_quote_request(
        &self,
        params: SendQuoteRequestParams,
    ) -> anyhow::Result<RestApiResponse<models::SendQuoteRequestResponse>>;
}

#[derive(Debug, Clone)]
pub struct TradeApiClient {
    configuration: ConfigurationRestApi,
}

impl TradeApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`accept_quote`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`accept_quote`](#method.accept_quote).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AcceptQuoteParams {
    ///
    /// The `quote_id` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub quote_id: String,
    /// The value cannot be greater than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl AcceptQuoteParams {
    /// Create a builder for [`accept_quote`].
    ///
    /// Required parameters:
    ///
    /// * `quote_id` — String
    ///
    #[must_use]
    pub fn builder(quote_id: String) -> AcceptQuoteParamsBuilder {
        AcceptQuoteParamsBuilder::default().quote_id(quote_id)
    }
}
/// Request parameters for the [`cancel_limit_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cancel_limit_order`](#method.cancel_limit_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CancelLimitOrderParams {
    /// The orderId from `placeOrder` api
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub order_id: i64,
    /// The value cannot be greater than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CancelLimitOrderParams {
    /// Create a builder for [`cancel_limit_order`].
    ///
    /// Required parameters:
    ///
    /// * `order_id` — The orderId from `placeOrder` api
    ///
    #[must_use]
    pub fn builder(order_id: i64) -> CancelLimitOrderParamsBuilder {
        CancelLimitOrderParamsBuilder::default().order_id(order_id)
    }
}
/// Request parameters for the [`get_convert_trade_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_convert_trade_history`](#method.get_convert_trade_history).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetConvertTradeHistoryParams {
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub start_time: i64,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub end_time: i64,
    /// Default 100, Max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    /// The value cannot be greater than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetConvertTradeHistoryParams {
    /// Create a builder for [`get_convert_trade_history`].
    ///
    /// Required parameters:
    ///
    /// * `start_time` — i64
    /// * `end_time` — i64
    ///
    #[must_use]
    pub fn builder(start_time: i64, end_time: i64) -> GetConvertTradeHistoryParamsBuilder {
        GetConvertTradeHistoryParamsBuilder::default()
            .start_time(start_time)
            .end_time(end_time)
    }
}
/// Request parameters for the [`order_status`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_status`](#method.order_status).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderStatusParams {
    /// Either orderId or quoteId is required
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<String>,
    /// Either orderId or quoteId is required
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quote_id: Option<String>,
}

impl OrderStatusParams {
    /// Create a builder for [`order_status`].
    ///
    #[must_use]
    pub fn builder() -> OrderStatusParamsBuilder {
        OrderStatusParamsBuilder::default()
    }
}
/// Request parameters for the [`place_limit_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`place_limit_order`](#method.place_limit_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct PlaceLimitOrderParams {
    /// base asset (use the response `fromIsBase` from `GET /sapi/v1/convert/exchangeInfo` api to check which one is baseAsset )
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub base_asset: String,
    /// quote asset
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub quote_asset: String,
    /// Symbol limit price (from baseAsset to quoteAsset)
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub limit_price: f32,
    /// `BUY` or `SELL`
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: String,
    /// `1_D`, `3_D`, `7_D`, `30_D`  (D means day)
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub expired_type: String,
    /// Base asset amount.  (One of `baseAmount` or `quoteAmount` is required)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub base_amount: Option<f32>,
    /// Quote asset amount.  (One of `baseAmount` or `quoteAmount` is required)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quote_amount: Option<f32>,
    /// It is to choose which wallet of assets. The wallet selection is `SPOT`, `FUNDING` and `EARN`. Combination of wallet is supported i.e. `SPOT_FUNDING`, `FUNDING_EARN`, `SPOT_FUNDING_EARN` or `SPOT_EARN`  Default is `SPOT`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub wallet_type: Option<String>,
    /// The value cannot be greater than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl PlaceLimitOrderParams {
    /// Create a builder for [`place_limit_order`].
    ///
    /// Required parameters:
    ///
    /// * `base_asset` — base asset (use the response `fromIsBase` from `GET /sapi/v1/convert/exchangeInfo` api to check which one is baseAsset )
    /// * `quote_asset` — quote asset
    /// * `limit_price` — Symbol limit price (from baseAsset to quoteAsset)
    /// * `side` — `BUY` or `SELL`
    /// * `expired_type` — `1_D`, `3_D`, `7_D`, `30_D`  (D means day)
    ///
    #[must_use]
    pub fn builder(
        base_asset: String,
        quote_asset: String,
        limit_price: f32,
        side: String,
        expired_type: String,
    ) -> PlaceLimitOrderParamsBuilder {
        PlaceLimitOrderParamsBuilder::default()
            .base_asset(base_asset)
            .quote_asset(quote_asset)
            .limit_price(limit_price)
            .side(side)
            .expired_type(expired_type)
    }
}
/// Request parameters for the [`query_limit_open_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_limit_open_orders`](#method.query_limit_open_orders).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryLimitOpenOrdersParams {
    /// The value cannot be greater than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryLimitOpenOrdersParams {
    /// Create a builder for [`query_limit_open_orders`].
    ///
    #[must_use]
    pub fn builder() -> QueryLimitOpenOrdersParamsBuilder {
        QueryLimitOpenOrdersParamsBuilder::default()
    }
}
/// Request parameters for the [`send_quote_request`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`send_quote_request`](#method.send_quote_request).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct SendQuoteRequestParams {
    ///
    /// The `from_asset` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub from_asset: String,
    ///
    /// The `to_asset` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub to_asset: String,
    /// When specified, it is the amount you will be debited after the conversion
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from_amount: Option<f32>,
    /// When specified, it is the amount you will be credited after the conversion
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub to_amount: Option<f32>,
    /// It is to choose which wallet of assets. The wallet selection is `SPOT`, `FUNDING` and `EARN`. Combination of wallet is supported i.e. `SPOT_FUNDING`, `FUNDING_EARN`, `SPOT_FUNDING_EARN` or `SPOT_EARN`  Default is `SPOT`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub wallet_type: Option<String>,
    /// 10s, 30s, 1m, default 10s
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub valid_time: Option<String>,
    /// The value cannot be greater than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl SendQuoteRequestParams {
    /// Create a builder for [`send_quote_request`].
    ///
    /// Required parameters:
    ///
    /// * `from_asset` — String
    /// * `to_asset` — String
    ///
    #[must_use]
    pub fn builder(from_asset: String, to_asset: String) -> SendQuoteRequestParamsBuilder {
        SendQuoteRequestParamsBuilder::default()
            .from_asset(from_asset)
            .to_asset(to_asset)
    }
}

#[async_trait]
impl TradeApi for TradeApiClient {
    async fn accept_quote(
        &self,
        params: AcceptQuoteParams,
    ) -> anyhow::Result<RestApiResponse<models::AcceptQuoteResponse>> {
        let AcceptQuoteParams {
            quote_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("quoteId".to_string(), json!(quote_id));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::AcceptQuoteResponse>(
            &self.configuration,
            "/sapi/v1/convert/acceptQuote",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn cancel_limit_order(
        &self,
        params: CancelLimitOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelLimitOrderResponse>> {
        let CancelLimitOrderParams {
            order_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("orderId".to_string(), json!(order_id));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::CancelLimitOrderResponse>(
            &self.configuration,
            "/sapi/v1/convert/limit/cancelOrder",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_convert_trade_history(
        &self,
        params: GetConvertTradeHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetConvertTradeHistoryResponse>> {
        let GetConvertTradeHistoryParams {
            start_time,
            end_time,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("startTime".to_string(), json!(start_time));

        query_params.insert("endTime".to_string(), json!(end_time));

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetConvertTradeHistoryResponse>(
            &self.configuration,
            "/sapi/v1/convert/tradeFlow",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn order_status(
        &self,
        params: OrderStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::OrderStatusResponse>> {
        let OrderStatusParams { order_id, quote_id } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = quote_id {
            query_params.insert("quoteId".to_string(), json!(rw));
        }

        send_request::<models::OrderStatusResponse>(
            &self.configuration,
            "/sapi/v1/convert/orderStatus",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn place_limit_order(
        &self,
        params: PlaceLimitOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::PlaceLimitOrderResponse>> {
        let PlaceLimitOrderParams {
            base_asset,
            quote_asset,
            limit_price,
            side,
            expired_type,
            base_amount,
            quote_amount,
            wallet_type,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("baseAsset".to_string(), json!(base_asset));

        query_params.insert("quoteAsset".to_string(), json!(quote_asset));

        let limit_price_value = Decimal::from_f32(limit_price).unwrap_or_default();
        query_params.insert("limitPrice".to_string(), json!(limit_price_value));

        query_params.insert("side".to_string(), json!(side));

        query_params.insert("expiredType".to_string(), json!(expired_type));

        if let Some(rw) = base_amount {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("baseAmount".to_string(), json!(rw));
        }

        if let Some(rw) = quote_amount {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("quoteAmount".to_string(), json!(rw));
        }

        if let Some(rw) = wallet_type {
            query_params.insert("walletType".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::PlaceLimitOrderResponse>(
            &self.configuration,
            "/sapi/v1/convert/limit/placeOrder",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_limit_open_orders(
        &self,
        params: QueryLimitOpenOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryLimitOpenOrdersResponse>> {
        let QueryLimitOpenOrdersParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryLimitOpenOrdersResponse>(
            &self.configuration,
            "/sapi/v1/convert/limit/queryOpenOrders",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn send_quote_request(
        &self,
        params: SendQuoteRequestParams,
    ) -> anyhow::Result<RestApiResponse<models::SendQuoteRequestResponse>> {
        let SendQuoteRequestParams {
            from_asset,
            to_asset,
            from_amount,
            to_amount,
            wallet_type,
            valid_time,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("fromAsset".to_string(), json!(from_asset));

        query_params.insert("toAsset".to_string(), json!(to_asset));

        if let Some(rw) = from_amount {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("fromAmount".to_string(), json!(rw));
        }

        if let Some(rw) = to_amount {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("toAmount".to_string(), json!(rw));
        }

        if let Some(rw) = wallet_type {
            query_params.insert("walletType".to_string(), json!(rw));
        }

        if let Some(rw) = valid_time {
            query_params.insert("validTime".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::SendQuoteRequestResponse>(
            &self.configuration,
            "/sapi/v1/convert/getQuote",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "convert"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockTradeApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl TradeApi for MockTradeApiClient {
        async fn accept_quote(
            &self,
            _params: AcceptQuoteParams,
        ) -> anyhow::Result<RestApiResponse<models::AcceptQuoteResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"orderId":"933256278426274426","createTime":1623381330472,"orderStatus":"PROCESS"}"#).unwrap();
            let dummy_response: models::AcceptQuoteResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AcceptQuoteResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn cancel_limit_order(
            &self,
            _params: CancelLimitOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::CancelLimitOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"orderId":1603680255057330400,"status":"CANCELED"}"#)
                    .unwrap();
            let dummy_response: models::CancelLimitOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelLimitOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_convert_trade_history(
            &self,
            _params: GetConvertTradeHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetConvertTradeHistoryResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"list":[{"quoteId":"f3b91c525b2644c7bc1e1cd31b6e1aa6","orderId":940708407462087200,"orderStatus":"SUCCESS","fromAsset":"USDT","fromAmount":"20","toAsset":"BNB","toAmount":"0.06154036","ratio":"0.00307702","inverseRatio":"324.99","createTime":1624248872184}],"startTime":1623824139000,"endTime":1626416139000,"limit":100,"moreData":false}"#).unwrap();
            let dummy_response: models::GetConvertTradeHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetConvertTradeHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn order_status(
            &self,
            _params: OrderStatusParams,
        ) -> anyhow::Result<RestApiResponse<models::OrderStatusResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"orderId":933256278426274400,"orderStatus":"SUCCESS","fromAsset":"BTC","fromAmount":"0.00054414","toAsset":"USDT","toAmount":"20","ratio":"36755","inverseRatio":"0.00002721","createTime":1623381330472}"#).unwrap();
            let dummy_response: models::OrderStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::OrderStatusResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn place_limit_order(
            &self,
            _params: PlaceLimitOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::PlaceLimitOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"quoteId":"12415572564","ratio":"38163.7","inverseRatio":"0.0000262","validTimestamp":1623319461670,"toAmount":"3816.37","fromAmount":"0.1"}"#).unwrap();
            let dummy_response: models::PlaceLimitOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::PlaceLimitOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_limit_open_orders(
            &self,
            _params: QueryLimitOpenOrdersParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryLimitOpenOrdersResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"list":[{"quoteId":"18sdf87kh9df","orderId":1150901289839,"orderStatus":"SUCCESS","fromAsset":"BNB","fromAmount":"10","toAsset":"USDT","toAmount":"2317.89","ratio":"231.789","inverseRatio":"0.00431427","createTime":1614089498000,"expiredTimestamp":1614099498000}]}"#).unwrap();
            let dummy_response: models::QueryLimitOpenOrdersResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryLimitOpenOrdersResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn send_quote_request(
            &self,
            _params: SendQuoteRequestParams,
        ) -> anyhow::Result<RestApiResponse<models::SendQuoteRequestResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"quoteId":"12415572564","ratio":"38163.7","inverseRatio":"0.0000262","validTimestamp":1623319461670,"toAmount":"3816.37","fromAmount":"0.1"}"#).unwrap();
            let dummy_response: models::SendQuoteRequestResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::SendQuoteRequestResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn accept_quote_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = AcceptQuoteParams::builder("1".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderId":"933256278426274426","createTime":1623381330472,"orderStatus":"PROCESS"}"#).unwrap();
            let expected_response : models::AcceptQuoteResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::AcceptQuoteResponse");

            let resp = client.accept_quote(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn accept_quote_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = AcceptQuoteParams::builder("1".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderId":"933256278426274426","createTime":1623381330472,"orderStatus":"PROCESS"}"#).unwrap();
            let expected_response : models::AcceptQuoteResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::AcceptQuoteResponse");

            let resp = client.accept_quote(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn accept_quote_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = AcceptQuoteParams::builder("1".to_string()).build().unwrap();

            match client.accept_quote(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn cancel_limit_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelLimitOrderParams::builder(1).build().unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"orderId":1603680255057330400,"status":"CANCELED"}"#)
                    .unwrap();
            let expected_response: models::CancelLimitOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelLimitOrderResponse");

            let resp = client
                .cancel_limit_order(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_limit_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelLimitOrderParams::builder(1)
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"orderId":1603680255057330400,"status":"CANCELED"}"#)
                    .unwrap();
            let expected_response: models::CancelLimitOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelLimitOrderResponse");

            let resp = client
                .cancel_limit_order(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_limit_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = CancelLimitOrderParams::builder(1).build().unwrap();

            match client.cancel_limit_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_convert_trade_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = GetConvertTradeHistoryParams::builder(1623319461670,1641782889000,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"list":[{"quoteId":"f3b91c525b2644c7bc1e1cd31b6e1aa6","orderId":940708407462087200,"orderStatus":"SUCCESS","fromAsset":"USDT","fromAmount":"20","toAsset":"BNB","toAmount":"0.06154036","ratio":"0.00307702","inverseRatio":"324.99","createTime":1624248872184}],"startTime":1623824139000,"endTime":1626416139000,"limit":100,"moreData":false}"#).unwrap();
            let expected_response : models::GetConvertTradeHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetConvertTradeHistoryResponse");

            let resp = client.get_convert_trade_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_convert_trade_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = GetConvertTradeHistoryParams::builder(1623319461670,1641782889000,).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"list":[{"quoteId":"f3b91c525b2644c7bc1e1cd31b6e1aa6","orderId":940708407462087200,"orderStatus":"SUCCESS","fromAsset":"USDT","fromAmount":"20","toAsset":"BNB","toAmount":"0.06154036","ratio":"0.00307702","inverseRatio":"324.99","createTime":1624248872184}],"startTime":1623824139000,"endTime":1626416139000,"limit":100,"moreData":false}"#).unwrap();
            let expected_response : models::GetConvertTradeHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetConvertTradeHistoryResponse");

            let resp = client.get_convert_trade_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_convert_trade_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = GetConvertTradeHistoryParams::builder(1623319461670, 1641782889000)
                .build()
                .unwrap();

            match client.get_convert_trade_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn order_status_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderStatusParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderId":933256278426274400,"orderStatus":"SUCCESS","fromAsset":"BTC","fromAmount":"0.00054414","toAsset":"USDT","toAmount":"20","ratio":"36755","inverseRatio":"0.00002721","createTime":1623381330472}"#).unwrap();
            let expected_response : models::OrderStatusResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderStatusResponse");

            let resp = client.order_status(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_status_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = OrderStatusParams::builder().order_id("1".to_string()).quote_id("1".to_string()).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderId":933256278426274400,"orderStatus":"SUCCESS","fromAsset":"BTC","fromAmount":"0.00054414","toAsset":"USDT","toAmount":"20","ratio":"36755","inverseRatio":"0.00002721","createTime":1623381330472}"#).unwrap();
            let expected_response : models::OrderStatusResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::OrderStatusResponse");

            let resp = client.order_status(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn order_status_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = OrderStatusParams::builder().build().unwrap();

            match client.order_status(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn place_limit_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = PlaceLimitOrderParams::builder("base_asset_example".to_string(),"quote_asset_example".to_string(),1.0,"BUY".to_string(),"expired_type_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"quoteId":"12415572564","ratio":"38163.7","inverseRatio":"0.0000262","validTimestamp":1623319461670,"toAmount":"3816.37","fromAmount":"0.1"}"#).unwrap();
            let expected_response : models::PlaceLimitOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::PlaceLimitOrderResponse");

            let resp = client.place_limit_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn place_limit_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = PlaceLimitOrderParams::builder("base_asset_example".to_string(),"quote_asset_example".to_string(),1.0,"BUY".to_string(),"expired_type_example".to_string(),).base_amount(1.0).quote_amount(1.0).wallet_type(String::new()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"quoteId":"12415572564","ratio":"38163.7","inverseRatio":"0.0000262","validTimestamp":1623319461670,"toAmount":"3816.37","fromAmount":"0.1"}"#).unwrap();
            let expected_response : models::PlaceLimitOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::PlaceLimitOrderResponse");

            let resp = client.place_limit_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn place_limit_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = PlaceLimitOrderParams::builder(
                "base_asset_example".to_string(),
                "quote_asset_example".to_string(),
                1.0,
                "BUY".to_string(),
                "expired_type_example".to_string(),
            )
            .build()
            .unwrap();

            match client.place_limit_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_limit_open_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryLimitOpenOrdersParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"list":[{"quoteId":"18sdf87kh9df","orderId":1150901289839,"orderStatus":"SUCCESS","fromAsset":"BNB","fromAmount":"10","toAsset":"USDT","toAmount":"2317.89","ratio":"231.789","inverseRatio":"0.00431427","createTime":1614089498000,"expiredTimestamp":1614099498000}]}"#).unwrap();
            let expected_response : models::QueryLimitOpenOrdersResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryLimitOpenOrdersResponse");

            let resp = client.query_limit_open_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_limit_open_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryLimitOpenOrdersParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"list":[{"quoteId":"18sdf87kh9df","orderId":1150901289839,"orderStatus":"SUCCESS","fromAsset":"BNB","fromAmount":"10","toAsset":"USDT","toAmount":"2317.89","ratio":"231.789","inverseRatio":"0.00431427","createTime":1614089498000,"expiredTimestamp":1614099498000}]}"#).unwrap();
            let expected_response : models::QueryLimitOpenOrdersResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryLimitOpenOrdersResponse");

            let resp = client.query_limit_open_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_limit_open_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryLimitOpenOrdersParams::builder().build().unwrap();

            match client.query_limit_open_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn send_quote_request_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = SendQuoteRequestParams::builder("from_asset_example".to_string(),"to_asset_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"quoteId":"12415572564","ratio":"38163.7","inverseRatio":"0.0000262","validTimestamp":1623319461670,"toAmount":"3816.37","fromAmount":"0.1"}"#).unwrap();
            let expected_response : models::SendQuoteRequestResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::SendQuoteRequestResponse");

            let resp = client.send_quote_request(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn send_quote_request_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = SendQuoteRequestParams::builder("from_asset_example".to_string(),"to_asset_example".to_string(),).from_amount(1.0).to_amount(1.0).wallet_type(String::new()).valid_time("10s".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"quoteId":"12415572564","ratio":"38163.7","inverseRatio":"0.0000262","validTimestamp":1623319461670,"toAmount":"3816.37","fromAmount":"0.1"}"#).unwrap();
            let expected_response : models::SendQuoteRequestResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::SendQuoteRequestResponse");

            let resp = client.send_quote_request(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn send_quote_request_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = SendQuoteRequestParams::builder(
                "from_asset_example".to_string(),
                "to_asset_example".to_string(),
            )
            .build()
            .unwrap();

            match client.send_quote_request(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
