/*
 * Binance Wallet REST API
 *
 * OpenAPI Specification for the Binance Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::wallet::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait TravelRuleApi: Send + Sync {
    async fn broker_withdraw(
        &self,
        params: BrokerWithdrawParams,
    ) -> anyhow::Result<RestApiResponse<models::BrokerWithdrawResponse>>;
    async fn deposit_history_travel_rule(
        &self,
        params: DepositHistoryTravelRuleParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::DepositHistoryTravelRuleResponseInner>>>;
    async fn fetch_address_verification_list(
        &self,
    ) -> anyhow::Result<RestApiResponse<Vec<models::FetchAddressVerificationListResponseInner>>>;
    async fn onboarded_vasp_list(
        &self,
    ) -> anyhow::Result<RestApiResponse<Vec<models::OnboardedVaspListResponseInner>>>;
    async fn submit_deposit_questionnaire(
        &self,
        params: SubmitDepositQuestionnaireParams,
    ) -> anyhow::Result<RestApiResponse<models::SubmitDepositQuestionnaireResponse>>;
    async fn submit_deposit_questionnaire_travel_rule(
        &self,
        params: SubmitDepositQuestionnaireTravelRuleParams,
    ) -> anyhow::Result<RestApiResponse<models::SubmitDepositQuestionnaireTravelRuleResponse>>;
    async fn withdraw_history_v1(
        &self,
        params: WithdrawHistoryV1Params,
    ) -> anyhow::Result<RestApiResponse<Vec<models::WithdrawHistoryV2ResponseInner>>>;
    async fn withdraw_history_v2(
        &self,
        params: WithdrawHistoryV2Params,
    ) -> anyhow::Result<RestApiResponse<Vec<models::WithdrawHistoryV2ResponseInner>>>;
    async fn withdraw_travel_rule(
        &self,
        params: WithdrawTravelRuleParams,
    ) -> anyhow::Result<RestApiResponse<models::WithdrawTravelRuleResponse>>;
}

#[derive(Debug, Clone)]
pub struct TravelRuleApiClient {
    configuration: ConfigurationRestApi,
}

impl TravelRuleApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`broker_withdraw`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`broker_withdraw`](#method.broker_withdraw).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct BrokerWithdrawParams {
    ///
    /// The `address` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub address: String,
    ///
    /// The `coin` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub coin: String,
    ///
    /// The `amount` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: f32,
    /// withdrawID defined by the client (i.e. client's internal withdrawID)
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub withdraw_order_id: String,
    /// JSON format questionnaire answers.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub questionnaire: String,
    /// JSON format originator Pii, see `StandardPii` section below
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub originator_pii: String,
    /// Must be the last parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub signature: String,
    /// Secondary address identifier for coins like XRP,XMR etc.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub address_tag: Option<String>,
    ///
    /// The `network` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub network: Option<String>,
    /// Description of the address. Address book cap is 200, space in name should be encoded into `%20`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub address_name: Option<String>,
    /// When making internal transfer, `true` for returning the fee to the destination account; `false` for returning the fee back to the departure account. Default `false`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub transaction_fee_flag: Option<bool>,
    /// The wallet type for withdraw，0-spot wallet ，1-funding wallet. Default walletType is the current "selected wallet" under wallet->Fiat and Spot/Funding->Deposit
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub wallet_type: Option<i64>,
}

impl BrokerWithdrawParams {
    /// Create a builder for [`broker_withdraw`].
    ///
    /// Required parameters:
    ///
    /// * `address` — String
    /// * `coin` — String
    /// * `amount` — f32
    /// * `withdraw_order_id` — withdrawID defined by the client (i.e. client's internal withdrawID)
    /// * `questionnaire` — JSON format questionnaire answers.
    /// * `originator_pii` — JSON format originator Pii, see `StandardPii` section below
    /// * `signature` — Must be the last parameter.
    ///
    #[must_use]
    pub fn builder(
        address: String,
        coin: String,
        amount: f32,
        withdraw_order_id: String,
        questionnaire: String,
        originator_pii: String,
        signature: String,
    ) -> BrokerWithdrawParamsBuilder {
        BrokerWithdrawParamsBuilder::default()
            .address(address)
            .coin(coin)
            .amount(amount)
            .withdraw_order_id(withdraw_order_id)
            .questionnaire(questionnaire)
            .originator_pii(originator_pii)
            .signature(signature)
    }
}
/// Request parameters for the [`deposit_history_travel_rule`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`deposit_history_travel_rule`](#method.deposit_history_travel_rule).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct DepositHistoryTravelRuleParams {
    /// Comma(,) separated list of travel rule record Ids.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub tr_id: Option<String>,
    ///
    /// The `tx_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub tx_id: Option<String>,
    /// Comma(,) separated list of wallet tran Ids.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub tran_id: Option<String>,
    ///
    /// The `network` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub network: Option<String>,
    ///
    /// The `coin` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub coin: Option<String>,
    /// 0:Completed,1:Pending,2:Failed
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub travel_rule_status: Option<i64>,
    /// true: Only return records that pending deposit questionnaire. false/not provided: return all records.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_questionnaire: Option<bool>,
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default: 0
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub offset: Option<i64>,
    /// min 7, max 30, default 7
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
}

impl DepositHistoryTravelRuleParams {
    /// Create a builder for [`deposit_history_travel_rule`].
    ///
    #[must_use]
    pub fn builder() -> DepositHistoryTravelRuleParamsBuilder {
        DepositHistoryTravelRuleParamsBuilder::default()
    }
}
/// Request parameters for the [`submit_deposit_questionnaire`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`submit_deposit_questionnaire`](#method.submit_deposit_questionnaire).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct SubmitDepositQuestionnaireParams {
    /// External user ID.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub sub_account_id: String,
    /// Wallet deposit ID.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub deposit_id: String,
    /// JSON format questionnaire answers.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub questionnaire: String,
    /// JSON format beneficiary Pii.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub beneficiary_pii: String,
    /// Must be the last parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub signature: String,
    ///
    /// The `network` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub network: Option<String>,
    ///
    /// The `coin` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub coin: Option<String>,
    ///
    /// The `amount` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub amount: Option<f32>,
    ///
    /// The `address` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub address: Option<String>,
    /// Secondary address identifier for coins like XRP,XMR etc.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub address_tag: Option<String>,
}

impl SubmitDepositQuestionnaireParams {
    /// Create a builder for [`submit_deposit_questionnaire`].
    ///
    /// Required parameters:
    ///
    /// * `sub_account_id` — External user ID.
    /// * `deposit_id` — Wallet deposit ID.
    /// * `questionnaire` — JSON format questionnaire answers.
    /// * `beneficiary_pii` — JSON format beneficiary Pii.
    /// * `signature` — Must be the last parameter.
    ///
    #[must_use]
    pub fn builder(
        sub_account_id: String,
        deposit_id: String,
        questionnaire: String,
        beneficiary_pii: String,
        signature: String,
    ) -> SubmitDepositQuestionnaireParamsBuilder {
        SubmitDepositQuestionnaireParamsBuilder::default()
            .sub_account_id(sub_account_id)
            .deposit_id(deposit_id)
            .questionnaire(questionnaire)
            .beneficiary_pii(beneficiary_pii)
            .signature(signature)
    }
}
/// Request parameters for the [`submit_deposit_questionnaire_travel_rule`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`submit_deposit_questionnaire_travel_rule`](#method.submit_deposit_questionnaire_travel_rule).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct SubmitDepositQuestionnaireTravelRuleParams {
    /// Wallet tran ID
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub tran_id: i64,
    /// JSON format questionnaire answers.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub questionnaire: String,
}

impl SubmitDepositQuestionnaireTravelRuleParams {
    /// Create a builder for [`submit_deposit_questionnaire_travel_rule`].
    ///
    /// Required parameters:
    ///
    /// * `tran_id` — Wallet tran ID
    /// * `questionnaire` — JSON format questionnaire answers.
    ///
    #[must_use]
    pub fn builder(
        tran_id: i64,
        questionnaire: String,
    ) -> SubmitDepositQuestionnaireTravelRuleParamsBuilder {
        SubmitDepositQuestionnaireTravelRuleParamsBuilder::default()
            .tran_id(tran_id)
            .questionnaire(questionnaire)
    }
}
/// Request parameters for the [`withdraw_history_v1`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`withdraw_history_v1`](#method.withdraw_history_v1).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct WithdrawHistoryV1Params {
    /// Comma(,) separated list of travel rule record Ids.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub tr_id: Option<String>,
    ///
    /// The `tx_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub tx_id: Option<String>,
    /// client side id for withdrawal, if provided in POST `/sapi/v1/capital/withdraw/apply`, can be used here for query.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub withdraw_order_id: Option<String>,
    ///
    /// The `network` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub network: Option<String>,
    ///
    /// The `coin` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub coin: Option<String>,
    /// 0:Completed,1:Pending,2:Failed
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub travel_rule_status: Option<i64>,
    /// Default: 0
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub offset: Option<i64>,
    /// min 7, max 30, default 7
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl WithdrawHistoryV1Params {
    /// Create a builder for [`withdraw_history_v1`].
    ///
    #[must_use]
    pub fn builder() -> WithdrawHistoryV1ParamsBuilder {
        WithdrawHistoryV1ParamsBuilder::default()
    }
}
/// Request parameters for the [`withdraw_history_v2`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`withdraw_history_v2`](#method.withdraw_history_v2).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct WithdrawHistoryV2Params {
    /// Comma(,) separated list of travel rule record Ids.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub tr_id: Option<String>,
    ///
    /// The `tx_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub tx_id: Option<String>,
    /// client side id for withdrawal, if provided in POST `/sapi/v1/capital/withdraw/apply`, can be used here for query.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub withdraw_order_id: Option<String>,
    ///
    /// The `network` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub network: Option<String>,
    ///
    /// The `coin` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub coin: Option<String>,
    /// 0:Completed,1:Pending,2:Failed
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub travel_rule_status: Option<i64>,
    /// Default: 0
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub offset: Option<i64>,
    /// min 7, max 30, default 7
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl WithdrawHistoryV2Params {
    /// Create a builder for [`withdraw_history_v2`].
    ///
    #[must_use]
    pub fn builder() -> WithdrawHistoryV2ParamsBuilder {
        WithdrawHistoryV2ParamsBuilder::default()
    }
}
/// Request parameters for the [`withdraw_travel_rule`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`withdraw_travel_rule`](#method.withdraw_travel_rule).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct WithdrawTravelRuleParams {
    ///
    /// The `coin` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub coin: String,
    ///
    /// The `address` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub address: String,
    ///
    /// The `amount` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: f32,
    /// JSON format questionnaire answers.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub questionnaire: String,
    /// client side id for withdrawal, if provided in POST `/sapi/v1/capital/withdraw/apply`, can be used here for query.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub withdraw_order_id: Option<String>,
    ///
    /// The `network` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub network: Option<String>,
    /// Secondary address identifier for coins like XRP,XMR etc.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub address_tag: Option<String>,
    /// When making internal transfer, `true` for returning the fee to the destination account; `false` for returning the fee back to the departure account. Default `false`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub transaction_fee_flag: Option<bool>,
    /// Description of the address. Address book cap is 200, space in name should be encoded into `%20`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub name: Option<String>,
    /// The wallet type for withdraw，0-spot wallet ，1-funding wallet. Default walletType is the current "selected wallet" under wallet->Fiat and Spot/Funding->Deposit
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub wallet_type: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl WithdrawTravelRuleParams {
    /// Create a builder for [`withdraw_travel_rule`].
    ///
    /// Required parameters:
    ///
    /// * `coin` — String
    /// * `address` — String
    /// * `amount` — f32
    /// * `questionnaire` — JSON format questionnaire answers.
    ///
    #[must_use]
    pub fn builder(
        coin: String,
        address: String,
        amount: f32,
        questionnaire: String,
    ) -> WithdrawTravelRuleParamsBuilder {
        WithdrawTravelRuleParamsBuilder::default()
            .coin(coin)
            .address(address)
            .amount(amount)
            .questionnaire(questionnaire)
    }
}

#[async_trait]
impl TravelRuleApi for TravelRuleApiClient {
    async fn broker_withdraw(
        &self,
        params: BrokerWithdrawParams,
    ) -> anyhow::Result<RestApiResponse<models::BrokerWithdrawResponse>> {
        let BrokerWithdrawParams {
            address,
            coin,
            amount,
            withdraw_order_id,
            questionnaire,
            originator_pii,
            signature,
            address_tag,
            network,
            address_name,
            transaction_fee_flag,
            wallet_type,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("address".to_string(), json!(address));

        query_params.insert("coin".to_string(), json!(coin));

        let amount_value = Decimal::from_f32(amount).unwrap_or_default();
        query_params.insert("amount".to_string(), json!(amount_value));

        query_params.insert("withdrawOrderId".to_string(), json!(withdraw_order_id));

        query_params.insert("questionnaire".to_string(), json!(questionnaire));

        query_params.insert("originatorPii".to_string(), json!(originator_pii));

        query_params.insert("signature".to_string(), json!(signature));

        if let Some(rw) = address_tag {
            query_params.insert("addressTag".to_string(), json!(rw));
        }

        if let Some(rw) = network {
            query_params.insert("network".to_string(), json!(rw));
        }

        if let Some(rw) = address_name {
            query_params.insert("addressName".to_string(), json!(rw));
        }

        if let Some(rw) = transaction_fee_flag {
            query_params.insert("transactionFeeFlag".to_string(), json!(rw));
        }

        if let Some(rw) = wallet_type {
            query_params.insert("walletType".to_string(), json!(rw));
        }

        send_request::<models::BrokerWithdrawResponse>(
            &self.configuration,
            "/sapi/v1/localentity/broker/withdraw/apply",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn deposit_history_travel_rule(
        &self,
        params: DepositHistoryTravelRuleParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::DepositHistoryTravelRuleResponseInner>>> {
        let DepositHistoryTravelRuleParams {
            tr_id,
            tx_id,
            tran_id,
            network,
            coin,
            travel_rule_status,
            pending_questionnaire,
            start_time,
            end_time,
            offset,
            limit,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = tr_id {
            query_params.insert("trId".to_string(), json!(rw));
        }

        if let Some(rw) = tx_id {
            query_params.insert("txId".to_string(), json!(rw));
        }

        if let Some(rw) = tran_id {
            query_params.insert("tranId".to_string(), json!(rw));
        }

        if let Some(rw) = network {
            query_params.insert("network".to_string(), json!(rw));
        }

        if let Some(rw) = coin {
            query_params.insert("coin".to_string(), json!(rw));
        }

        if let Some(rw) = travel_rule_status {
            query_params.insert("travelRuleStatus".to_string(), json!(rw));
        }

        if let Some(rw) = pending_questionnaire {
            query_params.insert("pendingQuestionnaire".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = offset {
            query_params.insert("offset".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        send_request::<Vec<models::DepositHistoryTravelRuleResponseInner>>(
            &self.configuration,
            "/sapi/v1/localentity/deposit/history",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn fetch_address_verification_list(
        &self,
    ) -> anyhow::Result<RestApiResponse<Vec<models::FetchAddressVerificationListResponseInner>>>
    {
        let query_params = BTreeMap::new();

        send_request::<Vec<models::FetchAddressVerificationListResponseInner>>(
            &self.configuration,
            "/sapi/v1/addressVerify/list",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn onboarded_vasp_list(
        &self,
    ) -> anyhow::Result<RestApiResponse<Vec<models::OnboardedVaspListResponseInner>>> {
        let query_params = BTreeMap::new();

        send_request::<Vec<models::OnboardedVaspListResponseInner>>(
            &self.configuration,
            "/sapi/v1/localentity/vasp",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn submit_deposit_questionnaire(
        &self,
        params: SubmitDepositQuestionnaireParams,
    ) -> anyhow::Result<RestApiResponse<models::SubmitDepositQuestionnaireResponse>> {
        let SubmitDepositQuestionnaireParams {
            sub_account_id,
            deposit_id,
            questionnaire,
            beneficiary_pii,
            signature,
            network,
            coin,
            amount,
            address,
            address_tag,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("subAccountId".to_string(), json!(sub_account_id));

        query_params.insert("depositId".to_string(), json!(deposit_id));

        query_params.insert("questionnaire".to_string(), json!(questionnaire));

        query_params.insert("beneficiaryPii".to_string(), json!(beneficiary_pii));

        query_params.insert("signature".to_string(), json!(signature));

        if let Some(rw) = network {
            query_params.insert("network".to_string(), json!(rw));
        }

        if let Some(rw) = coin {
            query_params.insert("coin".to_string(), json!(rw));
        }

        if let Some(rw) = amount {
            let rw = Decimal::from_f32(rw).unwrap_or_default();
            query_params.insert("amount".to_string(), json!(rw));
        }

        if let Some(rw) = address {
            query_params.insert("address".to_string(), json!(rw));
        }

        if let Some(rw) = address_tag {
            query_params.insert("addressTag".to_string(), json!(rw));
        }

        send_request::<models::SubmitDepositQuestionnaireResponse>(
            &self.configuration,
            "/sapi/v1/localentity/broker/deposit/provide-info",
            reqwest::Method::PUT,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn submit_deposit_questionnaire_travel_rule(
        &self,
        params: SubmitDepositQuestionnaireTravelRuleParams,
    ) -> anyhow::Result<RestApiResponse<models::SubmitDepositQuestionnaireTravelRuleResponse>> {
        let SubmitDepositQuestionnaireTravelRuleParams {
            tran_id,
            questionnaire,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("tranId".to_string(), json!(tran_id));

        query_params.insert("questionnaire".to_string(), json!(questionnaire));

        send_request::<models::SubmitDepositQuestionnaireTravelRuleResponse>(
            &self.configuration,
            "/sapi/v1/localentity/deposit/provide-info",
            reqwest::Method::PUT,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn withdraw_history_v1(
        &self,
        params: WithdrawHistoryV1Params,
    ) -> anyhow::Result<RestApiResponse<Vec<models::WithdrawHistoryV2ResponseInner>>> {
        let WithdrawHistoryV1Params {
            tr_id,
            tx_id,
            withdraw_order_id,
            network,
            coin,
            travel_rule_status,
            offset,
            limit,
            start_time,
            end_time,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = tr_id {
            query_params.insert("trId".to_string(), json!(rw));
        }

        if let Some(rw) = tx_id {
            query_params.insert("txId".to_string(), json!(rw));
        }

        if let Some(rw) = withdraw_order_id {
            query_params.insert("withdrawOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = network {
            query_params.insert("network".to_string(), json!(rw));
        }

        if let Some(rw) = coin {
            query_params.insert("coin".to_string(), json!(rw));
        }

        if let Some(rw) = travel_rule_status {
            query_params.insert("travelRuleStatus".to_string(), json!(rw));
        }

        if let Some(rw) = offset {
            query_params.insert("offset".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::WithdrawHistoryV2ResponseInner>>(
            &self.configuration,
            "/sapi/v1/localentity/withdraw/history",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn withdraw_history_v2(
        &self,
        params: WithdrawHistoryV2Params,
    ) -> anyhow::Result<RestApiResponse<Vec<models::WithdrawHistoryV2ResponseInner>>> {
        let WithdrawHistoryV2Params {
            tr_id,
            tx_id,
            withdraw_order_id,
            network,
            coin,
            travel_rule_status,
            offset,
            limit,
            start_time,
            end_time,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = tr_id {
            query_params.insert("trId".to_string(), json!(rw));
        }

        if let Some(rw) = tx_id {
            query_params.insert("txId".to_string(), json!(rw));
        }

        if let Some(rw) = withdraw_order_id {
            query_params.insert("withdrawOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = network {
            query_params.insert("network".to_string(), json!(rw));
        }

        if let Some(rw) = coin {
            query_params.insert("coin".to_string(), json!(rw));
        }

        if let Some(rw) = travel_rule_status {
            query_params.insert("travelRuleStatus".to_string(), json!(rw));
        }

        if let Some(rw) = offset {
            query_params.insert("offset".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::WithdrawHistoryV2ResponseInner>>(
            &self.configuration,
            "/sapi/v2/localentity/withdraw/history",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn withdraw_travel_rule(
        &self,
        params: WithdrawTravelRuleParams,
    ) -> anyhow::Result<RestApiResponse<models::WithdrawTravelRuleResponse>> {
        let WithdrawTravelRuleParams {
            coin,
            address,
            amount,
            questionnaire,
            withdraw_order_id,
            network,
            address_tag,
            transaction_fee_flag,
            name,
            wallet_type,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("coin".to_string(), json!(coin));

        query_params.insert("address".to_string(), json!(address));

        let amount_value = Decimal::from_f32(amount).unwrap_or_default();
        query_params.insert("amount".to_string(), json!(amount_value));

        query_params.insert("questionnaire".to_string(), json!(questionnaire));

        if let Some(rw) = withdraw_order_id {
            query_params.insert("withdrawOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = network {
            query_params.insert("network".to_string(), json!(rw));
        }

        if let Some(rw) = address_tag {
            query_params.insert("addressTag".to_string(), json!(rw));
        }

        if let Some(rw) = transaction_fee_flag {
            query_params.insert("transactionFeeFlag".to_string(), json!(rw));
        }

        if let Some(rw) = name {
            query_params.insert("name".to_string(), json!(rw));
        }

        if let Some(rw) = wallet_type {
            query_params.insert("walletType".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::WithdrawTravelRuleResponse>(
            &self.configuration,
            "/sapi/v1/localentity/withdraw/apply",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "wallet"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockTravelRuleApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl TravelRuleApi for MockTravelRuleApiClient {
        async fn broker_withdraw(
            &self,
            _params: BrokerWithdrawParams,
        ) -> anyhow::Result<RestApiResponse<models::BrokerWithdrawResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"trId":123456,"accpted":true,"info":"Withdraw request accepted"}"#,
            )
            .unwrap();
            let dummy_response: models::BrokerWithdrawResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::BrokerWithdrawResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn deposit_history_travel_rule(
            &self,
            _params: DepositHistoryTravelRuleParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::DepositHistoryTravelRuleResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"trId":123451123,"tranId":17644346245865,"amount":"0.001","coin":"BNB","network":"BNB","depositStatus":0,"travelRuleStatus":1,"address":"bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23","addressTag":"101764890","txId":"98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC","insertTime":1661493146000,"transferType":0,"confirmTimes":"1/1","unlockConfirm":0,"walletType":0,"requireQuestionnaire":true,"questionnaire":null},{"trId":2451123,"tranId":4544346245865,"amount":"0.50000000","coin":"IOTA","network":"IOTA","depositStatus":0,"travelRuleStatus":0,"address":"SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW","addressTag":"","txId":"ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999","insertTime":1599620082000,"transferType":0,"confirmTimes":"1/1","unlockConfirm":0,"walletType":0,"requireQuestionnaire":false,"questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}"}]"#).unwrap();
            let dummy_response: Vec<models::DepositHistoryTravelRuleResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::DepositHistoryTravelRuleResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn fetch_address_verification_list(
            &self,
        ) -> anyhow::Result<RestApiResponse<Vec<models::FetchAddressVerificationListResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"status":"PENDING","token":"AVAX","network":"AVAXC","walletAddress":"0xc03a6aa728a8dde7464c33828424ede7553a0021","addressQuestionnaire":{"sendTo":1,"satoshiToken":"AVAX","isAddressOwner":1,"verifyMethod":1}}]"#).unwrap();
            let dummy_response: Vec<models::FetchAddressVerificationListResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::FetchAddressVerificationListResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn onboarded_vasp_list(
            &self,
        ) -> anyhow::Result<RestApiResponse<Vec<models::OnboardedVaspListResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"vaspName":"Binance","vaspCode":"BINANCE"},{"vaspName":"HashKeyGlobal","vaspCode":"NVBH3Z_nNEHjvqbUfkaL"}]"#).unwrap();
            let dummy_response: Vec<models::OnboardedVaspListResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::OnboardedVaspListResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn submit_deposit_questionnaire(
            &self,
            _params: SubmitDepositQuestionnaireParams,
        ) -> anyhow::Result<RestApiResponse<models::SubmitDepositQuestionnaireResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"trId":765127651,"accepted":true,"info":"Deposit questionnaire accepted."}"#,
            )
            .unwrap();
            let dummy_response: models::SubmitDepositQuestionnaireResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::SubmitDepositQuestionnaireResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn submit_deposit_questionnaire_travel_rule(
            &self,
            _params: SubmitDepositQuestionnaireTravelRuleParams,
        ) -> anyhow::Result<RestApiResponse<models::SubmitDepositQuestionnaireTravelRuleResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"trId":765127651,"accepted":true,"info":"Deposit questionnaire accepted."}"#,
            )
            .unwrap();
            let dummy_response: models::SubmitDepositQuestionnaireTravelRuleResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::SubmitDepositQuestionnaireTravelRuleResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn withdraw_history_v1(
            &self,
            _params: WithdrawHistoryV1Params,
        ) -> anyhow::Result<RestApiResponse<Vec<models::WithdrawHistoryV2ResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"id":"b6ae22b3aa844210a7041aee7589627c","trId":1234456,"amount":"8.91000000","transactionFee":"0.004","coin":"USDT","withdrawalStatus":6,"travelRuleStatus":0,"address":"0x94df8b352de7f46f64b01d3666bf6e936e44ce60","addressTag":"1231212","txId":"0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268","applyTime":"2019-10-12 11:12:02","network":"ETH","transferType":0,"withdrawOrderId":"WITHDRAWtest123","info":"The address is not valid. Please confirm with the recipient","confirmNo":3,"walletType":1,"txKey":"","questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}","completeTime":"2023-03-23 16:52:41"},{"id":"156ec387f49b41df8724fa744fa82719","trId":2231556234,"amount":"0.00150000","transactionFee":"0.004","coin":"BTC","withdrawalStatus":6,"travelRuleStatus":0,"address":"1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB","txId":"60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354","applyTime":"2019-09-24 12:43:45","network":"BTC","transferType":0,"info":"","confirmNo":2,"walletType":1,"txKey":"","questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}","completeTime":"2023-03-23 16:52:41"}]"#).unwrap();
            let dummy_response: Vec<models::WithdrawHistoryV2ResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::WithdrawHistoryV2ResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn withdraw_history_v2(
            &self,
            _params: WithdrawHistoryV2Params,
        ) -> anyhow::Result<RestApiResponse<Vec<models::WithdrawHistoryV2ResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"id":"b6ae22b3aa844210a7041aee7589627c","trId":1234456,"amount":"8.91000000","transactionFee":"0.004","coin":"USDT","withdrawalStatus":6,"travelRuleStatus":0,"address":"0x94df8b352de7f46f64b01d3666bf6e936e44ce60","addressTag":"1231212","txId":"0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268","applyTime":"2019-10-12 11:12:02","network":"ETH","transferType":0,"withdrawOrderId":"WITHDRAWtest123","info":"The address is not valid. Please confirm with the recipient","confirmNo":3,"walletType":1,"txKey":"","questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}","completeTime":"2023-03-23 16:52:41"},{"id":"156ec387f49b41df8724fa744fa82719","trId":2231556234,"amount":"0.00150000","transactionFee":"0.004","coin":"BTC","withdrawalStatus":6,"travelRuleStatus":0,"address":"1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB","txId":"60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354","applyTime":"2019-09-24 12:43:45","network":"BTC","transferType":0,"info":"","confirmNo":2,"walletType":1,"txKey":"","questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}","completeTime":"2023-03-23 16:52:41"}]"#).unwrap();
            let dummy_response: Vec<models::WithdrawHistoryV2ResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::WithdrawHistoryV2ResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn withdraw_travel_rule(
            &self,
            _params: WithdrawTravelRuleParams,
        ) -> anyhow::Result<RestApiResponse<models::WithdrawTravelRuleResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"trId":123456,"accpted":true,"info":"Withdraw request accepted"}"#,
            )
            .unwrap();
            let dummy_response: models::WithdrawTravelRuleResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::WithdrawTravelRuleResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn broker_withdraw_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = BrokerWithdrawParams::builder(
                "address_example".to_string(),
                "coin_example".to_string(),
                1.0,
                "1".to_string(),
                "questionnaire_example".to_string(),
                "originator_pii_example".to_string(),
                "signature_example".to_string(),
            )
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"trId":123456,"accpted":true,"info":"Withdraw request accepted"}"#,
            )
            .unwrap();
            let expected_response: models::BrokerWithdrawResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::BrokerWithdrawResponse");

            let resp = client
                .broker_withdraw(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn broker_withdraw_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = BrokerWithdrawParams::builder(
                "address_example".to_string(),
                "coin_example".to_string(),
                1.0,
                "1".to_string(),
                "questionnaire_example".to_string(),
                "originator_pii_example".to_string(),
                "signature_example".to_string(),
            )
            .address_tag("address_tag_example".to_string())
            .network("network_example".to_string())
            .address_name("address_name_example".to_string())
            .transaction_fee_flag(false)
            .wallet_type(0)
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"trId":123456,"accpted":true,"info":"Withdraw request accepted"}"#,
            )
            .unwrap();
            let expected_response: models::BrokerWithdrawResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::BrokerWithdrawResponse");

            let resp = client
                .broker_withdraw(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn broker_withdraw_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: true };

            let params = BrokerWithdrawParams::builder(
                "address_example".to_string(),
                "coin_example".to_string(),
                1.0,
                "1".to_string(),
                "questionnaire_example".to_string(),
                "originator_pii_example".to_string(),
                "signature_example".to_string(),
            )
            .build()
            .unwrap();

            match client.broker_withdraw(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn deposit_history_travel_rule_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = DepositHistoryTravelRuleParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"trId":123451123,"tranId":17644346245865,"amount":"0.001","coin":"BNB","network":"BNB","depositStatus":0,"travelRuleStatus":1,"address":"bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23","addressTag":"101764890","txId":"98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC","insertTime":1661493146000,"transferType":0,"confirmTimes":"1/1","unlockConfirm":0,"walletType":0,"requireQuestionnaire":true,"questionnaire":null},{"trId":2451123,"tranId":4544346245865,"amount":"0.50000000","coin":"IOTA","network":"IOTA","depositStatus":0,"travelRuleStatus":0,"address":"SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW","addressTag":"","txId":"ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999","insertTime":1599620082000,"transferType":0,"confirmTimes":"1/1","unlockConfirm":0,"walletType":0,"requireQuestionnaire":false,"questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}"}]"#).unwrap();
            let expected_response : Vec<models::DepositHistoryTravelRuleResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::DepositHistoryTravelRuleResponseInner>");

            let resp = client.deposit_history_travel_rule(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn deposit_history_travel_rule_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = DepositHistoryTravelRuleParams::builder().tr_id("1".to_string()).tx_id("1".to_string()).tran_id("1".to_string()).network("network_example".to_string()).coin("coin_example".to_string()).travel_rule_status(789).pending_questionnaire(true).start_time(1623319461670).end_time(1641782889000).offset(0).limit(7).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"trId":123451123,"tranId":17644346245865,"amount":"0.001","coin":"BNB","network":"BNB","depositStatus":0,"travelRuleStatus":1,"address":"bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23","addressTag":"101764890","txId":"98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC","insertTime":1661493146000,"transferType":0,"confirmTimes":"1/1","unlockConfirm":0,"walletType":0,"requireQuestionnaire":true,"questionnaire":null},{"trId":2451123,"tranId":4544346245865,"amount":"0.50000000","coin":"IOTA","network":"IOTA","depositStatus":0,"travelRuleStatus":0,"address":"SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW","addressTag":"","txId":"ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999","insertTime":1599620082000,"transferType":0,"confirmTimes":"1/1","unlockConfirm":0,"walletType":0,"requireQuestionnaire":false,"questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}"}]"#).unwrap();
            let expected_response : Vec<models::DepositHistoryTravelRuleResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::DepositHistoryTravelRuleResponseInner>");

            let resp = client.deposit_history_travel_rule(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn deposit_history_travel_rule_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: true };

            let params = DepositHistoryTravelRuleParams::builder().build().unwrap();

            match client.deposit_history_travel_rule(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn fetch_address_verification_list_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };


            let resp_json: Value = serde_json::from_str(r#"[{"status":"PENDING","token":"AVAX","network":"AVAXC","walletAddress":"0xc03a6aa728a8dde7464c33828424ede7553a0021","addressQuestionnaire":{"sendTo":1,"satoshiToken":"AVAX","isAddressOwner":1,"verifyMethod":1}}]"#).unwrap();
            let expected_response : Vec<models::FetchAddressVerificationListResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::FetchAddressVerificationListResponseInner>");

            let resp = client.fetch_address_verification_list().await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn fetch_address_verification_list_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };


            let resp_json: Value = serde_json::from_str(r#"[{"status":"PENDING","token":"AVAX","network":"AVAXC","walletAddress":"0xc03a6aa728a8dde7464c33828424ede7553a0021","addressQuestionnaire":{"sendTo":1,"satoshiToken":"AVAX","isAddressOwner":1,"verifyMethod":1}}]"#).unwrap();
            let expected_response : Vec<models::FetchAddressVerificationListResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::FetchAddressVerificationListResponseInner>");

            let resp = client.fetch_address_verification_list().await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn fetch_address_verification_list_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: true };

            match client.fetch_address_verification_list().await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn onboarded_vasp_list_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };


            let resp_json: Value = serde_json::from_str(r#"[{"vaspName":"Binance","vaspCode":"BINANCE"},{"vaspName":"HashKeyGlobal","vaspCode":"NVBH3Z_nNEHjvqbUfkaL"}]"#).unwrap();
            let expected_response : Vec<models::OnboardedVaspListResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::OnboardedVaspListResponseInner>");

            let resp = client.onboarded_vasp_list().await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn onboarded_vasp_list_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };


            let resp_json: Value = serde_json::from_str(r#"[{"vaspName":"Binance","vaspCode":"BINANCE"},{"vaspName":"HashKeyGlobal","vaspCode":"NVBH3Z_nNEHjvqbUfkaL"}]"#).unwrap();
            let expected_response : Vec<models::OnboardedVaspListResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::OnboardedVaspListResponseInner>");

            let resp = client.onboarded_vasp_list().await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn onboarded_vasp_list_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: true };

            match client.onboarded_vasp_list().await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn submit_deposit_questionnaire_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = SubmitDepositQuestionnaireParams::builder(
                "1".to_string(),
                "1".to_string(),
                "questionnaire_example".to_string(),
                "beneficiary_pii_example".to_string(),
                "signature_example".to_string(),
            )
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"trId":765127651,"accepted":true,"info":"Deposit questionnaire accepted."}"#,
            )
            .unwrap();
            let expected_response: models::SubmitDepositQuestionnaireResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::SubmitDepositQuestionnaireResponse");

            let resp = client
                .submit_deposit_questionnaire(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn submit_deposit_questionnaire_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = SubmitDepositQuestionnaireParams::builder(
                "1".to_string(),
                "1".to_string(),
                "questionnaire_example".to_string(),
                "beneficiary_pii_example".to_string(),
                "signature_example".to_string(),
            )
            .network("network_example".to_string())
            .coin("coin_example".to_string())
            .amount(1.0)
            .address("address_example".to_string())
            .address_tag("address_tag_example".to_string())
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"trId":765127651,"accepted":true,"info":"Deposit questionnaire accepted."}"#,
            )
            .unwrap();
            let expected_response: models::SubmitDepositQuestionnaireResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::SubmitDepositQuestionnaireResponse");

            let resp = client
                .submit_deposit_questionnaire(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn submit_deposit_questionnaire_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: true };

            let params = SubmitDepositQuestionnaireParams::builder(
                "1".to_string(),
                "1".to_string(),
                "questionnaire_example".to_string(),
                "beneficiary_pii_example".to_string(),
                "signature_example".to_string(),
            )
            .build()
            .unwrap();

            match client.submit_deposit_questionnaire(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn submit_deposit_questionnaire_travel_rule_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = SubmitDepositQuestionnaireTravelRuleParams::builder(
                1,
                "questionnaire_example".to_string(),
            )
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"trId":765127651,"accepted":true,"info":"Deposit questionnaire accepted."}"#,
            )
            .unwrap();
            let expected_response: models::SubmitDepositQuestionnaireTravelRuleResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::SubmitDepositQuestionnaireTravelRuleResponse",
                );

            let resp = client
                .submit_deposit_questionnaire_travel_rule(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn submit_deposit_questionnaire_travel_rule_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = SubmitDepositQuestionnaireTravelRuleParams::builder(
                1,
                "questionnaire_example".to_string(),
            )
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"trId":765127651,"accepted":true,"info":"Deposit questionnaire accepted."}"#,
            )
            .unwrap();
            let expected_response: models::SubmitDepositQuestionnaireTravelRuleResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::SubmitDepositQuestionnaireTravelRuleResponse",
                );

            let resp = client
                .submit_deposit_questionnaire_travel_rule(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn submit_deposit_questionnaire_travel_rule_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: true };

            let params = SubmitDepositQuestionnaireTravelRuleParams::builder(
                1,
                "questionnaire_example".to_string(),
            )
            .build()
            .unwrap();

            match client
                .submit_deposit_questionnaire_travel_rule(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn withdraw_history_v1_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = WithdrawHistoryV1Params::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":"b6ae22b3aa844210a7041aee7589627c","trId":1234456,"amount":"8.91000000","transactionFee":"0.004","coin":"USDT","withdrawalStatus":6,"travelRuleStatus":0,"address":"0x94df8b352de7f46f64b01d3666bf6e936e44ce60","addressTag":"1231212","txId":"0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268","applyTime":"2019-10-12 11:12:02","network":"ETH","transferType":0,"withdrawOrderId":"WITHDRAWtest123","info":"The address is not valid. Please confirm with the recipient","confirmNo":3,"walletType":1,"txKey":"","questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}","completeTime":"2023-03-23 16:52:41"},{"id":"156ec387f49b41df8724fa744fa82719","trId":2231556234,"amount":"0.00150000","transactionFee":"0.004","coin":"BTC","withdrawalStatus":6,"travelRuleStatus":0,"address":"1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB","txId":"60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354","applyTime":"2019-09-24 12:43:45","network":"BTC","transferType":0,"info":"","confirmNo":2,"walletType":1,"txKey":"","questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}","completeTime":"2023-03-23 16:52:41"}]"#).unwrap();
            let expected_response : Vec<models::WithdrawHistoryV2ResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::WithdrawHistoryV2ResponseInner>");

            let resp = client.withdraw_history_v1(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn withdraw_history_v1_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = WithdrawHistoryV1Params::builder().tr_id("1".to_string()).tx_id("1".to_string()).withdraw_order_id("1".to_string()).network("network_example".to_string()).coin("coin_example".to_string()).travel_rule_status(789).offset(0).limit(7).start_time(1623319461670).end_time(1641782889000).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":"b6ae22b3aa844210a7041aee7589627c","trId":1234456,"amount":"8.91000000","transactionFee":"0.004","coin":"USDT","withdrawalStatus":6,"travelRuleStatus":0,"address":"0x94df8b352de7f46f64b01d3666bf6e936e44ce60","addressTag":"1231212","txId":"0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268","applyTime":"2019-10-12 11:12:02","network":"ETH","transferType":0,"withdrawOrderId":"WITHDRAWtest123","info":"The address is not valid. Please confirm with the recipient","confirmNo":3,"walletType":1,"txKey":"","questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}","completeTime":"2023-03-23 16:52:41"},{"id":"156ec387f49b41df8724fa744fa82719","trId":2231556234,"amount":"0.00150000","transactionFee":"0.004","coin":"BTC","withdrawalStatus":6,"travelRuleStatus":0,"address":"1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB","txId":"60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354","applyTime":"2019-09-24 12:43:45","network":"BTC","transferType":0,"info":"","confirmNo":2,"walletType":1,"txKey":"","questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}","completeTime":"2023-03-23 16:52:41"}]"#).unwrap();
            let expected_response : Vec<models::WithdrawHistoryV2ResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::WithdrawHistoryV2ResponseInner>");

            let resp = client.withdraw_history_v1(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn withdraw_history_v1_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: true };

            let params = WithdrawHistoryV1Params::builder().build().unwrap();

            match client.withdraw_history_v1(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn withdraw_history_v2_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = WithdrawHistoryV2Params::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":"b6ae22b3aa844210a7041aee7589627c","trId":1234456,"amount":"8.91000000","transactionFee":"0.004","coin":"USDT","withdrawalStatus":6,"travelRuleStatus":0,"address":"0x94df8b352de7f46f64b01d3666bf6e936e44ce60","addressTag":"1231212","txId":"0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268","applyTime":"2019-10-12 11:12:02","network":"ETH","transferType":0,"withdrawOrderId":"WITHDRAWtest123","info":"The address is not valid. Please confirm with the recipient","confirmNo":3,"walletType":1,"txKey":"","questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}","completeTime":"2023-03-23 16:52:41"},{"id":"156ec387f49b41df8724fa744fa82719","trId":2231556234,"amount":"0.00150000","transactionFee":"0.004","coin":"BTC","withdrawalStatus":6,"travelRuleStatus":0,"address":"1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB","txId":"60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354","applyTime":"2019-09-24 12:43:45","network":"BTC","transferType":0,"info":"","confirmNo":2,"walletType":1,"txKey":"","questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}","completeTime":"2023-03-23 16:52:41"}]"#).unwrap();
            let expected_response : Vec<models::WithdrawHistoryV2ResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::WithdrawHistoryV2ResponseInner>");

            let resp = client.withdraw_history_v2(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn withdraw_history_v2_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = WithdrawHistoryV2Params::builder().tr_id("1".to_string()).tx_id("1".to_string()).withdraw_order_id("1".to_string()).network("network_example".to_string()).coin("coin_example".to_string()).travel_rule_status(789).offset(0).limit(7).start_time(1623319461670).end_time(1641782889000).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":"b6ae22b3aa844210a7041aee7589627c","trId":1234456,"amount":"8.91000000","transactionFee":"0.004","coin":"USDT","withdrawalStatus":6,"travelRuleStatus":0,"address":"0x94df8b352de7f46f64b01d3666bf6e936e44ce60","addressTag":"1231212","txId":"0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268","applyTime":"2019-10-12 11:12:02","network":"ETH","transferType":0,"withdrawOrderId":"WITHDRAWtest123","info":"The address is not valid. Please confirm with the recipient","confirmNo":3,"walletType":1,"txKey":"","questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}","completeTime":"2023-03-23 16:52:41"},{"id":"156ec387f49b41df8724fa744fa82719","trId":2231556234,"amount":"0.00150000","transactionFee":"0.004","coin":"BTC","withdrawalStatus":6,"travelRuleStatus":0,"address":"1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB","txId":"60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354","applyTime":"2019-09-24 12:43:45","network":"BTC","transferType":0,"info":"","confirmNo":2,"walletType":1,"txKey":"","questionnaire":"{\"question1\":\"answer1\",\"question2\":\"answer2\"}","completeTime":"2023-03-23 16:52:41"}]"#).unwrap();
            let expected_response : Vec<models::WithdrawHistoryV2ResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::WithdrawHistoryV2ResponseInner>");

            let resp = client.withdraw_history_v2(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn withdraw_history_v2_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: true };

            let params = WithdrawHistoryV2Params::builder().build().unwrap();

            match client.withdraw_history_v2(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn withdraw_travel_rule_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = WithdrawTravelRuleParams::builder(
                "coin_example".to_string(),
                "address_example".to_string(),
                1.0,
                "questionnaire_example".to_string(),
            )
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"trId":123456,"accpted":true,"info":"Withdraw request accepted"}"#,
            )
            .unwrap();
            let expected_response: models::WithdrawTravelRuleResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::WithdrawTravelRuleResponse");

            let resp = client
                .withdraw_travel_rule(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn withdraw_travel_rule_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: false };

            let params = WithdrawTravelRuleParams::builder(
                "coin_example".to_string(),
                "address_example".to_string(),
                1.0,
                "questionnaire_example".to_string(),
            )
            .withdraw_order_id("1".to_string())
            .network("network_example".to_string())
            .address_tag("address_tag_example".to_string())
            .transaction_fee_flag(false)
            .name("name_example".to_string())
            .wallet_type(0)
            .recv_window(5000)
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"trId":123456,"accpted":true,"info":"Withdraw request accepted"}"#,
            )
            .unwrap();
            let expected_response: models::WithdrawTravelRuleResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::WithdrawTravelRuleResponse");

            let resp = client
                .withdraw_travel_rule(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn withdraw_travel_rule_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTravelRuleApiClient { force_error: true };

            let params = WithdrawTravelRuleParams::builder(
                "coin_example".to_string(),
                "address_example".to_string(),
                1.0,
                "questionnaire_example".to_string(),
            )
            .build()
            .unwrap();

            match client.withdraw_travel_rule(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
