/*
 * Binance Derivatives Trading Portfolio Margin Pro REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin Pro REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::derivatives_trading_portfolio_margin_pro::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait AccountApi: Send + Sync {
    async fn bnb_transfer(
        &self,
        params: BnbTransferParams,
    ) -> anyhow::Result<RestApiResponse<models::BnbTransferResponse>>;
    async fn change_auto_repay_futures_status(
        &self,
        params: ChangeAutoRepayFuturesStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::ChangeAutoRepayFuturesStatusResponse>>;
    async fn fund_auto_collection(
        &self,
        params: FundAutoCollectionParams,
    ) -> anyhow::Result<RestApiResponse<models::FundAutoCollectionResponse>>;
    async fn fund_collection_by_asset(
        &self,
        params: FundCollectionByAssetParams,
    ) -> anyhow::Result<RestApiResponse<models::FundCollectionByAssetResponse>>;
    async fn get_auto_repay_futures_status(
        &self,
        params: GetAutoRepayFuturesStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::GetAutoRepayFuturesStatusResponse>>;
    async fn get_portfolio_margin_pro_account_balance(
        &self,
        params: GetPortfolioMarginProAccountBalanceParams,
    ) -> anyhow::Result<
        RestApiResponse<Vec<models::GetPortfolioMarginProAccountBalanceResponseInner>>,
    >;
    async fn get_portfolio_margin_pro_account_info(
        &self,
        params: GetPortfolioMarginProAccountInfoParams,
    ) -> anyhow::Result<RestApiResponse<models::GetPortfolioMarginProAccountInfoResponse>>;
    async fn get_portfolio_margin_pro_span_account_info(
        &self,
        params: GetPortfolioMarginProSpanAccountInfoParams,
    ) -> anyhow::Result<RestApiResponse<models::GetPortfolioMarginProSpanAccountInfoResponse>>;
    async fn get_transferable_earn_asset_balance_for_portfolio_margin(
        &self,
        params: GetTransferableEarnAssetBalanceForPortfolioMarginParams,
    ) -> anyhow::Result<
        RestApiResponse<models::GetTransferableEarnAssetBalanceForPortfolioMarginResponse>,
    >;
    async fn mint_bfusd_for_portfolio_margin(
        &self,
        params: MintBfusdForPortfolioMarginParams,
    ) -> anyhow::Result<RestApiResponse<models::MintBfusdForPortfolioMarginResponse>>;
    async fn portfolio_margin_pro_bankruptcy_loan_repay(
        &self,
        params: PortfolioMarginProBankruptcyLoanRepayParams,
    ) -> anyhow::Result<RestApiResponse<models::PortfolioMarginProBankruptcyLoanRepayResponse>>;
    async fn query_portfolio_margin_pro_bankruptcy_loan_amount(
        &self,
        params: QueryPortfolioMarginProBankruptcyLoanAmountParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryPortfolioMarginProBankruptcyLoanAmountResponse>>;
    async fn query_portfolio_margin_pro_bankruptcy_loan_repay_history(
        &self,
        params: QueryPortfolioMarginProBankruptcyLoanRepayHistoryParams,
    ) -> anyhow::Result<
        RestApiResponse<models::QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse>,
    >;
    async fn query_portfolio_margin_pro_negative_balance_interest_history(
        &self,
        params: QueryPortfolioMarginProNegativeBalanceInterestHistoryParams,
    ) -> anyhow::Result<
        RestApiResponse<
            Vec<models::QueryPortfolioMarginProNegativeBalanceInterestHistoryResponseInner>,
        >,
    >;
    async fn redeem_bfusd_for_portfolio_margin(
        &self,
        params: RedeemBfusdForPortfolioMarginParams,
    ) -> anyhow::Result<RestApiResponse<models::RedeemBfusdForPortfolioMarginResponse>>;
    async fn repay_futures_negative_balance(
        &self,
        params: RepayFuturesNegativeBalanceParams,
    ) -> anyhow::Result<RestApiResponse<models::RepayFuturesNegativeBalanceResponse>>;
    async fn transfer_ldusdt_for_portfolio_margin(
        &self,
        params: TransferLdusdtForPortfolioMarginParams,
    ) -> anyhow::Result<RestApiResponse<models::TransferLdusdtForPortfolioMarginResponse>>;
}

#[derive(Debug, Clone)]
pub struct AccountApiClient {
    configuration: ConfigurationRestApi,
}

impl AccountApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`bnb_transfer`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`bnb_transfer`](#method.bnb_transfer).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct BnbTransferParams {
    ///
    /// The `amount` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: f32,
    /// "`TO_UM","FROM_UM`"
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub transfer_side: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl BnbTransferParams {
    /// Create a builder for [`bnb_transfer`].
    ///
    /// Required parameters:
    ///
    /// * `amount` — f32
    /// * `transfer_side` — \"`TO_UM`\",\"`FROM_UM`\"
    ///
    #[must_use]
    pub fn builder(amount: f32, transfer_side: String) -> BnbTransferParamsBuilder {
        BnbTransferParamsBuilder::default()
            .amount(amount)
            .transfer_side(transfer_side)
    }
}
/// Request parameters for the [`change_auto_repay_futures_status`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`change_auto_repay_futures_status`](#method.change_auto_repay_futures_status).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct ChangeAutoRepayFuturesStatusParams {
    /// Default: `true`; `false` for turn off the auto-repay futures negative balance function
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub auto_repay: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl ChangeAutoRepayFuturesStatusParams {
    /// Create a builder for [`change_auto_repay_futures_status`].
    ///
    /// Required parameters:
    ///
    /// * `auto_repay` — Default: `true`; `false` for turn off the auto-repay futures negative balance function
    ///
    #[must_use]
    pub fn builder(auto_repay: String) -> ChangeAutoRepayFuturesStatusParamsBuilder {
        ChangeAutoRepayFuturesStatusParamsBuilder::default().auto_repay(auto_repay)
    }
}
/// Request parameters for the [`fund_auto_collection`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`fund_auto_collection`](#method.fund_auto_collection).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct FundAutoCollectionParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl FundAutoCollectionParams {
    /// Create a builder for [`fund_auto_collection`].
    ///
    #[must_use]
    pub fn builder() -> FundAutoCollectionParamsBuilder {
        FundAutoCollectionParamsBuilder::default()
    }
}
/// Request parameters for the [`fund_collection_by_asset`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`fund_collection_by_asset`](#method.fund_collection_by_asset).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct FundCollectionByAssetParams {
    /// `LDUSDT` only
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub asset: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl FundCollectionByAssetParams {
    /// Create a builder for [`fund_collection_by_asset`].
    ///
    /// Required parameters:
    ///
    /// * `asset` — `LDUSDT` only
    ///
    #[must_use]
    pub fn builder(asset: String) -> FundCollectionByAssetParamsBuilder {
        FundCollectionByAssetParamsBuilder::default().asset(asset)
    }
}
/// Request parameters for the [`get_auto_repay_futures_status`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_auto_repay_futures_status`](#method.get_auto_repay_futures_status).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetAutoRepayFuturesStatusParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetAutoRepayFuturesStatusParams {
    /// Create a builder for [`get_auto_repay_futures_status`].
    ///
    #[must_use]
    pub fn builder() -> GetAutoRepayFuturesStatusParamsBuilder {
        GetAutoRepayFuturesStatusParamsBuilder::default()
    }
}
/// Request parameters for the [`get_portfolio_margin_pro_account_balance`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_portfolio_margin_pro_account_balance`](#method.get_portfolio_margin_pro_account_balance).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetPortfolioMarginProAccountBalanceParams {
    ///
    /// The `asset` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub asset: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetPortfolioMarginProAccountBalanceParams {
    /// Create a builder for [`get_portfolio_margin_pro_account_balance`].
    ///
    #[must_use]
    pub fn builder() -> GetPortfolioMarginProAccountBalanceParamsBuilder {
        GetPortfolioMarginProAccountBalanceParamsBuilder::default()
    }
}
/// Request parameters for the [`get_portfolio_margin_pro_account_info`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_portfolio_margin_pro_account_info`](#method.get_portfolio_margin_pro_account_info).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetPortfolioMarginProAccountInfoParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetPortfolioMarginProAccountInfoParams {
    /// Create a builder for [`get_portfolio_margin_pro_account_info`].
    ///
    #[must_use]
    pub fn builder() -> GetPortfolioMarginProAccountInfoParamsBuilder {
        GetPortfolioMarginProAccountInfoParamsBuilder::default()
    }
}
/// Request parameters for the [`get_portfolio_margin_pro_span_account_info`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_portfolio_margin_pro_span_account_info`](#method.get_portfolio_margin_pro_span_account_info).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetPortfolioMarginProSpanAccountInfoParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetPortfolioMarginProSpanAccountInfoParams {
    /// Create a builder for [`get_portfolio_margin_pro_span_account_info`].
    ///
    #[must_use]
    pub fn builder() -> GetPortfolioMarginProSpanAccountInfoParamsBuilder {
        GetPortfolioMarginProSpanAccountInfoParamsBuilder::default()
    }
}
/// Request parameters for the [`get_transferable_earn_asset_balance_for_portfolio_margin`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_transferable_earn_asset_balance_for_portfolio_margin`](#method.get_transferable_earn_asset_balance_for_portfolio_margin).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetTransferableEarnAssetBalanceForPortfolioMarginParams {
    /// `LDUSDT` only
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub asset: String,
    /// `EARN_TO_FUTURE` /`FUTURE_TO_EARN`
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub transfer_type: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetTransferableEarnAssetBalanceForPortfolioMarginParams {
    /// Create a builder for [`get_transferable_earn_asset_balance_for_portfolio_margin`].
    ///
    /// Required parameters:
    ///
    /// * `asset` — `LDUSDT` only
    /// * `transfer_type` — `EARN_TO_FUTURE` /`FUTURE_TO_EARN`
    ///
    #[must_use]
    pub fn builder(
        asset: String,
        transfer_type: String,
    ) -> GetTransferableEarnAssetBalanceForPortfolioMarginParamsBuilder {
        GetTransferableEarnAssetBalanceForPortfolioMarginParamsBuilder::default()
            .asset(asset)
            .transfer_type(transfer_type)
    }
}
/// Request parameters for the [`mint_bfusd_for_portfolio_margin`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`mint_bfusd_for_portfolio_margin`](#method.mint_bfusd_for_portfolio_margin).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct MintBfusdForPortfolioMarginParams {
    /// `BFUSD` only
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub from_asset: String,
    /// `USDT` only
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub target_asset: String,
    ///
    /// The `amount` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: f32,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl MintBfusdForPortfolioMarginParams {
    /// Create a builder for [`mint_bfusd_for_portfolio_margin`].
    ///
    /// Required parameters:
    ///
    /// * `from_asset` — `BFUSD` only
    /// * `target_asset` — `USDT` only
    /// * `amount` — f32
    ///
    #[must_use]
    pub fn builder(
        from_asset: String,
        target_asset: String,
        amount: f32,
    ) -> MintBfusdForPortfolioMarginParamsBuilder {
        MintBfusdForPortfolioMarginParamsBuilder::default()
            .from_asset(from_asset)
            .target_asset(target_asset)
            .amount(amount)
    }
}
/// Request parameters for the [`portfolio_margin_pro_bankruptcy_loan_repay`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`portfolio_margin_pro_bankruptcy_loan_repay`](#method.portfolio_margin_pro_bankruptcy_loan_repay).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct PortfolioMarginProBankruptcyLoanRepayParams {
    /// SPOT or MARGIN，default SPOT
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl PortfolioMarginProBankruptcyLoanRepayParams {
    /// Create a builder for [`portfolio_margin_pro_bankruptcy_loan_repay`].
    ///
    #[must_use]
    pub fn builder() -> PortfolioMarginProBankruptcyLoanRepayParamsBuilder {
        PortfolioMarginProBankruptcyLoanRepayParamsBuilder::default()
    }
}
/// Request parameters for the [`query_portfolio_margin_pro_bankruptcy_loan_amount`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_portfolio_margin_pro_bankruptcy_loan_amount`](#method.query_portfolio_margin_pro_bankruptcy_loan_amount).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryPortfolioMarginProBankruptcyLoanAmountParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryPortfolioMarginProBankruptcyLoanAmountParams {
    /// Create a builder for [`query_portfolio_margin_pro_bankruptcy_loan_amount`].
    ///
    #[must_use]
    pub fn builder() -> QueryPortfolioMarginProBankruptcyLoanAmountParamsBuilder {
        QueryPortfolioMarginProBankruptcyLoanAmountParamsBuilder::default()
    }
}
/// Request parameters for the [`query_portfolio_margin_pro_bankruptcy_loan_repay_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_portfolio_margin_pro_bankruptcy_loan_repay_history`](#method.query_portfolio_margin_pro_bankruptcy_loan_repay_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryPortfolioMarginProBankruptcyLoanRepayHistoryParams {
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10 Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryPortfolioMarginProBankruptcyLoanRepayHistoryParams {
    /// Create a builder for [`query_portfolio_margin_pro_bankruptcy_loan_repay_history`].
    ///
    #[must_use]
    pub fn builder() -> QueryPortfolioMarginProBankruptcyLoanRepayHistoryParamsBuilder {
        QueryPortfolioMarginProBankruptcyLoanRepayHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`query_portfolio_margin_pro_negative_balance_interest_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_portfolio_margin_pro_negative_balance_interest_history`](#method.query_portfolio_margin_pro_negative_balance_interest_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryPortfolioMarginProNegativeBalanceInterestHistoryParams {
    ///
    /// The `asset` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub asset: Option<String>,
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default:10 Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryPortfolioMarginProNegativeBalanceInterestHistoryParams {
    /// Create a builder for [`query_portfolio_margin_pro_negative_balance_interest_history`].
    ///
    #[must_use]
    pub fn builder() -> QueryPortfolioMarginProNegativeBalanceInterestHistoryParamsBuilder {
        QueryPortfolioMarginProNegativeBalanceInterestHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`redeem_bfusd_for_portfolio_margin`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`redeem_bfusd_for_portfolio_margin`](#method.redeem_bfusd_for_portfolio_margin).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct RedeemBfusdForPortfolioMarginParams {
    /// `BFUSD` only
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub from_asset: String,
    /// `USDT` only
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub target_asset: String,
    ///
    /// The `amount` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: f32,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl RedeemBfusdForPortfolioMarginParams {
    /// Create a builder for [`redeem_bfusd_for_portfolio_margin`].
    ///
    /// Required parameters:
    ///
    /// * `from_asset` — `BFUSD` only
    /// * `target_asset` — `USDT` only
    /// * `amount` — f32
    ///
    #[must_use]
    pub fn builder(
        from_asset: String,
        target_asset: String,
        amount: f32,
    ) -> RedeemBfusdForPortfolioMarginParamsBuilder {
        RedeemBfusdForPortfolioMarginParamsBuilder::default()
            .from_asset(from_asset)
            .target_asset(target_asset)
            .amount(amount)
    }
}
/// Request parameters for the [`repay_futures_negative_balance`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`repay_futures_negative_balance`](#method.repay_futures_negative_balance).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct RepayFuturesNegativeBalanceParams {
    /// SPOT or MARGIN，default SPOT
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl RepayFuturesNegativeBalanceParams {
    /// Create a builder for [`repay_futures_negative_balance`].
    ///
    #[must_use]
    pub fn builder() -> RepayFuturesNegativeBalanceParamsBuilder {
        RepayFuturesNegativeBalanceParamsBuilder::default()
    }
}
/// Request parameters for the [`transfer_ldusdt_for_portfolio_margin`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`transfer_ldusdt_for_portfolio_margin`](#method.transfer_ldusdt_for_portfolio_margin).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TransferLdusdtForPortfolioMarginParams {
    /// `LDUSDT` only
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub asset: String,
    /// `EARN_TO_FUTURE` /`FUTURE_TO_EARN`
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub transfer_type: String,
    ///
    /// The `amount` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: f32,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl TransferLdusdtForPortfolioMarginParams {
    /// Create a builder for [`transfer_ldusdt_for_portfolio_margin`].
    ///
    /// Required parameters:
    ///
    /// * `asset` — `LDUSDT` only
    /// * `transfer_type` — `EARN_TO_FUTURE` /`FUTURE_TO_EARN`
    /// * `amount` — f32
    ///
    #[must_use]
    pub fn builder(
        asset: String,
        transfer_type: String,
        amount: f32,
    ) -> TransferLdusdtForPortfolioMarginParamsBuilder {
        TransferLdusdtForPortfolioMarginParamsBuilder::default()
            .asset(asset)
            .transfer_type(transfer_type)
            .amount(amount)
    }
}

#[async_trait]
impl AccountApi for AccountApiClient {
    async fn bnb_transfer(
        &self,
        params: BnbTransferParams,
    ) -> anyhow::Result<RestApiResponse<models::BnbTransferResponse>> {
        let BnbTransferParams {
            amount,
            transfer_side,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        let amount_value = Decimal::from_f32(amount).unwrap_or_default();
        query_params.insert("amount".to_string(), json!(amount_value));

        query_params.insert("transferSide".to_string(), json!(transfer_side));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::BnbTransferResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/bnb-transfer",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn change_auto_repay_futures_status(
        &self,
        params: ChangeAutoRepayFuturesStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::ChangeAutoRepayFuturesStatusResponse>> {
        let ChangeAutoRepayFuturesStatusParams {
            auto_repay,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("autoRepay".to_string(), json!(auto_repay));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::ChangeAutoRepayFuturesStatusResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/repay-futures-switch",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn fund_auto_collection(
        &self,
        params: FundAutoCollectionParams,
    ) -> anyhow::Result<RestApiResponse<models::FundAutoCollectionResponse>> {
        let FundAutoCollectionParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::FundAutoCollectionResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/auto-collection",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn fund_collection_by_asset(
        &self,
        params: FundCollectionByAssetParams,
    ) -> anyhow::Result<RestApiResponse<models::FundCollectionByAssetResponse>> {
        let FundCollectionByAssetParams { asset, recv_window } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("asset".to_string(), json!(asset));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::FundCollectionByAssetResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/asset-collection",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_auto_repay_futures_status(
        &self,
        params: GetAutoRepayFuturesStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::GetAutoRepayFuturesStatusResponse>> {
        let GetAutoRepayFuturesStatusParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetAutoRepayFuturesStatusResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/repay-futures-switch",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_portfolio_margin_pro_account_balance(
        &self,
        params: GetPortfolioMarginProAccountBalanceParams,
    ) -> anyhow::Result<
        RestApiResponse<Vec<models::GetPortfolioMarginProAccountBalanceResponseInner>>,
    > {
        let GetPortfolioMarginProAccountBalanceParams { asset, recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = asset {
            query_params.insert("asset".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::GetPortfolioMarginProAccountBalanceResponseInner>>(
            &self.configuration,
            "/sapi/v1/portfolio/balance",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_portfolio_margin_pro_account_info(
        &self,
        params: GetPortfolioMarginProAccountInfoParams,
    ) -> anyhow::Result<RestApiResponse<models::GetPortfolioMarginProAccountInfoResponse>> {
        let GetPortfolioMarginProAccountInfoParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetPortfolioMarginProAccountInfoResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/account",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_portfolio_margin_pro_span_account_info(
        &self,
        params: GetPortfolioMarginProSpanAccountInfoParams,
    ) -> anyhow::Result<RestApiResponse<models::GetPortfolioMarginProSpanAccountInfoResponse>> {
        let GetPortfolioMarginProSpanAccountInfoParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetPortfolioMarginProSpanAccountInfoResponse>(
            &self.configuration,
            "/sapi/v2/portfolio/account",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_transferable_earn_asset_balance_for_portfolio_margin(
        &self,
        params: GetTransferableEarnAssetBalanceForPortfolioMarginParams,
    ) -> anyhow::Result<
        RestApiResponse<models::GetTransferableEarnAssetBalanceForPortfolioMarginResponse>,
    > {
        let GetTransferableEarnAssetBalanceForPortfolioMarginParams {
            asset,
            transfer_type,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("asset".to_string(), json!(asset));

        query_params.insert("transferType".to_string(), json!(transfer_type));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetTransferableEarnAssetBalanceForPortfolioMarginResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/earn-asset-balance",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn mint_bfusd_for_portfolio_margin(
        &self,
        params: MintBfusdForPortfolioMarginParams,
    ) -> anyhow::Result<RestApiResponse<models::MintBfusdForPortfolioMarginResponse>> {
        let MintBfusdForPortfolioMarginParams {
            from_asset,
            target_asset,
            amount,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("fromAsset".to_string(), json!(from_asset));

        query_params.insert("targetAsset".to_string(), json!(target_asset));

        let amount_value = Decimal::from_f32(amount).unwrap_or_default();
        query_params.insert("amount".to_string(), json!(amount_value));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::MintBfusdForPortfolioMarginResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/mint",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn portfolio_margin_pro_bankruptcy_loan_repay(
        &self,
        params: PortfolioMarginProBankruptcyLoanRepayParams,
    ) -> anyhow::Result<RestApiResponse<models::PortfolioMarginProBankruptcyLoanRepayResponse>>
    {
        let PortfolioMarginProBankruptcyLoanRepayParams { from, recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = from {
            query_params.insert("from".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::PortfolioMarginProBankruptcyLoanRepayResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/repay",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_portfolio_margin_pro_bankruptcy_loan_amount(
        &self,
        params: QueryPortfolioMarginProBankruptcyLoanAmountParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryPortfolioMarginProBankruptcyLoanAmountResponse>>
    {
        let QueryPortfolioMarginProBankruptcyLoanAmountParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryPortfolioMarginProBankruptcyLoanAmountResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/pmLoan",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_portfolio_margin_pro_bankruptcy_loan_repay_history(
        &self,
        params: QueryPortfolioMarginProBankruptcyLoanRepayHistoryParams,
    ) -> anyhow::Result<
        RestApiResponse<models::QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse>,
    > {
        let QueryPortfolioMarginProBankruptcyLoanRepayHistoryParams {
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/pmloan-history",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_portfolio_margin_pro_negative_balance_interest_history(
        &self,
        params: QueryPortfolioMarginProNegativeBalanceInterestHistoryParams,
    ) -> anyhow::Result<
        RestApiResponse<
            Vec<models::QueryPortfolioMarginProNegativeBalanceInterestHistoryResponseInner>,
        >,
    > {
        let QueryPortfolioMarginProNegativeBalanceInterestHistoryParams {
            asset,
            start_time,
            end_time,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = asset {
            query_params.insert("asset".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<
            Vec<models::QueryPortfolioMarginProNegativeBalanceInterestHistoryResponseInner>,
        >(
            &self.configuration,
            "/sapi/v1/portfolio/interest-history",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn redeem_bfusd_for_portfolio_margin(
        &self,
        params: RedeemBfusdForPortfolioMarginParams,
    ) -> anyhow::Result<RestApiResponse<models::RedeemBfusdForPortfolioMarginResponse>> {
        let RedeemBfusdForPortfolioMarginParams {
            from_asset,
            target_asset,
            amount,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("fromAsset".to_string(), json!(from_asset));

        query_params.insert("targetAsset".to_string(), json!(target_asset));

        let amount_value = Decimal::from_f32(amount).unwrap_or_default();
        query_params.insert("amount".to_string(), json!(amount_value));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::RedeemBfusdForPortfolioMarginResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/redeem",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn repay_futures_negative_balance(
        &self,
        params: RepayFuturesNegativeBalanceParams,
    ) -> anyhow::Result<RestApiResponse<models::RepayFuturesNegativeBalanceResponse>> {
        let RepayFuturesNegativeBalanceParams { from, recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = from {
            query_params.insert("from".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::RepayFuturesNegativeBalanceResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/repay-futures-negative-balance",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn transfer_ldusdt_for_portfolio_margin(
        &self,
        params: TransferLdusdtForPortfolioMarginParams,
    ) -> anyhow::Result<RestApiResponse<models::TransferLdusdtForPortfolioMarginResponse>> {
        let TransferLdusdtForPortfolioMarginParams {
            asset,
            transfer_type,
            amount,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("asset".to_string(), json!(asset));

        query_params.insert("transferType".to_string(), json!(transfer_type));

        let amount_value = Decimal::from_f32(amount).unwrap_or_default();
        query_params.insert("amount".to_string(), json!(amount_value));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::TransferLdusdtForPortfolioMarginResponse>(
            &self.configuration,
            "/sapi/v1/portfolio/earn-asset-transfer",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "derivatives_trading_portfolio_margin_pro"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockAccountApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl AccountApi for MockAccountApiClient {
        async fn bnb_transfer(
            &self,
            _params: BnbTransferParams,
        ) -> anyhow::Result<RestApiResponse<models::BnbTransferResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"tranId":100000001}"#).unwrap();
            let dummy_response: models::BnbTransferResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::BnbTransferResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn change_auto_repay_futures_status(
            &self,
            _params: ChangeAutoRepayFuturesStatusParams,
        ) -> anyhow::Result<RestApiResponse<models::ChangeAutoRepayFuturesStatusResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let dummy_response: models::ChangeAutoRepayFuturesStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::ChangeAutoRepayFuturesStatusResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn fund_auto_collection(
            &self,
            _params: FundAutoCollectionParams,
        ) -> anyhow::Result<RestApiResponse<models::FundAutoCollectionResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let dummy_response: models::FundAutoCollectionResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::FundAutoCollectionResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn fund_collection_by_asset(
            &self,
            _params: FundCollectionByAssetParams,
        ) -> anyhow::Result<RestApiResponse<models::FundCollectionByAssetResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let dummy_response: models::FundCollectionByAssetResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::FundCollectionByAssetResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_auto_repay_futures_status(
            &self,
            _params: GetAutoRepayFuturesStatusParams,
        ) -> anyhow::Result<RestApiResponse<models::GetAutoRepayFuturesStatusResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"autoRepay":true}"#).unwrap();
            let dummy_response: models::GetAutoRepayFuturesStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetAutoRepayFuturesStatusResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_portfolio_margin_pro_account_balance(
            &self,
            _params: GetPortfolioMarginProAccountBalanceParams,
        ) -> anyhow::Result<
            RestApiResponse<Vec<models::GetPortfolioMarginProAccountBalanceResponseInner>>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"asset":"BTC","totalWalletBalance":"100","crossMarginAsset":"100","crossMarginBorrowed":"0","crossMarginFree":"100","crossMarginInterest":"0","crossMarginLocked":"0","umWalletBalance":"0","umUnrealizedPNL":"0","cmWalletBalance":"0","cmUnrealizedPNL":"0","updateTime":0,"negativeBalance":"0","optionWalletBalance":"0","optionEquity":"0"}]"#).unwrap();
            let dummy_response : Vec<models::GetPortfolioMarginProAccountBalanceResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetPortfolioMarginProAccountBalanceResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_portfolio_margin_pro_account_info(
            &self,
            _params: GetPortfolioMarginProAccountInfoParams,
        ) -> anyhow::Result<RestApiResponse<models::GetPortfolioMarginProAccountInfoResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"uniMMR":"5167.92171923","accountEquity":"122607.35137903","actualEquity":"142607.35137903","accountMaintMargin":"23.72469206","accountInitialMargin":"47.44938412","totalAvailableBalance":"122,559.90199491","accountStatus":"NORMAL","accountType":"PM_1"}"#).unwrap();
            let dummy_response: models::GetPortfolioMarginProAccountInfoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetPortfolioMarginProAccountInfoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_portfolio_margin_pro_span_account_info(
            &self,
            _params: GetPortfolioMarginProSpanAccountInfoParams,
        ) -> anyhow::Result<RestApiResponse<models::GetPortfolioMarginProSpanAccountInfoResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"uniMMR":"5167.92171923","accountEquity":"122607.35137903","actualEquity":"142607.35137903","accountMaintMargin":"23.72469206","riskUnitMMList":[{"asset":"BTC","uniMaintainUsd":"23.72469206"}],"marginMM":"0.00000000","otherMM":"0.00000000","accountStatus":"NORMAL","accountType":"PM_3"}"#).unwrap();
            let dummy_response: models::GetPortfolioMarginProSpanAccountInfoResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetPortfolioMarginProSpanAccountInfoResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_transferable_earn_asset_balance_for_portfolio_margin(
            &self,
            _params: GetTransferableEarnAssetBalanceForPortfolioMarginParams,
        ) -> anyhow::Result<
            RestApiResponse<models::GetTransferableEarnAssetBalanceForPortfolioMarginResponse>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"asset":"LDUSDT","amount":"0.55"}"#).unwrap();
            let dummy_response : models::GetTransferableEarnAssetBalanceForPortfolioMarginResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetTransferableEarnAssetBalanceForPortfolioMarginResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn mint_bfusd_for_portfolio_margin(
            &self,
            _params: MintBfusdForPortfolioMarginParams,
        ) -> anyhow::Result<RestApiResponse<models::MintBfusdForPortfolioMarginResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"fromAsset":"USDT","targetAsset":"BFUSD","fromAssetQty":10,"targetAssetQty":9.998,"rate":0.9998}"#).unwrap();
            let dummy_response: models::MintBfusdForPortfolioMarginResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::MintBfusdForPortfolioMarginResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn portfolio_margin_pro_bankruptcy_loan_repay(
            &self,
            _params: PortfolioMarginProBankruptcyLoanRepayParams,
        ) -> anyhow::Result<RestApiResponse<models::PortfolioMarginProBankruptcyLoanRepayResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"tranId":58203331886213500}"#).unwrap();
            let dummy_response: models::PortfolioMarginProBankruptcyLoanRepayResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::PortfolioMarginProBankruptcyLoanRepayResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_portfolio_margin_pro_bankruptcy_loan_amount(
            &self,
            _params: QueryPortfolioMarginProBankruptcyLoanAmountParams,
        ) -> anyhow::Result<
            RestApiResponse<models::QueryPortfolioMarginProBankruptcyLoanAmountResponse>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"asset":"BUSD","amount":"579.45"}"#).unwrap();
            let dummy_response: models::QueryPortfolioMarginProBankruptcyLoanAmountResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::QueryPortfolioMarginProBankruptcyLoanAmountResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_portfolio_margin_pro_bankruptcy_loan_repay_history(
            &self,
            _params: QueryPortfolioMarginProBankruptcyLoanRepayHistoryParams,
        ) -> anyhow::Result<
            RestApiResponse<models::QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"total":3,"rows":[{"asset":"USDT","amount":"404.80294503","repayTime":1731336427804},{"asset":"USDT","amount":"4620.41204574","repayTime":1726125090016}]}"#).unwrap();
            let dummy_response : models::QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_portfolio_margin_pro_negative_balance_interest_history(
            &self,
            _params: QueryPortfolioMarginProNegativeBalanceInterestHistoryParams,
        ) -> anyhow::Result<
            RestApiResponse<
                Vec<models::QueryPortfolioMarginProNegativeBalanceInterestHistoryResponseInner>,
            >,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"asset":"USDT","interest":"24.4440","interestAccruedTime":1670227200000,"interestRate":"0.0001164","principal":"210000"}]"#).unwrap();
            let dummy_response : Vec<models::QueryPortfolioMarginProNegativeBalanceInterestHistoryResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryPortfolioMarginProNegativeBalanceInterestHistoryResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn redeem_bfusd_for_portfolio_margin(
            &self,
            _params: RedeemBfusdForPortfolioMarginParams,
        ) -> anyhow::Result<RestApiResponse<models::RedeemBfusdForPortfolioMarginResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"fromAsset":"BFUSD","targetAsset":"USDT","fromAssetQty":9.99800001,"targetAssetQty":9.996000409998,"rate":0.9998}"#).unwrap();
            let dummy_response: models::RedeemBfusdForPortfolioMarginResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::RedeemBfusdForPortfolioMarginResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn repay_futures_negative_balance(
            &self,
            _params: RepayFuturesNegativeBalanceParams,
        ) -> anyhow::Result<RestApiResponse<models::RepayFuturesNegativeBalanceResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let dummy_response: models::RepayFuturesNegativeBalanceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::RepayFuturesNegativeBalanceResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn transfer_ldusdt_for_portfolio_margin(
            &self,
            _params: TransferLdusdtForPortfolioMarginParams,
        ) -> anyhow::Result<RestApiResponse<models::TransferLdusdtForPortfolioMarginResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let dummy_response: models::TransferLdusdtForPortfolioMarginResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TransferLdusdtForPortfolioMarginResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn bnb_transfer_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = BnbTransferParams::builder(1.0, "transfer_side_example".to_string())
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"tranId":100000001}"#).unwrap();
            let expected_response: models::BnbTransferResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::BnbTransferResponse");

            let resp = client
                .bnb_transfer(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn bnb_transfer_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = BnbTransferParams::builder(1.0, "transfer_side_example".to_string())
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"tranId":100000001}"#).unwrap();
            let expected_response: models::BnbTransferResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::BnbTransferResponse");

            let resp = client
                .bnb_transfer(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn bnb_transfer_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = BnbTransferParams::builder(1.0, "transfer_side_example".to_string())
                .build()
                .unwrap();

            match client.bnb_transfer(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn change_auto_repay_futures_status_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = ChangeAutoRepayFuturesStatusParams::builder(String::new())
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let expected_response: models::ChangeAutoRepayFuturesStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::ChangeAutoRepayFuturesStatusResponse");

            let resp = client
                .change_auto_repay_futures_status(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn change_auto_repay_futures_status_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = ChangeAutoRepayFuturesStatusParams::builder(String::new())
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let expected_response: models::ChangeAutoRepayFuturesStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::ChangeAutoRepayFuturesStatusResponse");

            let resp = client
                .change_auto_repay_futures_status(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn change_auto_repay_futures_status_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = ChangeAutoRepayFuturesStatusParams::builder(String::new())
                .build()
                .unwrap();

            match client.change_auto_repay_futures_status(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn fund_auto_collection_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = FundAutoCollectionParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let expected_response: models::FundAutoCollectionResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::FundAutoCollectionResponse");

            let resp = client
                .fund_auto_collection(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn fund_auto_collection_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = FundAutoCollectionParams::builder()
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let expected_response: models::FundAutoCollectionResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::FundAutoCollectionResponse");

            let resp = client
                .fund_auto_collection(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn fund_auto_collection_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = FundAutoCollectionParams::builder().build().unwrap();

            match client.fund_auto_collection(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn fund_collection_by_asset_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = FundCollectionByAssetParams::builder("asset_example".to_string())
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let expected_response: models::FundCollectionByAssetResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::FundCollectionByAssetResponse");

            let resp = client
                .fund_collection_by_asset(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn fund_collection_by_asset_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = FundCollectionByAssetParams::builder("asset_example".to_string())
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let expected_response: models::FundCollectionByAssetResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::FundCollectionByAssetResponse");

            let resp = client
                .fund_collection_by_asset(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn fund_collection_by_asset_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = FundCollectionByAssetParams::builder("asset_example".to_string())
                .build()
                .unwrap();

            match client.fund_collection_by_asset(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_auto_repay_futures_status_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetAutoRepayFuturesStatusParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"autoRepay":true}"#).unwrap();
            let expected_response: models::GetAutoRepayFuturesStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetAutoRepayFuturesStatusResponse");

            let resp = client
                .get_auto_repay_futures_status(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_auto_repay_futures_status_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetAutoRepayFuturesStatusParams::builder()
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"autoRepay":true}"#).unwrap();
            let expected_response: models::GetAutoRepayFuturesStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetAutoRepayFuturesStatusResponse");

            let resp = client
                .get_auto_repay_futures_status(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_auto_repay_futures_status_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetAutoRepayFuturesStatusParams::builder().build().unwrap();

            match client.get_auto_repay_futures_status(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_portfolio_margin_pro_account_balance_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetPortfolioMarginProAccountBalanceParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"asset":"BTC","totalWalletBalance":"100","crossMarginAsset":"100","crossMarginBorrowed":"0","crossMarginFree":"100","crossMarginInterest":"0","crossMarginLocked":"0","umWalletBalance":"0","umUnrealizedPNL":"0","cmWalletBalance":"0","cmUnrealizedPNL":"0","updateTime":0,"negativeBalance":"0","optionWalletBalance":"0","optionEquity":"0"}]"#).unwrap();
            let expected_response : Vec<models::GetPortfolioMarginProAccountBalanceResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetPortfolioMarginProAccountBalanceResponseInner>");

            let resp = client.get_portfolio_margin_pro_account_balance(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_portfolio_margin_pro_account_balance_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetPortfolioMarginProAccountBalanceParams::builder().asset("asset_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"asset":"BTC","totalWalletBalance":"100","crossMarginAsset":"100","crossMarginBorrowed":"0","crossMarginFree":"100","crossMarginInterest":"0","crossMarginLocked":"0","umWalletBalance":"0","umUnrealizedPNL":"0","cmWalletBalance":"0","cmUnrealizedPNL":"0","updateTime":0,"negativeBalance":"0","optionWalletBalance":"0","optionEquity":"0"}]"#).unwrap();
            let expected_response : Vec<models::GetPortfolioMarginProAccountBalanceResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetPortfolioMarginProAccountBalanceResponseInner>");

            let resp = client.get_portfolio_margin_pro_account_balance(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_portfolio_margin_pro_account_balance_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetPortfolioMarginProAccountBalanceParams::builder()
                .build()
                .unwrap();

            match client
                .get_portfolio_margin_pro_account_balance(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_portfolio_margin_pro_account_info_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetPortfolioMarginProAccountInfoParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"uniMMR":"5167.92171923","accountEquity":"122607.35137903","actualEquity":"142607.35137903","accountMaintMargin":"23.72469206","accountInitialMargin":"47.44938412","totalAvailableBalance":"122,559.90199491","accountStatus":"NORMAL","accountType":"PM_1"}"#).unwrap();
            let expected_response : models::GetPortfolioMarginProAccountInfoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetPortfolioMarginProAccountInfoResponse");

            let resp = client.get_portfolio_margin_pro_account_info(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_portfolio_margin_pro_account_info_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetPortfolioMarginProAccountInfoParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"uniMMR":"5167.92171923","accountEquity":"122607.35137903","actualEquity":"142607.35137903","accountMaintMargin":"23.72469206","accountInitialMargin":"47.44938412","totalAvailableBalance":"122,559.90199491","accountStatus":"NORMAL","accountType":"PM_1"}"#).unwrap();
            let expected_response : models::GetPortfolioMarginProAccountInfoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetPortfolioMarginProAccountInfoResponse");

            let resp = client.get_portfolio_margin_pro_account_info(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_portfolio_margin_pro_account_info_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetPortfolioMarginProAccountInfoParams::builder()
                .build()
                .unwrap();

            match client.get_portfolio_margin_pro_account_info(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_portfolio_margin_pro_span_account_info_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetPortfolioMarginProSpanAccountInfoParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"uniMMR":"5167.92171923","accountEquity":"122607.35137903","actualEquity":"142607.35137903","accountMaintMargin":"23.72469206","riskUnitMMList":[{"asset":"BTC","uniMaintainUsd":"23.72469206"}],"marginMM":"0.00000000","otherMM":"0.00000000","accountStatus":"NORMAL","accountType":"PM_3"}"#).unwrap();
            let expected_response : models::GetPortfolioMarginProSpanAccountInfoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetPortfolioMarginProSpanAccountInfoResponse");

            let resp = client.get_portfolio_margin_pro_span_account_info(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_portfolio_margin_pro_span_account_info_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetPortfolioMarginProSpanAccountInfoParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"uniMMR":"5167.92171923","accountEquity":"122607.35137903","actualEquity":"142607.35137903","accountMaintMargin":"23.72469206","riskUnitMMList":[{"asset":"BTC","uniMaintainUsd":"23.72469206"}],"marginMM":"0.00000000","otherMM":"0.00000000","accountStatus":"NORMAL","accountType":"PM_3"}"#).unwrap();
            let expected_response : models::GetPortfolioMarginProSpanAccountInfoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetPortfolioMarginProSpanAccountInfoResponse");

            let resp = client.get_portfolio_margin_pro_span_account_info(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_portfolio_margin_pro_span_account_info_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetPortfolioMarginProSpanAccountInfoParams::builder()
                .build()
                .unwrap();

            match client
                .get_portfolio_margin_pro_span_account_info(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_transferable_earn_asset_balance_for_portfolio_margin_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetTransferableEarnAssetBalanceForPortfolioMarginParams::builder("asset_example".to_string(),"transfer_type_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"asset":"LDUSDT","amount":"0.55"}"#).unwrap();
            let expected_response : models::GetTransferableEarnAssetBalanceForPortfolioMarginResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetTransferableEarnAssetBalanceForPortfolioMarginResponse");

            let resp = client.get_transferable_earn_asset_balance_for_portfolio_margin(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_transferable_earn_asset_balance_for_portfolio_margin_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = GetTransferableEarnAssetBalanceForPortfolioMarginParams::builder("asset_example".to_string(),"transfer_type_example".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"asset":"LDUSDT","amount":"0.55"}"#).unwrap();
            let expected_response : models::GetTransferableEarnAssetBalanceForPortfolioMarginResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetTransferableEarnAssetBalanceForPortfolioMarginResponse");

            let resp = client.get_transferable_earn_asset_balance_for_portfolio_margin(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_transferable_earn_asset_balance_for_portfolio_margin_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = GetTransferableEarnAssetBalanceForPortfolioMarginParams::builder(
                "asset_example".to_string(),
                "transfer_type_example".to_string(),
            )
            .build()
            .unwrap();

            match client
                .get_transferable_earn_asset_balance_for_portfolio_margin(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn mint_bfusd_for_portfolio_margin_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = MintBfusdForPortfolioMarginParams::builder("from_asset_example".to_string(),"target_asset_example".to_string(),1.0,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"fromAsset":"USDT","targetAsset":"BFUSD","fromAssetQty":10,"targetAssetQty":9.998,"rate":0.9998}"#).unwrap();
            let expected_response : models::MintBfusdForPortfolioMarginResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::MintBfusdForPortfolioMarginResponse");

            let resp = client.mint_bfusd_for_portfolio_margin(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn mint_bfusd_for_portfolio_margin_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = MintBfusdForPortfolioMarginParams::builder("from_asset_example".to_string(),"target_asset_example".to_string(),1.0,).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"fromAsset":"USDT","targetAsset":"BFUSD","fromAssetQty":10,"targetAssetQty":9.998,"rate":0.9998}"#).unwrap();
            let expected_response : models::MintBfusdForPortfolioMarginResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::MintBfusdForPortfolioMarginResponse");

            let resp = client.mint_bfusd_for_portfolio_margin(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn mint_bfusd_for_portfolio_margin_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = MintBfusdForPortfolioMarginParams::builder(
                "from_asset_example".to_string(),
                "target_asset_example".to_string(),
                1.0,
            )
            .build()
            .unwrap();

            match client.mint_bfusd_for_portfolio_margin(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn portfolio_margin_pro_bankruptcy_loan_repay_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = PortfolioMarginProBankruptcyLoanRepayParams::builder()
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"tranId":58203331886213500}"#).unwrap();
            let expected_response: models::PortfolioMarginProBankruptcyLoanRepayResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::PortfolioMarginProBankruptcyLoanRepayResponse",
                );

            let resp = client
                .portfolio_margin_pro_bankruptcy_loan_repay(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn portfolio_margin_pro_bankruptcy_loan_repay_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = PortfolioMarginProBankruptcyLoanRepayParams::builder()
                .from("SPOT".to_string())
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"tranId":58203331886213500}"#).unwrap();
            let expected_response: models::PortfolioMarginProBankruptcyLoanRepayResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::PortfolioMarginProBankruptcyLoanRepayResponse",
                );

            let resp = client
                .portfolio_margin_pro_bankruptcy_loan_repay(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn portfolio_margin_pro_bankruptcy_loan_repay_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = PortfolioMarginProBankruptcyLoanRepayParams::builder()
                .build()
                .unwrap();

            match client
                .portfolio_margin_pro_bankruptcy_loan_repay(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_portfolio_margin_pro_bankruptcy_loan_amount_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryPortfolioMarginProBankruptcyLoanAmountParams::builder()
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"asset":"BUSD","amount":"579.45"}"#).unwrap();
            let expected_response: models::QueryPortfolioMarginProBankruptcyLoanAmountResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::QueryPortfolioMarginProBankruptcyLoanAmountResponse",
                );

            let resp = client
                .query_portfolio_margin_pro_bankruptcy_loan_amount(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_portfolio_margin_pro_bankruptcy_loan_amount_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryPortfolioMarginProBankruptcyLoanAmountParams::builder()
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"asset":"BUSD","amount":"579.45"}"#).unwrap();
            let expected_response: models::QueryPortfolioMarginProBankruptcyLoanAmountResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::QueryPortfolioMarginProBankruptcyLoanAmountResponse",
                );

            let resp = client
                .query_portfolio_margin_pro_bankruptcy_loan_amount(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_portfolio_margin_pro_bankruptcy_loan_amount_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = QueryPortfolioMarginProBankruptcyLoanAmountParams::builder()
                .build()
                .unwrap();

            match client
                .query_portfolio_margin_pro_bankruptcy_loan_amount(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_portfolio_margin_pro_bankruptcy_loan_repay_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryPortfolioMarginProBankruptcyLoanRepayHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"total":3,"rows":[{"asset":"USDT","amount":"404.80294503","repayTime":1731336427804},{"asset":"USDT","amount":"4620.41204574","repayTime":1726125090016}]}"#).unwrap();
            let expected_response : models::QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse");

            let resp = client.query_portfolio_margin_pro_bankruptcy_loan_repay_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_portfolio_margin_pro_bankruptcy_loan_repay_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryPortfolioMarginProBankruptcyLoanRepayHistoryParams::builder().start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"total":3,"rows":[{"asset":"USDT","amount":"404.80294503","repayTime":1731336427804},{"asset":"USDT","amount":"4620.41204574","repayTime":1726125090016}]}"#).unwrap();
            let expected_response : models::QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse");

            let resp = client.query_portfolio_margin_pro_bankruptcy_loan_repay_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_portfolio_margin_pro_bankruptcy_loan_repay_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = QueryPortfolioMarginProBankruptcyLoanRepayHistoryParams::builder()
                .build()
                .unwrap();

            match client
                .query_portfolio_margin_pro_bankruptcy_loan_repay_history(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_portfolio_margin_pro_negative_balance_interest_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryPortfolioMarginProNegativeBalanceInterestHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"asset":"USDT","interest":"24.4440","interestAccruedTime":1670227200000,"interestRate":"0.0001164","principal":"210000"}]"#).unwrap();
            let expected_response : Vec<models::QueryPortfolioMarginProNegativeBalanceInterestHistoryResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryPortfolioMarginProNegativeBalanceInterestHistoryResponseInner>");

            let resp = client.query_portfolio_margin_pro_negative_balance_interest_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_portfolio_margin_pro_negative_balance_interest_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = QueryPortfolioMarginProNegativeBalanceInterestHistoryParams::builder().asset("asset_example".to_string()).start_time(1623319461670).end_time(1641782889000).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"asset":"USDT","interest":"24.4440","interestAccruedTime":1670227200000,"interestRate":"0.0001164","principal":"210000"}]"#).unwrap();
            let expected_response : Vec<models::QueryPortfolioMarginProNegativeBalanceInterestHistoryResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryPortfolioMarginProNegativeBalanceInterestHistoryResponseInner>");

            let resp = client.query_portfolio_margin_pro_negative_balance_interest_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_portfolio_margin_pro_negative_balance_interest_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = QueryPortfolioMarginProNegativeBalanceInterestHistoryParams::builder()
                .build()
                .unwrap();

            match client
                .query_portfolio_margin_pro_negative_balance_interest_history(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn redeem_bfusd_for_portfolio_margin_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = RedeemBfusdForPortfolioMarginParams::builder("from_asset_example".to_string(),"target_asset_example".to_string(),1.0,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"fromAsset":"BFUSD","targetAsset":"USDT","fromAssetQty":9.99800001,"targetAssetQty":9.996000409998,"rate":0.9998}"#).unwrap();
            let expected_response : models::RedeemBfusdForPortfolioMarginResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::RedeemBfusdForPortfolioMarginResponse");

            let resp = client.redeem_bfusd_for_portfolio_margin(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn redeem_bfusd_for_portfolio_margin_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = RedeemBfusdForPortfolioMarginParams::builder("from_asset_example".to_string(),"target_asset_example".to_string(),1.0,).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"fromAsset":"BFUSD","targetAsset":"USDT","fromAssetQty":9.99800001,"targetAssetQty":9.996000409998,"rate":0.9998}"#).unwrap();
            let expected_response : models::RedeemBfusdForPortfolioMarginResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::RedeemBfusdForPortfolioMarginResponse");

            let resp = client.redeem_bfusd_for_portfolio_margin(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn redeem_bfusd_for_portfolio_margin_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = RedeemBfusdForPortfolioMarginParams::builder(
                "from_asset_example".to_string(),
                "target_asset_example".to_string(),
                1.0,
            )
            .build()
            .unwrap();

            match client.redeem_bfusd_for_portfolio_margin(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn repay_futures_negative_balance_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = RepayFuturesNegativeBalanceParams::builder()
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let expected_response: models::RepayFuturesNegativeBalanceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::RepayFuturesNegativeBalanceResponse");

            let resp = client
                .repay_futures_negative_balance(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn repay_futures_negative_balance_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = RepayFuturesNegativeBalanceParams::builder()
                .from("SPOT".to_string())
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let expected_response: models::RepayFuturesNegativeBalanceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::RepayFuturesNegativeBalanceResponse");

            let resp = client
                .repay_futures_negative_balance(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn repay_futures_negative_balance_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = RepayFuturesNegativeBalanceParams::builder()
                .build()
                .unwrap();

            match client.repay_futures_negative_balance(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn transfer_ldusdt_for_portfolio_margin_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = TransferLdusdtForPortfolioMarginParams::builder(
                "asset_example".to_string(),
                "transfer_type_example".to_string(),
                1.0,
            )
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let expected_response: models::TransferLdusdtForPortfolioMarginResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TransferLdusdtForPortfolioMarginResponse");

            let resp = client
                .transfer_ldusdt_for_portfolio_margin(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn transfer_ldusdt_for_portfolio_margin_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: false };

            let params = TransferLdusdtForPortfolioMarginParams::builder(
                "asset_example".to_string(),
                "transfer_type_example".to_string(),
                1.0,
            )
            .recv_window(5000)
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"msg":"success"}"#).unwrap();
            let expected_response: models::TransferLdusdtForPortfolioMarginResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TransferLdusdtForPortfolioMarginResponse");

            let resp = client
                .transfer_ldusdt_for_portfolio_margin(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn transfer_ldusdt_for_portfolio_margin_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountApiClient { force_error: true };

            let params = TransferLdusdtForPortfolioMarginParams::builder(
                "asset_example".to_string(),
                "transfer_type_example".to_string(),
                1.0,
            )
            .build()
            .unwrap();

            match client.transfer_ldusdt_for_portfolio_margin(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
