/*
 * Binance Staking REST API
 *
 * OpenAPI Specification for the Binance Staking REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::staking::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait SolStakingApi: Send + Sync {
    async fn claim_boost_rewards(
        &self,
        params: ClaimBoostRewardsParams,
    ) -> anyhow::Result<RestApiResponse<models::ClaimBoostRewardsResponse>>;
    async fn get_bnsol_rate_history(
        &self,
        params: GetBnsolRateHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetBnsolRateHistoryResponse>>;
    async fn get_bnsol_rewards_history(
        &self,
        params: GetBnsolRewardsHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetBnsolRewardsHistoryResponse>>;
    async fn get_boost_rewards_history(
        &self,
        params: GetBoostRewardsHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetBoostRewardsHistoryResponse>>;
    async fn get_sol_redemption_history(
        &self,
        params: GetSolRedemptionHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetSolRedemptionHistoryResponse>>;
    async fn get_sol_staking_history(
        &self,
        params: GetSolStakingHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetSolStakingHistoryResponse>>;
    async fn get_sol_staking_quota_details(
        &self,
        params: GetSolStakingQuotaDetailsParams,
    ) -> anyhow::Result<RestApiResponse<models::GetSolStakingQuotaDetailsResponse>>;
    async fn get_unclaimed_rewards(
        &self,
        params: GetUnclaimedRewardsParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::GetUnclaimedRewardsResponseInner>>>;
    async fn redeem_sol(
        &self,
        params: RedeemSolParams,
    ) -> anyhow::Result<RestApiResponse<models::RedeemSolResponse>>;
    async fn sol_staking_account(
        &self,
        params: SolStakingAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::SolStakingAccountResponse>>;
    async fn subscribe_sol_staking(
        &self,
        params: SubscribeSolStakingParams,
    ) -> anyhow::Result<RestApiResponse<models::SubscribeSolStakingResponse>>;
}

#[derive(Debug, Clone)]
pub struct SolStakingApiClient {
    configuration: ConfigurationRestApi,
}

impl SolStakingApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`claim_boost_rewards`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`claim_boost_rewards`](#method.claim_boost_rewards).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct ClaimBoostRewardsParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl ClaimBoostRewardsParams {
    /// Create a builder for [`claim_boost_rewards`].
    ///
    #[must_use]
    pub fn builder() -> ClaimBoostRewardsParamsBuilder {
        ClaimBoostRewardsParamsBuilder::default()
    }
}
/// Request parameters for the [`get_bnsol_rate_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_bnsol_rate_history`](#method.get_bnsol_rate_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetBnsolRateHistoryParams {
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10, Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetBnsolRateHistoryParams {
    /// Create a builder for [`get_bnsol_rate_history`].
    ///
    #[must_use]
    pub fn builder() -> GetBnsolRateHistoryParamsBuilder {
        GetBnsolRateHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`get_bnsol_rewards_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_bnsol_rewards_history`](#method.get_bnsol_rewards_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetBnsolRewardsHistoryParams {
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10, Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetBnsolRewardsHistoryParams {
    /// Create a builder for [`get_bnsol_rewards_history`].
    ///
    #[must_use]
    pub fn builder() -> GetBnsolRewardsHistoryParamsBuilder {
        GetBnsolRewardsHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`get_boost_rewards_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_boost_rewards_history`](#method.get_boost_rewards_history).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetBoostRewardsHistoryParams {
    /// "CLAIM", "DISTRIBUTE", default "CLAIM"
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub r#type: String,
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10, Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetBoostRewardsHistoryParams {
    /// Create a builder for [`get_boost_rewards_history`].
    ///
    /// Required parameters:
    ///
    /// * `r#type` — \"CLAIM\", \"DISTRIBUTE\", default \"CLAIM\"
    ///
    #[must_use]
    pub fn builder(r#type: String) -> GetBoostRewardsHistoryParamsBuilder {
        GetBoostRewardsHistoryParamsBuilder::default().r#type(r#type)
    }
}
/// Request parameters for the [`get_sol_redemption_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_sol_redemption_history`](#method.get_sol_redemption_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetSolRedemptionHistoryParams {
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10, Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetSolRedemptionHistoryParams {
    /// Create a builder for [`get_sol_redemption_history`].
    ///
    #[must_use]
    pub fn builder() -> GetSolRedemptionHistoryParamsBuilder {
        GetSolRedemptionHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`get_sol_staking_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_sol_staking_history`](#method.get_sol_staking_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetSolStakingHistoryParams {
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10, Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetSolStakingHistoryParams {
    /// Create a builder for [`get_sol_staking_history`].
    ///
    #[must_use]
    pub fn builder() -> GetSolStakingHistoryParamsBuilder {
        GetSolStakingHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`get_sol_staking_quota_details`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_sol_staking_quota_details`](#method.get_sol_staking_quota_details).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetSolStakingQuotaDetailsParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetSolStakingQuotaDetailsParams {
    /// Create a builder for [`get_sol_staking_quota_details`].
    ///
    #[must_use]
    pub fn builder() -> GetSolStakingQuotaDetailsParamsBuilder {
        GetSolStakingQuotaDetailsParamsBuilder::default()
    }
}
/// Request parameters for the [`get_unclaimed_rewards`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_unclaimed_rewards`](#method.get_unclaimed_rewards).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetUnclaimedRewardsParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetUnclaimedRewardsParams {
    /// Create a builder for [`get_unclaimed_rewards`].
    ///
    #[must_use]
    pub fn builder() -> GetUnclaimedRewardsParamsBuilder {
        GetUnclaimedRewardsParamsBuilder::default()
    }
}
/// Request parameters for the [`redeem_sol`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`redeem_sol`](#method.redeem_sol).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct RedeemSolParams {
    /// Amount in SOL.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: f32,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl RedeemSolParams {
    /// Create a builder for [`redeem_sol`].
    ///
    /// Required parameters:
    ///
    /// * `amount` — Amount in SOL.
    ///
    #[must_use]
    pub fn builder(amount: f32) -> RedeemSolParamsBuilder {
        RedeemSolParamsBuilder::default().amount(amount)
    }
}
/// Request parameters for the [`sol_staking_account`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`sol_staking_account`](#method.sol_staking_account).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct SolStakingAccountParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl SolStakingAccountParams {
    /// Create a builder for [`sol_staking_account`].
    ///
    #[must_use]
    pub fn builder() -> SolStakingAccountParamsBuilder {
        SolStakingAccountParamsBuilder::default()
    }
}
/// Request parameters for the [`subscribe_sol_staking`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`subscribe_sol_staking`](#method.subscribe_sol_staking).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct SubscribeSolStakingParams {
    /// Amount in SOL.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: f32,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl SubscribeSolStakingParams {
    /// Create a builder for [`subscribe_sol_staking`].
    ///
    /// Required parameters:
    ///
    /// * `amount` — Amount in SOL.
    ///
    #[must_use]
    pub fn builder(amount: f32) -> SubscribeSolStakingParamsBuilder {
        SubscribeSolStakingParamsBuilder::default().amount(amount)
    }
}

#[async_trait]
impl SolStakingApi for SolStakingApiClient {
    async fn claim_boost_rewards(
        &self,
        params: ClaimBoostRewardsParams,
    ) -> anyhow::Result<RestApiResponse<models::ClaimBoostRewardsResponse>> {
        let ClaimBoostRewardsParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::ClaimBoostRewardsResponse>(
            &self.configuration,
            "/sapi/v1/sol-staking/sol/claim",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_bnsol_rate_history(
        &self,
        params: GetBnsolRateHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetBnsolRateHistoryResponse>> {
        let GetBnsolRateHistoryParams {
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetBnsolRateHistoryResponse>(
            &self.configuration,
            "/sapi/v1/sol-staking/sol/history/rateHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_bnsol_rewards_history(
        &self,
        params: GetBnsolRewardsHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetBnsolRewardsHistoryResponse>> {
        let GetBnsolRewardsHistoryParams {
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetBnsolRewardsHistoryResponse>(
            &self.configuration,
            "/sapi/v1/sol-staking/sol/history/bnsolRewardsHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_boost_rewards_history(
        &self,
        params: GetBoostRewardsHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetBoostRewardsHistoryResponse>> {
        let GetBoostRewardsHistoryParams {
            r#type,
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("type".to_string(), json!(r#type));

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetBoostRewardsHistoryResponse>(
            &self.configuration,
            "/sapi/v1/sol-staking/sol/history/boostRewardsHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_sol_redemption_history(
        &self,
        params: GetSolRedemptionHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetSolRedemptionHistoryResponse>> {
        let GetSolRedemptionHistoryParams {
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetSolRedemptionHistoryResponse>(
            &self.configuration,
            "/sapi/v1/sol-staking/sol/history/redemptionHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_sol_staking_history(
        &self,
        params: GetSolStakingHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetSolStakingHistoryResponse>> {
        let GetSolStakingHistoryParams {
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetSolStakingHistoryResponse>(
            &self.configuration,
            "/sapi/v1/sol-staking/sol/history/stakingHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_sol_staking_quota_details(
        &self,
        params: GetSolStakingQuotaDetailsParams,
    ) -> anyhow::Result<RestApiResponse<models::GetSolStakingQuotaDetailsResponse>> {
        let GetSolStakingQuotaDetailsParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetSolStakingQuotaDetailsResponse>(
            &self.configuration,
            "/sapi/v1/sol-staking/sol/quota",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_unclaimed_rewards(
        &self,
        params: GetUnclaimedRewardsParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::GetUnclaimedRewardsResponseInner>>> {
        let GetUnclaimedRewardsParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::GetUnclaimedRewardsResponseInner>>(
            &self.configuration,
            "/sapi/v1/sol-staking/sol/history/unclaimedRewards",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn redeem_sol(
        &self,
        params: RedeemSolParams,
    ) -> anyhow::Result<RestApiResponse<models::RedeemSolResponse>> {
        let RedeemSolParams {
            amount,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        let amount_value = Decimal::from_f32(amount).unwrap_or_default();
        query_params.insert("amount".to_string(), json!(amount_value));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::RedeemSolResponse>(
            &self.configuration,
            "/sapi/v1/sol-staking/sol/redeem",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn sol_staking_account(
        &self,
        params: SolStakingAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::SolStakingAccountResponse>> {
        let SolStakingAccountParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::SolStakingAccountResponse>(
            &self.configuration,
            "/sapi/v1/sol-staking/account",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn subscribe_sol_staking(
        &self,
        params: SubscribeSolStakingParams,
    ) -> anyhow::Result<RestApiResponse<models::SubscribeSolStakingResponse>> {
        let SubscribeSolStakingParams {
            amount,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        let amount_value = Decimal::from_f32(amount).unwrap_or_default();
        query_params.insert("amount".to_string(), json!(amount_value));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::SubscribeSolStakingResponse>(
            &self.configuration,
            "/sapi/v1/sol-staking/sol/stake",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "staking"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockSolStakingApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl SolStakingApi for MockSolStakingApiClient {
        async fn claim_boost_rewards(
            &self,
            _params: ClaimBoostRewardsParams,
        ) -> anyhow::Result<RestApiResponse<models::ClaimBoostRewardsResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"success":true}"#).unwrap();
            let dummy_response: models::ClaimBoostRewardsResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::ClaimBoostRewardsResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_bnsol_rate_history(
            &self,
            _params: GetBnsolRateHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetBnsolRateHistoryResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"annualPercentageRate":"0.00006408","exchangeRate":"1.001212343432","boostRewards":[{"boostAPR":"0.12000000","rewardsAsset":"SOL"},{"boostAPR":"0.00200000","rewardsAsset":"BNB"}],"time":1577233578000}],"total":"1"}"#).unwrap();
            let dummy_response: models::GetBnsolRateHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetBnsolRateHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_bnsol_rewards_history(
            &self,
            _params: GetBnsolRewardsHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetBnsolRewardsHistoryResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"estRewardsInSOL":"1.23230920","rows":[{"time":1575018510000,"amountInSOL":"0.23223","holding":"2.3223","holdingInSOL":"2.4231","annualPercentageRate":"0.5"}],"total":1}"#).unwrap();
            let dummy_response: models::GetBnsolRewardsHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetBnsolRewardsHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_boost_rewards_history(
            &self,
            _params: GetBoostRewardsHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetBoostRewardsHistoryResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1729520680,"token":"SOL","amount":"1.20291028","bnsolHolding":"2.0928798","status":"SUCCESS"}],"total":1}"#).unwrap();
            let dummy_response: models::GetBoostRewardsHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetBoostRewardsHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_sol_redemption_history(
            &self,
            _params: GetSolRedemptionHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetSolRedemptionHistoryResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"arrivalTime":1575018510000,"asset":"BNSOL","amount":"21312.23223","distributeAsset":"SOL","distributeAmount":"21338.0699","exchangeRate":"1.00121234","status":"SUCCESS"}],"total":1}"#).unwrap();
            let dummy_response: models::GetSolRedemptionHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetSolRedemptionHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_sol_staking_history(
            &self,
            _params: GetSolStakingHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetSolStakingHistoryResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"asset":"SOL","amount":"21312.23223","distributeAsset":"BNSOL","distributeAmount":"21286.42584","exchangeRate":"1.00121234","status":"SUCCESS"}],"total":1}"#).unwrap();
            let dummy_response: models::GetSolStakingHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetSolStakingHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_sol_staking_quota_details(
            &self,
            _params: GetSolStakingQuotaDetailsParams,
        ) -> anyhow::Result<RestApiResponse<models::GetSolStakingQuotaDetailsResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"leftStakingPersonalQuota":"1000","leftRedemptionPersonalQuota":"1000","minStakeAmount":"0.01000000","minRedeemAmount":"0.00000001","redeemPeriod":4,"stakeable":true,"redeemable":true,"soldOut":false,"commissionFee":"0.25000000","nextEpochTime":725993969475,"calculating":false}"#).unwrap();
            let dummy_response: models::GetSolStakingQuotaDetailsResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetSolStakingQuotaDetailsResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_unclaimed_rewards(
            &self,
            _params: GetUnclaimedRewardsParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::GetUnclaimedRewardsResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"amount":"1.00000011","rewardsAsset":"SOL"},{"amount":"2.00202321","rewardsAsset":"BNB"}]"#).unwrap();
            let dummy_response: Vec<models::GetUnclaimedRewardsResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::GetUnclaimedRewardsResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn redeem_sol(
            &self,
            _params: RedeemSolParams,
        ) -> anyhow::Result<RestApiResponse<models::RedeemSolResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"success":true,"solAmount":"0.23092091","exchangeRate":"1.00121234","arrivalTime":1575018510000}"#).unwrap();
            let dummy_response: models::RedeemSolResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::RedeemSolResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn sol_staking_account(
            &self,
            _params: SolStakingAccountParams,
        ) -> anyhow::Result<RestApiResponse<models::SolStakingAccountResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"bnsolAmount":"1.10928781","holdingInSOL":"1.22330928","thirtyDaysProfitInSOL":"0.22330928"}"#).unwrap();
            let dummy_response: models::SolStakingAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::SolStakingAccountResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn subscribe_sol_staking(
            &self,
            _params: SubscribeSolStakingParams,
        ) -> anyhow::Result<RestApiResponse<models::SubscribeSolStakingResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"success":true,"bnsolAmount":"0.23092091","exchangeRate":"1.001212342342"}"#,
            )
            .unwrap();
            let dummy_response: models::SubscribeSolStakingResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::SubscribeSolStakingResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn claim_boost_rewards_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = ClaimBoostRewardsParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"success":true}"#).unwrap();
            let expected_response: models::ClaimBoostRewardsResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::ClaimBoostRewardsResponse");

            let resp = client
                .claim_boost_rewards(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn claim_boost_rewards_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = ClaimBoostRewardsParams::builder()
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"success":true}"#).unwrap();
            let expected_response: models::ClaimBoostRewardsResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::ClaimBoostRewardsResponse");

            let resp = client
                .claim_boost_rewards(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn claim_boost_rewards_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: true };

            let params = ClaimBoostRewardsParams::builder().build().unwrap();

            match client.claim_boost_rewards(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_bnsol_rate_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetBnsolRateHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"annualPercentageRate":"0.00006408","exchangeRate":"1.001212343432","boostRewards":[{"boostAPR":"0.12000000","rewardsAsset":"SOL"},{"boostAPR":"0.00200000","rewardsAsset":"BNB"}],"time":1577233578000}],"total":"1"}"#).unwrap();
            let expected_response : models::GetBnsolRateHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetBnsolRateHistoryResponse");

            let resp = client.get_bnsol_rate_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_bnsol_rate_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetBnsolRateHistoryParams::builder().start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"annualPercentageRate":"0.00006408","exchangeRate":"1.001212343432","boostRewards":[{"boostAPR":"0.12000000","rewardsAsset":"SOL"},{"boostAPR":"0.00200000","rewardsAsset":"BNB"}],"time":1577233578000}],"total":"1"}"#).unwrap();
            let expected_response : models::GetBnsolRateHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetBnsolRateHistoryResponse");

            let resp = client.get_bnsol_rate_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_bnsol_rate_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: true };

            let params = GetBnsolRateHistoryParams::builder().build().unwrap();

            match client.get_bnsol_rate_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_bnsol_rewards_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetBnsolRewardsHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"estRewardsInSOL":"1.23230920","rows":[{"time":1575018510000,"amountInSOL":"0.23223","holding":"2.3223","holdingInSOL":"2.4231","annualPercentageRate":"0.5"}],"total":1}"#).unwrap();
            let expected_response : models::GetBnsolRewardsHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetBnsolRewardsHistoryResponse");

            let resp = client.get_bnsol_rewards_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_bnsol_rewards_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetBnsolRewardsHistoryParams::builder().start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"estRewardsInSOL":"1.23230920","rows":[{"time":1575018510000,"amountInSOL":"0.23223","holding":"2.3223","holdingInSOL":"2.4231","annualPercentageRate":"0.5"}],"total":1}"#).unwrap();
            let expected_response : models::GetBnsolRewardsHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetBnsolRewardsHistoryResponse");

            let resp = client.get_bnsol_rewards_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_bnsol_rewards_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: true };

            let params = GetBnsolRewardsHistoryParams::builder().build().unwrap();

            match client.get_bnsol_rewards_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_boost_rewards_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetBoostRewardsHistoryParams::builder("CLAIM".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1729520680,"token":"SOL","amount":"1.20291028","bnsolHolding":"2.0928798","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetBoostRewardsHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetBoostRewardsHistoryResponse");

            let resp = client.get_boost_rewards_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_boost_rewards_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetBoostRewardsHistoryParams::builder("CLAIM".to_string(),).start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1729520680,"token":"SOL","amount":"1.20291028","bnsolHolding":"2.0928798","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetBoostRewardsHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetBoostRewardsHistoryResponse");

            let resp = client.get_boost_rewards_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_boost_rewards_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: true };

            let params = GetBoostRewardsHistoryParams::builder("CLAIM".to_string())
                .build()
                .unwrap();

            match client.get_boost_rewards_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_sol_redemption_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetSolRedemptionHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"arrivalTime":1575018510000,"asset":"BNSOL","amount":"21312.23223","distributeAsset":"SOL","distributeAmount":"21338.0699","exchangeRate":"1.00121234","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetSolRedemptionHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetSolRedemptionHistoryResponse");

            let resp = client.get_sol_redemption_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_sol_redemption_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetSolRedemptionHistoryParams::builder().start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"arrivalTime":1575018510000,"asset":"BNSOL","amount":"21312.23223","distributeAsset":"SOL","distributeAmount":"21338.0699","exchangeRate":"1.00121234","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetSolRedemptionHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetSolRedemptionHistoryResponse");

            let resp = client.get_sol_redemption_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_sol_redemption_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: true };

            let params = GetSolRedemptionHistoryParams::builder().build().unwrap();

            match client.get_sol_redemption_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_sol_staking_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetSolStakingHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"asset":"SOL","amount":"21312.23223","distributeAsset":"BNSOL","distributeAmount":"21286.42584","exchangeRate":"1.00121234","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetSolStakingHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetSolStakingHistoryResponse");

            let resp = client.get_sol_staking_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_sol_staking_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetSolStakingHistoryParams::builder().start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"asset":"SOL","amount":"21312.23223","distributeAsset":"BNSOL","distributeAmount":"21286.42584","exchangeRate":"1.00121234","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetSolStakingHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetSolStakingHistoryResponse");

            let resp = client.get_sol_staking_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_sol_staking_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: true };

            let params = GetSolStakingHistoryParams::builder().build().unwrap();

            match client.get_sol_staking_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_sol_staking_quota_details_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetSolStakingQuotaDetailsParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"leftStakingPersonalQuota":"1000","leftRedemptionPersonalQuota":"1000","minStakeAmount":"0.01000000","minRedeemAmount":"0.00000001","redeemPeriod":4,"stakeable":true,"redeemable":true,"soldOut":false,"commissionFee":"0.25000000","nextEpochTime":725993969475,"calculating":false}"#).unwrap();
            let expected_response : models::GetSolStakingQuotaDetailsResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetSolStakingQuotaDetailsResponse");

            let resp = client.get_sol_staking_quota_details(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_sol_staking_quota_details_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetSolStakingQuotaDetailsParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"leftStakingPersonalQuota":"1000","leftRedemptionPersonalQuota":"1000","minStakeAmount":"0.01000000","minRedeemAmount":"0.00000001","redeemPeriod":4,"stakeable":true,"redeemable":true,"soldOut":false,"commissionFee":"0.25000000","nextEpochTime":725993969475,"calculating":false}"#).unwrap();
            let expected_response : models::GetSolStakingQuotaDetailsResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetSolStakingQuotaDetailsResponse");

            let resp = client.get_sol_staking_quota_details(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_sol_staking_quota_details_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: true };

            let params = GetSolStakingQuotaDetailsParams::builder().build().unwrap();

            match client.get_sol_staking_quota_details(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_unclaimed_rewards_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetUnclaimedRewardsParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"amount":"1.00000011","rewardsAsset":"SOL"},{"amount":"2.00202321","rewardsAsset":"BNB"}]"#).unwrap();
            let expected_response : Vec<models::GetUnclaimedRewardsResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetUnclaimedRewardsResponseInner>");

            let resp = client.get_unclaimed_rewards(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_unclaimed_rewards_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = GetUnclaimedRewardsParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"amount":"1.00000011","rewardsAsset":"SOL"},{"amount":"2.00202321","rewardsAsset":"BNB"}]"#).unwrap();
            let expected_response : Vec<models::GetUnclaimedRewardsResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetUnclaimedRewardsResponseInner>");

            let resp = client.get_unclaimed_rewards(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_unclaimed_rewards_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: true };

            let params = GetUnclaimedRewardsParams::builder().build().unwrap();

            match client.get_unclaimed_rewards(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn redeem_sol_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = RedeemSolParams::builder(1.0,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"success":true,"solAmount":"0.23092091","exchangeRate":"1.00121234","arrivalTime":1575018510000}"#).unwrap();
            let expected_response : models::RedeemSolResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::RedeemSolResponse");

            let resp = client.redeem_sol(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn redeem_sol_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = RedeemSolParams::builder(1.0,).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"success":true,"solAmount":"0.23092091","exchangeRate":"1.00121234","arrivalTime":1575018510000}"#).unwrap();
            let expected_response : models::RedeemSolResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::RedeemSolResponse");

            let resp = client.redeem_sol(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn redeem_sol_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: true };

            let params = RedeemSolParams::builder(1.0).build().unwrap();

            match client.redeem_sol(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn sol_staking_account_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = SolStakingAccountParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"bnsolAmount":"1.10928781","holdingInSOL":"1.22330928","thirtyDaysProfitInSOL":"0.22330928"}"#).unwrap();
            let expected_response : models::SolStakingAccountResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::SolStakingAccountResponse");

            let resp = client.sol_staking_account(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn sol_staking_account_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = SolStakingAccountParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"bnsolAmount":"1.10928781","holdingInSOL":"1.22330928","thirtyDaysProfitInSOL":"0.22330928"}"#).unwrap();
            let expected_response : models::SolStakingAccountResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::SolStakingAccountResponse");

            let resp = client.sol_staking_account(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn sol_staking_account_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: true };

            let params = SolStakingAccountParams::builder().build().unwrap();

            match client.sol_staking_account(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn subscribe_sol_staking_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = SubscribeSolStakingParams::builder(1.0).build().unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"success":true,"bnsolAmount":"0.23092091","exchangeRate":"1.001212342342"}"#,
            )
            .unwrap();
            let expected_response: models::SubscribeSolStakingResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::SubscribeSolStakingResponse");

            let resp = client
                .subscribe_sol_staking(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn subscribe_sol_staking_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: false };

            let params = SubscribeSolStakingParams::builder(1.0)
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"success":true,"bnsolAmount":"0.23092091","exchangeRate":"1.001212342342"}"#,
            )
            .unwrap();
            let expected_response: models::SubscribeSolStakingResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::SubscribeSolStakingResponse");

            let resp = client
                .subscribe_sol_staking(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn subscribe_sol_staking_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockSolStakingApiClient { force_error: true };

            let params = SubscribeSolStakingParams::builder(1.0).build().unwrap();

            match client.subscribe_sol_staking(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
