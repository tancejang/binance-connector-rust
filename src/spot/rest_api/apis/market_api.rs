/*
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::spot::rest_api::models;

const HAS_TIME_UNIT: bool = true;

#[async_trait]
pub trait MarketApi: Send + Sync {
    async fn agg_trades(
        &self,
        params: AggTradesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::AggTradesResponseInner>>>;
    async fn avg_price(
        &self,
        params: AvgPriceParams,
    ) -> anyhow::Result<RestApiResponse<models::AvgPriceResponse>>;
    async fn depth(
        &self,
        params: DepthParams,
    ) -> anyhow::Result<RestApiResponse<models::DepthResponse>>;
    async fn get_trades(
        &self,
        params: GetTradesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::HistoricalTradesResponseInner>>>;
    async fn historical_trades(
        &self,
        params: HistoricalTradesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::HistoricalTradesResponseInner>>>;
    async fn klines(
        &self,
        params: KlinesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<Vec<models::KlinesItemInner>>>>;
    async fn ticker(
        &self,
        params: TickerParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerResponse>>;
    async fn ticker24hr(
        &self,
        params: Ticker24hrParams,
    ) -> anyhow::Result<RestApiResponse<models::Ticker24hrResponse>>;
    async fn ticker_book_ticker(
        &self,
        params: TickerBookTickerParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerBookTickerResponse>>;
    async fn ticker_price(
        &self,
        params: TickerPriceParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerPriceResponse>>;
    async fn ticker_trading_day(
        &self,
        params: TickerTradingDayParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerTradingDayResponse>>;
    async fn ui_klines(
        &self,
        params: UiKlinesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<Vec<models::KlinesItemInner>>>>;
}

#[derive(Debug, Clone)]
pub struct MarketApiClient {
    configuration: ConfigurationRestApi,
}

impl MarketApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum KlinesIntervalEnum {
    #[serde(rename = "1s")]
    Interval1s,
    #[serde(rename = "1m")]
    Interval1m,
    #[serde(rename = "3m")]
    Interval3m,
    #[serde(rename = "5m")]
    Interval5m,
    #[serde(rename = "15m")]
    Interval15m,
    #[serde(rename = "30m")]
    Interval30m,
    #[serde(rename = "1h")]
    Interval1h,
    #[serde(rename = "2h")]
    Interval2h,
    #[serde(rename = "4h")]
    Interval4h,
    #[serde(rename = "6h")]
    Interval6h,
    #[serde(rename = "8h")]
    Interval8h,
    #[serde(rename = "12h")]
    Interval12h,
    #[serde(rename = "1d")]
    Interval1d,
    #[serde(rename = "3d")]
    Interval3d,
    #[serde(rename = "1w")]
    Interval1w,
    #[serde(rename = "1M")]
    Interval1M,
}

impl KlinesIntervalEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            KlinesIntervalEnum::Interval1s => "1s",
            KlinesIntervalEnum::Interval1m => "1m",
            KlinesIntervalEnum::Interval3m => "3m",
            KlinesIntervalEnum::Interval5m => "5m",
            KlinesIntervalEnum::Interval15m => "15m",
            KlinesIntervalEnum::Interval30m => "30m",
            KlinesIntervalEnum::Interval1h => "1h",
            KlinesIntervalEnum::Interval2h => "2h",
            KlinesIntervalEnum::Interval4h => "4h",
            KlinesIntervalEnum::Interval6h => "6h",
            KlinesIntervalEnum::Interval8h => "8h",
            KlinesIntervalEnum::Interval12h => "12h",
            KlinesIntervalEnum::Interval1d => "1d",
            KlinesIntervalEnum::Interval3d => "3d",
            KlinesIntervalEnum::Interval1w => "1w",
            KlinesIntervalEnum::Interval1M => "1M",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TickerWindowSizeEnum {
    #[serde(rename = "1m")]
    WindowSize1m,
    #[serde(rename = "2m")]
    WindowSize2m,
    #[serde(rename = "3m")]
    WindowSize3m,
    #[serde(rename = "4m")]
    WindowSize4m,
    #[serde(rename = "5m")]
    WindowSize5m,
    #[serde(rename = "6m")]
    WindowSize6m,
    #[serde(rename = "7m")]
    WindowSize7m,
    #[serde(rename = "8m")]
    WindowSize8m,
    #[serde(rename = "9m")]
    WindowSize9m,
    #[serde(rename = "10m")]
    WindowSize10m,
    #[serde(rename = "11m")]
    WindowSize11m,
    #[serde(rename = "12m")]
    WindowSize12m,
    #[serde(rename = "13m")]
    WindowSize13m,
    #[serde(rename = "14m")]
    WindowSize14m,
    #[serde(rename = "15m")]
    WindowSize15m,
    #[serde(rename = "16m")]
    WindowSize16m,
    #[serde(rename = "17m")]
    WindowSize17m,
    #[serde(rename = "18m")]
    WindowSize18m,
    #[serde(rename = "19m")]
    WindowSize19m,
    #[serde(rename = "20m")]
    WindowSize20m,
    #[serde(rename = "21m")]
    WindowSize21m,
    #[serde(rename = "22m")]
    WindowSize22m,
    #[serde(rename = "23m")]
    WindowSize23m,
    #[serde(rename = "24m")]
    WindowSize24m,
    #[serde(rename = "25m")]
    WindowSize25m,
    #[serde(rename = "26m")]
    WindowSize26m,
    #[serde(rename = "27m")]
    WindowSize27m,
    #[serde(rename = "28m")]
    WindowSize28m,
    #[serde(rename = "29m")]
    WindowSize29m,
    #[serde(rename = "30m")]
    WindowSize30m,
    #[serde(rename = "31m")]
    WindowSize31m,
    #[serde(rename = "32m")]
    WindowSize32m,
    #[serde(rename = "33m")]
    WindowSize33m,
    #[serde(rename = "34m")]
    WindowSize34m,
    #[serde(rename = "35m")]
    WindowSize35m,
    #[serde(rename = "36m")]
    WindowSize36m,
    #[serde(rename = "37m")]
    WindowSize37m,
    #[serde(rename = "38m")]
    WindowSize38m,
    #[serde(rename = "39m")]
    WindowSize39m,
    #[serde(rename = "40m")]
    WindowSize40m,
    #[serde(rename = "41m")]
    WindowSize41m,
    #[serde(rename = "42m")]
    WindowSize42m,
    #[serde(rename = "43m")]
    WindowSize43m,
    #[serde(rename = "44m")]
    WindowSize44m,
    #[serde(rename = "45m")]
    WindowSize45m,
    #[serde(rename = "46m")]
    WindowSize46m,
    #[serde(rename = "47m")]
    WindowSize47m,
    #[serde(rename = "48m")]
    WindowSize48m,
    #[serde(rename = "49m")]
    WindowSize49m,
    #[serde(rename = "50m")]
    WindowSize50m,
    #[serde(rename = "51m")]
    WindowSize51m,
    #[serde(rename = "52m")]
    WindowSize52m,
    #[serde(rename = "53m")]
    WindowSize53m,
    #[serde(rename = "54m")]
    WindowSize54m,
    #[serde(rename = "55m")]
    WindowSize55m,
    #[serde(rename = "56m")]
    WindowSize56m,
    #[serde(rename = "57m")]
    WindowSize57m,
    #[serde(rename = "58m")]
    WindowSize58m,
    #[serde(rename = "59m")]
    WindowSize59m,
    #[serde(rename = "1h")]
    WindowSize1h,
    #[serde(rename = "2h")]
    WindowSize2h,
    #[serde(rename = "3h")]
    WindowSize3h,
    #[serde(rename = "4h")]
    WindowSize4h,
    #[serde(rename = "5h")]
    WindowSize5h,
    #[serde(rename = "6h")]
    WindowSize6h,
    #[serde(rename = "7h")]
    WindowSize7h,
    #[serde(rename = "8h")]
    WindowSize8h,
    #[serde(rename = "9h")]
    WindowSize9h,
    #[serde(rename = "10h")]
    WindowSize10h,
    #[serde(rename = "11h")]
    WindowSize11h,
    #[serde(rename = "12h")]
    WindowSize12h,
    #[serde(rename = "13h")]
    WindowSize13h,
    #[serde(rename = "14h")]
    WindowSize14h,
    #[serde(rename = "15h")]
    WindowSize15h,
    #[serde(rename = "16h")]
    WindowSize16h,
    #[serde(rename = "17h")]
    WindowSize17h,
    #[serde(rename = "18h")]
    WindowSize18h,
    #[serde(rename = "19h")]
    WindowSize19h,
    #[serde(rename = "20h")]
    WindowSize20h,
    #[serde(rename = "21h")]
    WindowSize21h,
    #[serde(rename = "22h")]
    WindowSize22h,
    #[serde(rename = "23h")]
    WindowSize23h,
    #[serde(rename = "1d")]
    WindowSize1d,
    #[serde(rename = "2d")]
    WindowSize2d,
    #[serde(rename = "3d")]
    WindowSize3d,
    #[serde(rename = "4d")]
    WindowSize4d,
    #[serde(rename = "5d")]
    WindowSize5d,
    #[serde(rename = "6d")]
    WindowSize6d,
}

impl TickerWindowSizeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            TickerWindowSizeEnum::WindowSize1m => "1m",
            TickerWindowSizeEnum::WindowSize2m => "2m",
            TickerWindowSizeEnum::WindowSize3m => "3m",
            TickerWindowSizeEnum::WindowSize4m => "4m",
            TickerWindowSizeEnum::WindowSize5m => "5m",
            TickerWindowSizeEnum::WindowSize6m => "6m",
            TickerWindowSizeEnum::WindowSize7m => "7m",
            TickerWindowSizeEnum::WindowSize8m => "8m",
            TickerWindowSizeEnum::WindowSize9m => "9m",
            TickerWindowSizeEnum::WindowSize10m => "10m",
            TickerWindowSizeEnum::WindowSize11m => "11m",
            TickerWindowSizeEnum::WindowSize12m => "12m",
            TickerWindowSizeEnum::WindowSize13m => "13m",
            TickerWindowSizeEnum::WindowSize14m => "14m",
            TickerWindowSizeEnum::WindowSize15m => "15m",
            TickerWindowSizeEnum::WindowSize16m => "16m",
            TickerWindowSizeEnum::WindowSize17m => "17m",
            TickerWindowSizeEnum::WindowSize18m => "18m",
            TickerWindowSizeEnum::WindowSize19m => "19m",
            TickerWindowSizeEnum::WindowSize20m => "20m",
            TickerWindowSizeEnum::WindowSize21m => "21m",
            TickerWindowSizeEnum::WindowSize22m => "22m",
            TickerWindowSizeEnum::WindowSize23m => "23m",
            TickerWindowSizeEnum::WindowSize24m => "24m",
            TickerWindowSizeEnum::WindowSize25m => "25m",
            TickerWindowSizeEnum::WindowSize26m => "26m",
            TickerWindowSizeEnum::WindowSize27m => "27m",
            TickerWindowSizeEnum::WindowSize28m => "28m",
            TickerWindowSizeEnum::WindowSize29m => "29m",
            TickerWindowSizeEnum::WindowSize30m => "30m",
            TickerWindowSizeEnum::WindowSize31m => "31m",
            TickerWindowSizeEnum::WindowSize32m => "32m",
            TickerWindowSizeEnum::WindowSize33m => "33m",
            TickerWindowSizeEnum::WindowSize34m => "34m",
            TickerWindowSizeEnum::WindowSize35m => "35m",
            TickerWindowSizeEnum::WindowSize36m => "36m",
            TickerWindowSizeEnum::WindowSize37m => "37m",
            TickerWindowSizeEnum::WindowSize38m => "38m",
            TickerWindowSizeEnum::WindowSize39m => "39m",
            TickerWindowSizeEnum::WindowSize40m => "40m",
            TickerWindowSizeEnum::WindowSize41m => "41m",
            TickerWindowSizeEnum::WindowSize42m => "42m",
            TickerWindowSizeEnum::WindowSize43m => "43m",
            TickerWindowSizeEnum::WindowSize44m => "44m",
            TickerWindowSizeEnum::WindowSize45m => "45m",
            TickerWindowSizeEnum::WindowSize46m => "46m",
            TickerWindowSizeEnum::WindowSize47m => "47m",
            TickerWindowSizeEnum::WindowSize48m => "48m",
            TickerWindowSizeEnum::WindowSize49m => "49m",
            TickerWindowSizeEnum::WindowSize50m => "50m",
            TickerWindowSizeEnum::WindowSize51m => "51m",
            TickerWindowSizeEnum::WindowSize52m => "52m",
            TickerWindowSizeEnum::WindowSize53m => "53m",
            TickerWindowSizeEnum::WindowSize54m => "54m",
            TickerWindowSizeEnum::WindowSize55m => "55m",
            TickerWindowSizeEnum::WindowSize56m => "56m",
            TickerWindowSizeEnum::WindowSize57m => "57m",
            TickerWindowSizeEnum::WindowSize58m => "58m",
            TickerWindowSizeEnum::WindowSize59m => "59m",
            TickerWindowSizeEnum::WindowSize1h => "1h",
            TickerWindowSizeEnum::WindowSize2h => "2h",
            TickerWindowSizeEnum::WindowSize3h => "3h",
            TickerWindowSizeEnum::WindowSize4h => "4h",
            TickerWindowSizeEnum::WindowSize5h => "5h",
            TickerWindowSizeEnum::WindowSize6h => "6h",
            TickerWindowSizeEnum::WindowSize7h => "7h",
            TickerWindowSizeEnum::WindowSize8h => "8h",
            TickerWindowSizeEnum::WindowSize9h => "9h",
            TickerWindowSizeEnum::WindowSize10h => "10h",
            TickerWindowSizeEnum::WindowSize11h => "11h",
            TickerWindowSizeEnum::WindowSize12h => "12h",
            TickerWindowSizeEnum::WindowSize13h => "13h",
            TickerWindowSizeEnum::WindowSize14h => "14h",
            TickerWindowSizeEnum::WindowSize15h => "15h",
            TickerWindowSizeEnum::WindowSize16h => "16h",
            TickerWindowSizeEnum::WindowSize17h => "17h",
            TickerWindowSizeEnum::WindowSize18h => "18h",
            TickerWindowSizeEnum::WindowSize19h => "19h",
            TickerWindowSizeEnum::WindowSize20h => "20h",
            TickerWindowSizeEnum::WindowSize21h => "21h",
            TickerWindowSizeEnum::WindowSize22h => "22h",
            TickerWindowSizeEnum::WindowSize23h => "23h",
            TickerWindowSizeEnum::WindowSize1d => "1d",
            TickerWindowSizeEnum::WindowSize2d => "2d",
            TickerWindowSizeEnum::WindowSize3d => "3d",
            TickerWindowSizeEnum::WindowSize4d => "4d",
            TickerWindowSizeEnum::WindowSize5d => "5d",
            TickerWindowSizeEnum::WindowSize6d => "6d",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TickerTypeEnum {
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MINI")]
    Mini,
}

impl TickerTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            TickerTypeEnum::Full => "FULL",
            TickerTypeEnum::Mini => "MINI",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Ticker24hrTypeEnum {
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MINI")]
    Mini,
}

impl Ticker24hrTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Ticker24hrTypeEnum::Full => "FULL",
            Ticker24hrTypeEnum::Mini => "MINI",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TickerTradingDayTypeEnum {
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MINI")]
    Mini,
}

impl TickerTradingDayTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            TickerTradingDayTypeEnum::Full => "FULL",
            TickerTradingDayTypeEnum::Mini => "MINI",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UiKlinesIntervalEnum {
    #[serde(rename = "1s")]
    Interval1s,
    #[serde(rename = "1m")]
    Interval1m,
    #[serde(rename = "3m")]
    Interval3m,
    #[serde(rename = "5m")]
    Interval5m,
    #[serde(rename = "15m")]
    Interval15m,
    #[serde(rename = "30m")]
    Interval30m,
    #[serde(rename = "1h")]
    Interval1h,
    #[serde(rename = "2h")]
    Interval2h,
    #[serde(rename = "4h")]
    Interval4h,
    #[serde(rename = "6h")]
    Interval6h,
    #[serde(rename = "8h")]
    Interval8h,
    #[serde(rename = "12h")]
    Interval12h,
    #[serde(rename = "1d")]
    Interval1d,
    #[serde(rename = "3d")]
    Interval3d,
    #[serde(rename = "1w")]
    Interval1w,
    #[serde(rename = "1M")]
    Interval1M,
}

impl UiKlinesIntervalEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            UiKlinesIntervalEnum::Interval1s => "1s",
            UiKlinesIntervalEnum::Interval1m => "1m",
            UiKlinesIntervalEnum::Interval3m => "3m",
            UiKlinesIntervalEnum::Interval5m => "5m",
            UiKlinesIntervalEnum::Interval15m => "15m",
            UiKlinesIntervalEnum::Interval30m => "30m",
            UiKlinesIntervalEnum::Interval1h => "1h",
            UiKlinesIntervalEnum::Interval2h => "2h",
            UiKlinesIntervalEnum::Interval4h => "4h",
            UiKlinesIntervalEnum::Interval6h => "6h",
            UiKlinesIntervalEnum::Interval8h => "8h",
            UiKlinesIntervalEnum::Interval12h => "12h",
            UiKlinesIntervalEnum::Interval1d => "1d",
            UiKlinesIntervalEnum::Interval3d => "3d",
            UiKlinesIntervalEnum::Interval1w => "1w",
            UiKlinesIntervalEnum::Interval1M => "1M",
        }
    }
}

/// Request parameters for the [`agg_trades`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`agg_trades`](#method.agg_trades).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AggTradesParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// ID to get aggregate trades from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from_id: Option<i64>,
    /// Timestamp in ms to get aggregate trades from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get aggregate trades until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default: 500; Maximum: 1000.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl AggTradesParams {
    /// Create a builder for [`agg_trades`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> AggTradesParamsBuilder {
        AggTradesParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`avg_price`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`avg_price`](#method.avg_price).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AvgPriceParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
}

impl AvgPriceParams {
    /// Create a builder for [`avg_price`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> AvgPriceParamsBuilder {
        AvgPriceParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`depth`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`depth`](#method.depth).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct DepthParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Default: 500; Maximum: 1000.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl DepthParams {
    /// Create a builder for [`depth`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> DepthParamsBuilder {
        DepthParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`get_trades`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_trades`](#method.get_trades).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetTradesParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Default: 500; Maximum: 1000.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl GetTradesParams {
    /// Create a builder for [`get_trades`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> GetTradesParamsBuilder {
        GetTradesParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`historical_trades`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`historical_trades`](#method.historical_trades).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct HistoricalTradesParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Default: 500; Maximum: 1000.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
    /// ID to get aggregate trades from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from_id: Option<i64>,
}

impl HistoricalTradesParams {
    /// Create a builder for [`historical_trades`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> HistoricalTradesParamsBuilder {
        HistoricalTradesParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`klines`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`klines`](#method.klines).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct KlinesParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `interval` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub interval: KlinesIntervalEnum,
    /// Timestamp in ms to get aggregate trades from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get aggregate trades until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default: 0 (UTC)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_zone: Option<String>,
    /// Default: 500; Maximum: 1000.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl KlinesParams {
    /// Create a builder for [`klines`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `interval` — String
    ///
    #[must_use]
    pub fn builder(symbol: String, interval: KlinesIntervalEnum) -> KlinesParamsBuilder {
        KlinesParamsBuilder::default()
            .symbol(symbol)
            .interval(interval)
    }
}
/// Request parameters for the [`ticker`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker`](#method.ticker).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TickerParams {
    /// Symbol to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
    ///
    /// The `window_size` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub window_size: Option<TickerWindowSizeEnum>,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub r#type: Option<TickerTypeEnum>,
}

impl TickerParams {
    /// Create a builder for [`ticker`].
    ///
    #[must_use]
    pub fn builder() -> TickerParamsBuilder {
        TickerParamsBuilder::default()
    }
}
/// Request parameters for the [`ticker24hr`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker24hr`](#method.ticker24hr).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct Ticker24hrParams {
    /// Symbol to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub r#type: Option<Ticker24hrTypeEnum>,
}

impl Ticker24hrParams {
    /// Create a builder for [`ticker24hr`].
    ///
    #[must_use]
    pub fn builder() -> Ticker24hrParamsBuilder {
        Ticker24hrParamsBuilder::default()
    }
}
/// Request parameters for the [`ticker_book_ticker`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker_book_ticker`](#method.ticker_book_ticker).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TickerBookTickerParams {
    /// Symbol to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
}

impl TickerBookTickerParams {
    /// Create a builder for [`ticker_book_ticker`].
    ///
    #[must_use]
    pub fn builder() -> TickerBookTickerParamsBuilder {
        TickerBookTickerParamsBuilder::default()
    }
}
/// Request parameters for the [`ticker_price`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker_price`](#method.ticker_price).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TickerPriceParams {
    /// Symbol to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
}

impl TickerPriceParams {
    /// Create a builder for [`ticker_price`].
    ///
    #[must_use]
    pub fn builder() -> TickerPriceParamsBuilder {
        TickerPriceParamsBuilder::default()
    }
}
/// Request parameters for the [`ticker_trading_day`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker_trading_day`](#method.ticker_trading_day).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TickerTradingDayParams {
    /// Symbol to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
    /// Default: 0 (UTC)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_zone: Option<String>,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub r#type: Option<TickerTradingDayTypeEnum>,
}

impl TickerTradingDayParams {
    /// Create a builder for [`ticker_trading_day`].
    ///
    #[must_use]
    pub fn builder() -> TickerTradingDayParamsBuilder {
        TickerTradingDayParamsBuilder::default()
    }
}
/// Request parameters for the [`ui_klines`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ui_klines`](#method.ui_klines).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct UiKlinesParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `interval` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub interval: UiKlinesIntervalEnum,
    /// Timestamp in ms to get aggregate trades from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get aggregate trades until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default: 0 (UTC)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_zone: Option<String>,
    /// Default: 500; Maximum: 1000.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl UiKlinesParams {
    /// Create a builder for [`ui_klines`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `interval` — String
    ///
    #[must_use]
    pub fn builder(symbol: String, interval: UiKlinesIntervalEnum) -> UiKlinesParamsBuilder {
        UiKlinesParamsBuilder::default()
            .symbol(symbol)
            .interval(interval)
    }
}

#[async_trait]
impl MarketApi for MarketApiClient {
    async fn agg_trades(
        &self,
        params: AggTradesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::AggTradesResponseInner>>> {
        let AggTradesParams {
            symbol,
            from_id,
            start_time,
            end_time,
            limit,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = from_id {
            query_params.insert("fromId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        send_request::<Vec<models::AggTradesResponseInner>>(
            &self.configuration,
            "/api/v3/aggTrades",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn avg_price(
        &self,
        params: AvgPriceParams,
    ) -> anyhow::Result<RestApiResponse<models::AvgPriceResponse>> {
        let AvgPriceParams { symbol } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        send_request::<models::AvgPriceResponse>(
            &self.configuration,
            "/api/v3/avgPrice",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn depth(
        &self,
        params: DepthParams,
    ) -> anyhow::Result<RestApiResponse<models::DepthResponse>> {
        let DepthParams { symbol, limit } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        send_request::<models::DepthResponse>(
            &self.configuration,
            "/api/v3/depth",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn get_trades(
        &self,
        params: GetTradesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::HistoricalTradesResponseInner>>> {
        let GetTradesParams { symbol, limit } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        send_request::<Vec<models::HistoricalTradesResponseInner>>(
            &self.configuration,
            "/api/v3/trades",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn historical_trades(
        &self,
        params: HistoricalTradesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::HistoricalTradesResponseInner>>> {
        let HistoricalTradesParams {
            symbol,
            limit,
            from_id,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = from_id {
            query_params.insert("fromId".to_string(), json!(rw));
        }

        send_request::<Vec<models::HistoricalTradesResponseInner>>(
            &self.configuration,
            "/api/v3/historicalTrades",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn klines(
        &self,
        params: KlinesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<Vec<models::KlinesItemInner>>>> {
        let KlinesParams {
            symbol,
            interval,
            start_time,
            end_time,
            time_zone,
            limit,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("interval".to_string(), json!(interval));

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = time_zone {
            query_params.insert("timeZone".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        send_request::<Vec<Vec<models::KlinesItemInner>>>(
            &self.configuration,
            "/api/v3/klines",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn ticker(
        &self,
        params: TickerParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerResponse>> {
        let TickerParams {
            symbol,
            symbols,
            window_size,
            r#type,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = symbols {
            query_params.insert("symbols".to_string(), json!(rw));
        }

        if let Some(rw) = window_size {
            query_params.insert("windowSize".to_string(), json!(rw));
        }

        if let Some(rw) = r#type {
            query_params.insert("type".to_string(), json!(rw));
        }

        send_request::<models::TickerResponse>(
            &self.configuration,
            "/api/v3/ticker",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn ticker24hr(
        &self,
        params: Ticker24hrParams,
    ) -> anyhow::Result<RestApiResponse<models::Ticker24hrResponse>> {
        let Ticker24hrParams {
            symbol,
            symbols,
            r#type,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = symbols {
            query_params.insert("symbols".to_string(), json!(rw));
        }

        if let Some(rw) = r#type {
            query_params.insert("type".to_string(), json!(rw));
        }

        send_request::<models::Ticker24hrResponse>(
            &self.configuration,
            "/api/v3/ticker/24hr",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn ticker_book_ticker(
        &self,
        params: TickerBookTickerParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerBookTickerResponse>> {
        let TickerBookTickerParams { symbol, symbols } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = symbols {
            query_params.insert("symbols".to_string(), json!(rw));
        }

        send_request::<models::TickerBookTickerResponse>(
            &self.configuration,
            "/api/v3/ticker/bookTicker",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn ticker_price(
        &self,
        params: TickerPriceParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerPriceResponse>> {
        let TickerPriceParams { symbol, symbols } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = symbols {
            query_params.insert("symbols".to_string(), json!(rw));
        }

        send_request::<models::TickerPriceResponse>(
            &self.configuration,
            "/api/v3/ticker/price",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn ticker_trading_day(
        &self,
        params: TickerTradingDayParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerTradingDayResponse>> {
        let TickerTradingDayParams {
            symbol,
            symbols,
            time_zone,
            r#type,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = symbols {
            query_params.insert("symbols".to_string(), json!(rw));
        }

        if let Some(rw) = time_zone {
            query_params.insert("timeZone".to_string(), json!(rw));
        }

        if let Some(rw) = r#type {
            query_params.insert("type".to_string(), json!(rw));
        }

        send_request::<models::TickerTradingDayResponse>(
            &self.configuration,
            "/api/v3/ticker/tradingDay",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn ui_klines(
        &self,
        params: UiKlinesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<Vec<models::KlinesItemInner>>>> {
        let UiKlinesParams {
            symbol,
            interval,
            start_time,
            end_time,
            time_zone,
            limit,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("interval".to_string(), json!(interval));

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = time_zone {
            query_params.insert("timeZone".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        send_request::<Vec<Vec<models::KlinesItemInner>>>(
            &self.configuration,
            "/api/v3/uiKlines",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }
}

#[cfg(all(test, feature = "spot"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockMarketApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl MarketApi for MockMarketApiClient {
        async fn agg_trades(
            &self,
            _params: AggTradesParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::AggTradesResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"a":26129,"p":"0.01633102","q":"4.70443515","f":27781,"l":27781,"T":1498793709153,"m":true,"M":true}]"#).unwrap();
            let dummy_response: Vec<models::AggTradesResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::AggTradesResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn avg_price(
            &self,
            _params: AvgPriceParams,
        ) -> anyhow::Result<RestApiResponse<models::AvgPriceResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"mins":5,"price":"9.35751834","closeTime":1694061154503}"#,
            )
            .unwrap();
            let dummy_response: models::AvgPriceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AvgPriceResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn depth(
            &self,
            _params: DepthParams,
        ) -> anyhow::Result<RestApiResponse<models::DepthResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"lastUpdateId":1027024,"bids":[["4.00000000","431.00000000"]],"asks":[["4.00000200","12.00000000"]]}"#).unwrap();
            let dummy_response: models::DepthResponse = serde_json::from_value(resp_json.clone())
                .expect("should parse into models::DepthResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_trades(
            &self,
            _params: GetTradesParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::HistoricalTradesResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"id":28457,"price":"4.00000100","qty":"12.00000000","quoteQty":"48.000012","time":1499865549590,"isBuyerMaker":true,"isBestMatch":true}]"#).unwrap();
            let dummy_response: Vec<models::HistoricalTradesResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::HistoricalTradesResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn historical_trades(
            &self,
            _params: HistoricalTradesParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::HistoricalTradesResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"id":28457,"price":"4.00000100","qty":"12.00000000","quoteQty":"48.000012","time":1499865549590,"isBuyerMaker":true,"isBestMatch":true}]"#).unwrap();
            let dummy_response: Vec<models::HistoricalTradesResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::HistoricalTradesResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn klines(
            &self,
            _params: KlinesParams,
        ) -> anyhow::Result<RestApiResponse<Vec<Vec<models::KlinesItemInner>>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[[1499040000000,"0.01634790","0.80000000","0.01575800","0.01577100","148976.11427815",1499644799999,"2434.19055334",308,"1756.87402397","28.46694368","0"]]"#).unwrap();
            let dummy_response: Vec<Vec<models::KlinesItemInner>> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<Vec<models::KlinesItemInner>>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn ticker(
            &self,
            _params: TickerParams,
        ) -> anyhow::Result<RestApiResponse<models::TickerResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","openPrice":"0.10000000","highPrice":"2.00000000","lowPrice":"0.10000000","lastPrice":"2.00000000","volume":"39.00000000","quoteVolume":"13.40000000","openTime":1656986580000,"closeTime":1657001016795,"firstId":0,"lastId":34,"count":35}"#).unwrap();
            let dummy_response: models::TickerResponse = serde_json::from_value(resp_json.clone())
                .expect("should parse into models::TickerResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn ticker24hr(
            &self,
            _params: Ticker24hrParams,
        ) -> anyhow::Result<RestApiResponse<models::Ticker24hrResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BNBBTC","openPrice":"99.00000000","highPrice":"100.00000000","lowPrice":"0.10000000","lastPrice":"4.00000200","volume":"8913.30000000","quoteVolume":"15.30000000","openTime":1499783499040,"closeTime":1499869899040,"firstId":28385,"lastId":28460,"count":76}"#).unwrap();
            let dummy_response: models::Ticker24hrResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::Ticker24hrResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn ticker_book_ticker(
            &self,
            _params: TickerBookTickerParams,
        ) -> anyhow::Result<RestApiResponse<models::TickerBookTickerResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","bidPrice":"4.00000000","bidQty":"431.00000000","askPrice":"4.00000200","askQty":"9.00000000"}"#).unwrap();
            let dummy_response: models::TickerBookTickerResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TickerBookTickerResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn ticker_price(
            &self,
            _params: TickerPriceParams,
        ) -> anyhow::Result<RestApiResponse<models::TickerPriceResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"symbol":"LTCBTC","price":"4.00000200"}"#).unwrap();
            let dummy_response: models::TickerPriceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TickerPriceResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn ticker_trading_day(
            &self,
            _params: TickerTradingDayParams,
        ) -> anyhow::Result<RestApiResponse<models::TickerTradingDayResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","openPrice":"26304.80000000","highPrice":"26397.46000000","lowPrice":"26088.34000000","lastPrice":"26221.67000000","volume":"18495.35066000","quoteVolume":"485217905.04210480","openTime":1695686400000,"closeTime":1695772799999,"firstId":3220151555,"lastId":3220849281,"count":697727}"#).unwrap();
            let dummy_response: models::TickerTradingDayResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TickerTradingDayResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn ui_klines(
            &self,
            _params: UiKlinesParams,
        ) -> anyhow::Result<RestApiResponse<Vec<Vec<models::KlinesItemInner>>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[[1499040000000,"0.01634790","0.80000000","0.01575800","0.01577100","148976.11427815",1499644799999,"2434.19055334",308,"1756.87402397","28.46694368","0"]]"#).unwrap();
            let dummy_response: Vec<Vec<models::KlinesItemInner>> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<Vec<models::KlinesItemInner>>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn agg_trades_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = AggTradesParams::builder("BNBUSDT".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"a":26129,"p":"0.01633102","q":"4.70443515","f":27781,"l":27781,"T":1498793709153,"m":true,"M":true}]"#).unwrap();
            let expected_response : Vec<models::AggTradesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::AggTradesResponseInner>");

            let resp = client.agg_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn agg_trades_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = AggTradesParams::builder("BNBUSDT".to_string(),).from_id(1).start_time(1735693200000).end_time(1735693200000).limit(500).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"a":26129,"p":"0.01633102","q":"4.70443515","f":27781,"l":27781,"T":1498793709153,"m":true,"M":true}]"#).unwrap();
            let expected_response : Vec<models::AggTradesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::AggTradesResponseInner>");

            let resp = client.agg_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn agg_trades_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = AggTradesParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            match client.agg_trades(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn avg_price_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = AvgPriceParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"mins":5,"price":"9.35751834","closeTime":1694061154503}"#,
            )
            .unwrap();
            let expected_response: models::AvgPriceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AvgPriceResponse");

            let resp = client.avg_price(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn avg_price_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = AvgPriceParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"mins":5,"price":"9.35751834","closeTime":1694061154503}"#,
            )
            .unwrap();
            let expected_response: models::AvgPriceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AvgPriceResponse");

            let resp = client.avg_price(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn avg_price_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = AvgPriceParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            match client.avg_price(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn depth_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = DepthParams::builder("BNBUSDT".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"lastUpdateId":1027024,"bids":[["4.00000000","431.00000000"]],"asks":[["4.00000200","12.00000000"]]}"#).unwrap();
            let expected_response : models::DepthResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::DepthResponse");

            let resp = client.depth(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn depth_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = DepthParams::builder("BNBUSDT".to_string(),).limit(500).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"lastUpdateId":1027024,"bids":[["4.00000000","431.00000000"]],"asks":[["4.00000200","12.00000000"]]}"#).unwrap();
            let expected_response : models::DepthResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::DepthResponse");

            let resp = client.depth(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn depth_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = DepthParams::builder("BNBUSDT".to_string()).build().unwrap();

            match client.depth(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_trades_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = GetTradesParams::builder("BNBUSDT".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":28457,"price":"4.00000100","qty":"12.00000000","quoteQty":"48.000012","time":1499865549590,"isBuyerMaker":true,"isBestMatch":true}]"#).unwrap();
            let expected_response : Vec<models::HistoricalTradesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::HistoricalTradesResponseInner>");

            let resp = client.get_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_trades_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = GetTradesParams::builder("BNBUSDT".to_string(),).limit(500).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":28457,"price":"4.00000100","qty":"12.00000000","quoteQty":"48.000012","time":1499865549590,"isBuyerMaker":true,"isBestMatch":true}]"#).unwrap();
            let expected_response : Vec<models::HistoricalTradesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::HistoricalTradesResponseInner>");

            let resp = client.get_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_trades_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = GetTradesParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            match client.get_trades(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn historical_trades_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = HistoricalTradesParams::builder("BNBUSDT".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":28457,"price":"4.00000100","qty":"12.00000000","quoteQty":"48.000012","time":1499865549590,"isBuyerMaker":true,"isBestMatch":true}]"#).unwrap();
            let expected_response : Vec<models::HistoricalTradesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::HistoricalTradesResponseInner>");

            let resp = client.historical_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn historical_trades_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = HistoricalTradesParams::builder("BNBUSDT".to_string(),).limit(500).from_id(1).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":28457,"price":"4.00000100","qty":"12.00000000","quoteQty":"48.000012","time":1499865549590,"isBuyerMaker":true,"isBestMatch":true}]"#).unwrap();
            let expected_response : Vec<models::HistoricalTradesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::HistoricalTradesResponseInner>");

            let resp = client.historical_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn historical_trades_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = HistoricalTradesParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            match client.historical_trades(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn klines_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = KlinesParams::builder("BNBUSDT".to_string(),KlinesIntervalEnum::Interval1s,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[[1499040000000,"0.01634790","0.80000000","0.01575800","0.01577100","148976.11427815",1499644799999,"2434.19055334",308,"1756.87402397","28.46694368","0"]]"#).unwrap();
            let expected_response : Vec<Vec<models::KlinesItemInner>> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<Vec<models::KlinesItemInner>>");

            let resp = client.klines(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn klines_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = KlinesParams::builder("BNBUSDT".to_string(),KlinesIntervalEnum::Interval1s,).start_time(1735693200000).end_time(1735693200000).time_zone("time_zone_example".to_string()).limit(500).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[[1499040000000,"0.01634790","0.80000000","0.01575800","0.01577100","148976.11427815",1499644799999,"2434.19055334",308,"1756.87402397","28.46694368","0"]]"#).unwrap();
            let expected_response : Vec<Vec<models::KlinesItemInner>> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<Vec<models::KlinesItemInner>>");

            let resp = client.klines(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn klines_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params =
                KlinesParams::builder("BNBUSDT".to_string(), KlinesIntervalEnum::Interval1s)
                    .build()
                    .unwrap();

            match client.klines(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn ticker_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","openPrice":"0.10000000","highPrice":"2.00000000","lowPrice":"0.10000000","lastPrice":"2.00000000","volume":"39.00000000","quoteVolume":"13.40000000","openTime":1656986580000,"closeTime":1657001016795,"firstId":0,"lastId":34,"count":35}"#).unwrap();
            let expected_response : models::TickerResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerResponse");

            let resp = client.ticker(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerParams::builder().symbol("BNBUSDT".to_string()).symbols(["null".to_string(),].to_vec()).window_size(TickerWindowSizeEnum::WindowSize1m).r#type(TickerTypeEnum::Full).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","openPrice":"0.10000000","highPrice":"2.00000000","lowPrice":"0.10000000","lastPrice":"2.00000000","volume":"39.00000000","quoteVolume":"13.40000000","openTime":1656986580000,"closeTime":1657001016795,"firstId":0,"lastId":34,"count":35}"#).unwrap();
            let expected_response : models::TickerResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerResponse");

            let resp = client.ticker(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = TickerParams::builder().build().unwrap();

            match client.ticker(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn ticker24hr_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = Ticker24hrParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BNBBTC","openPrice":"99.00000000","highPrice":"100.00000000","lowPrice":"0.10000000","lastPrice":"4.00000200","volume":"8913.30000000","quoteVolume":"15.30000000","openTime":1499783499040,"closeTime":1499869899040,"firstId":28385,"lastId":28460,"count":76}"#).unwrap();
            let expected_response : models::Ticker24hrResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::Ticker24hrResponse");

            let resp = client.ticker24hr(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker24hr_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = Ticker24hrParams::builder().symbol("BNBUSDT".to_string()).symbols(["null".to_string(),].to_vec()).r#type(Ticker24hrTypeEnum::Full).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BNBBTC","openPrice":"99.00000000","highPrice":"100.00000000","lowPrice":"0.10000000","lastPrice":"4.00000200","volume":"8913.30000000","quoteVolume":"15.30000000","openTime":1499783499040,"closeTime":1499869899040,"firstId":28385,"lastId":28460,"count":76}"#).unwrap();
            let expected_response : models::Ticker24hrResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::Ticker24hrResponse");

            let resp = client.ticker24hr(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker24hr_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = Ticker24hrParams::builder().build().unwrap();

            match client.ticker24hr(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn ticker_book_ticker_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerBookTickerParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","bidPrice":"4.00000000","bidQty":"431.00000000","askPrice":"4.00000200","askQty":"9.00000000"}"#).unwrap();
            let expected_response : models::TickerBookTickerResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerBookTickerResponse");

            let resp = client.ticker_book_ticker(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_book_ticker_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerBookTickerParams::builder().symbol("BNBUSDT".to_string()).symbols(["null".to_string()].to_vec()).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","bidPrice":"4.00000000","bidQty":"431.00000000","askPrice":"4.00000200","askQty":"9.00000000"}"#).unwrap();
            let expected_response : models::TickerBookTickerResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerBookTickerResponse");

            let resp = client.ticker_book_ticker(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_book_ticker_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = TickerBookTickerParams::builder().build().unwrap();

            match client.ticker_book_ticker(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn ticker_price_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerPriceParams::builder().build().unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"symbol":"LTCBTC","price":"4.00000200"}"#).unwrap();
            let expected_response: models::TickerPriceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TickerPriceResponse");

            let resp = client
                .ticker_price(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_price_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerPriceParams::builder()
                .symbol("BNBUSDT".to_string())
                .symbols(["null".to_string()].to_vec())
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"symbol":"LTCBTC","price":"4.00000200"}"#).unwrap();
            let expected_response: models::TickerPriceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TickerPriceResponse");

            let resp = client
                .ticker_price(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_price_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = TickerPriceParams::builder().build().unwrap();

            match client.ticker_price(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn ticker_trading_day_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerTradingDayParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","openPrice":"26304.80000000","highPrice":"26397.46000000","lowPrice":"26088.34000000","lastPrice":"26221.67000000","volume":"18495.35066000","quoteVolume":"485217905.04210480","openTime":1695686400000,"closeTime":1695772799999,"firstId":3220151555,"lastId":3220849281,"count":697727}"#).unwrap();
            let expected_response : models::TickerTradingDayResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerTradingDayResponse");

            let resp = client.ticker_trading_day(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_trading_day_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerTradingDayParams::builder().symbol("BNBUSDT".to_string()).symbols(["null".to_string(),].to_vec()).time_zone("time_zone_example".to_string()).r#type(TickerTradingDayTypeEnum::Full).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","openPrice":"26304.80000000","highPrice":"26397.46000000","lowPrice":"26088.34000000","lastPrice":"26221.67000000","volume":"18495.35066000","quoteVolume":"485217905.04210480","openTime":1695686400000,"closeTime":1695772799999,"firstId":3220151555,"lastId":3220849281,"count":697727}"#).unwrap();
            let expected_response : models::TickerTradingDayResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerTradingDayResponse");

            let resp = client.ticker_trading_day(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_trading_day_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = TickerTradingDayParams::builder().build().unwrap();

            match client.ticker_trading_day(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn ui_klines_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = UiKlinesParams::builder("BNBUSDT".to_string(),UiKlinesIntervalEnum::Interval1s,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[[1499040000000,"0.01634790","0.80000000","0.01575800","0.01577100","148976.11427815",1499644799999,"2434.19055334",308,"1756.87402397","28.46694368","0"]]"#).unwrap();
            let expected_response : Vec<Vec<models::KlinesItemInner>> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<Vec<models::KlinesItemInner>>");

            let resp = client.ui_klines(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ui_klines_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = UiKlinesParams::builder("BNBUSDT".to_string(),UiKlinesIntervalEnum::Interval1s,).start_time(1735693200000).end_time(1735693200000).time_zone("time_zone_example".to_string()).limit(500).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[[1499040000000,"0.01634790","0.80000000","0.01575800","0.01577100","148976.11427815",1499644799999,"2434.19055334",308,"1756.87402397","28.46694368","0"]]"#).unwrap();
            let expected_response : Vec<Vec<models::KlinesItemInner>> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<Vec<models::KlinesItemInner>>");

            let resp = client.ui_klines(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ui_klines_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params =
                UiKlinesParams::builder("BNBUSDT".to_string(), UiKlinesIntervalEnum::Interval1s)
                    .build()
                    .unwrap();

            match client.ui_klines(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
