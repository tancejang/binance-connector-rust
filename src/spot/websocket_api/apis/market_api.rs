/*
 * Binance Spot WebSocket API
 *
 * OpenAPI Specifications for the Binance Spot WebSocket API
 *
 * API documents:
 * - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)
 * - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use anyhow::Context;
use async_trait::async_trait;
use derive_builder::Builder;
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::{collections::BTreeMap, sync::Arc};

use crate::common::{
    models::{ParamBuildError, WebsocketApiResponse},
    utils::remove_empty_value,
    websocket::{WebsocketApi, WebsocketMessageSendOptions},
};
use crate::spot::websocket_api::models;

#[async_trait]
pub trait MarketApi: Send + Sync {
    async fn avg_price(
        &self,
        params: AvgPriceParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::AvgPriceResponseResult>>>;
    async fn depth(
        &self,
        params: DepthParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::DepthResponseResult>>>;
    async fn klines(
        &self,
        params: KlinesParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<Vec<models::KlinesItemInner>>>>;
    async fn ticker(
        &self,
        params: TickerParams,
    ) -> anyhow::Result<WebsocketApiResponse<models::TickerResponse>>;
    async fn ticker24hr(
        &self,
        params: Ticker24hrParams,
    ) -> anyhow::Result<WebsocketApiResponse<models::Ticker24hrResponse>>;
    async fn ticker_book(
        &self,
        params: TickerBookParams,
    ) -> anyhow::Result<WebsocketApiResponse<models::TickerBookResponse>>;
    async fn ticker_price(
        &self,
        params: TickerPriceParams,
    ) -> anyhow::Result<WebsocketApiResponse<models::TickerPriceResponse>>;
    async fn ticker_trading_day(
        &self,
        params: TickerTradingDayParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<models::TickerTradingDayResponseResultInner>>>;
    async fn trades_aggregate(
        &self,
        params: TradesAggregateParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<models::TradesAggregateResponseResultInner>>>;
    async fn trades_historical(
        &self,
        params: TradesHistoricalParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<models::TradesHistoricalResponseResultInner>>>;
    async fn trades_recent(
        &self,
        params: TradesRecentParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<models::TradesRecentResponseResultInner>>>;
    async fn ui_klines(
        &self,
        params: UiKlinesParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<Vec<models::KlinesItemInner>>>>;
}

pub struct MarketApiClient {
    websocket_api_base: Arc<WebsocketApi>,
}

impl MarketApiClient {
    pub fn new(websocket_api_base: Arc<WebsocketApi>) -> Self {
        Self { websocket_api_base }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum KlinesIntervalEnum {
    #[serde(rename = "1s")]
    Interval1s,
    #[serde(rename = "1m")]
    Interval1m,
    #[serde(rename = "3m")]
    Interval3m,
    #[serde(rename = "5m")]
    Interval5m,
    #[serde(rename = "15m")]
    Interval15m,
    #[serde(rename = "30m")]
    Interval30m,
    #[serde(rename = "1h")]
    Interval1h,
    #[serde(rename = "2h")]
    Interval2h,
    #[serde(rename = "4h")]
    Interval4h,
    #[serde(rename = "6h")]
    Interval6h,
    #[serde(rename = "8h")]
    Interval8h,
    #[serde(rename = "12h")]
    Interval12h,
    #[serde(rename = "1d")]
    Interval1d,
    #[serde(rename = "3d")]
    Interval3d,
    #[serde(rename = "1w")]
    Interval1w,
    #[serde(rename = "1M")]
    Interval1M,
}

impl KlinesIntervalEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            KlinesIntervalEnum::Interval1s => "1s",
            KlinesIntervalEnum::Interval1m => "1m",
            KlinesIntervalEnum::Interval3m => "3m",
            KlinesIntervalEnum::Interval5m => "5m",
            KlinesIntervalEnum::Interval15m => "15m",
            KlinesIntervalEnum::Interval30m => "30m",
            KlinesIntervalEnum::Interval1h => "1h",
            KlinesIntervalEnum::Interval2h => "2h",
            KlinesIntervalEnum::Interval4h => "4h",
            KlinesIntervalEnum::Interval6h => "6h",
            KlinesIntervalEnum::Interval8h => "8h",
            KlinesIntervalEnum::Interval12h => "12h",
            KlinesIntervalEnum::Interval1d => "1d",
            KlinesIntervalEnum::Interval3d => "3d",
            KlinesIntervalEnum::Interval1w => "1w",
            KlinesIntervalEnum::Interval1M => "1M",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TickerTypeEnum {
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MINI")]
    Mini,
}

impl TickerTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            TickerTypeEnum::Full => "FULL",
            TickerTypeEnum::Mini => "MINI",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TickerWindowSizeEnum {
    #[serde(rename = "1m")]
    WindowSize1m,
    #[serde(rename = "2m")]
    WindowSize2m,
    #[serde(rename = "3m")]
    WindowSize3m,
    #[serde(rename = "4m")]
    WindowSize4m,
    #[serde(rename = "5m")]
    WindowSize5m,
    #[serde(rename = "6m")]
    WindowSize6m,
    #[serde(rename = "7m")]
    WindowSize7m,
    #[serde(rename = "8m")]
    WindowSize8m,
    #[serde(rename = "9m")]
    WindowSize9m,
    #[serde(rename = "10m")]
    WindowSize10m,
    #[serde(rename = "11m")]
    WindowSize11m,
    #[serde(rename = "12m")]
    WindowSize12m,
    #[serde(rename = "13m")]
    WindowSize13m,
    #[serde(rename = "14m")]
    WindowSize14m,
    #[serde(rename = "15m")]
    WindowSize15m,
    #[serde(rename = "16m")]
    WindowSize16m,
    #[serde(rename = "17m")]
    WindowSize17m,
    #[serde(rename = "18m")]
    WindowSize18m,
    #[serde(rename = "19m")]
    WindowSize19m,
    #[serde(rename = "20m")]
    WindowSize20m,
    #[serde(rename = "21m")]
    WindowSize21m,
    #[serde(rename = "22m")]
    WindowSize22m,
    #[serde(rename = "23m")]
    WindowSize23m,
    #[serde(rename = "24m")]
    WindowSize24m,
    #[serde(rename = "25m")]
    WindowSize25m,
    #[serde(rename = "26m")]
    WindowSize26m,
    #[serde(rename = "27m")]
    WindowSize27m,
    #[serde(rename = "28m")]
    WindowSize28m,
    #[serde(rename = "29m")]
    WindowSize29m,
    #[serde(rename = "30m")]
    WindowSize30m,
    #[serde(rename = "31m")]
    WindowSize31m,
    #[serde(rename = "32m")]
    WindowSize32m,
    #[serde(rename = "33m")]
    WindowSize33m,
    #[serde(rename = "34m")]
    WindowSize34m,
    #[serde(rename = "35m")]
    WindowSize35m,
    #[serde(rename = "36m")]
    WindowSize36m,
    #[serde(rename = "37m")]
    WindowSize37m,
    #[serde(rename = "38m")]
    WindowSize38m,
    #[serde(rename = "39m")]
    WindowSize39m,
    #[serde(rename = "40m")]
    WindowSize40m,
    #[serde(rename = "41m")]
    WindowSize41m,
    #[serde(rename = "42m")]
    WindowSize42m,
    #[serde(rename = "43m")]
    WindowSize43m,
    #[serde(rename = "44m")]
    WindowSize44m,
    #[serde(rename = "45m")]
    WindowSize45m,
    #[serde(rename = "46m")]
    WindowSize46m,
    #[serde(rename = "47m")]
    WindowSize47m,
    #[serde(rename = "48m")]
    WindowSize48m,
    #[serde(rename = "49m")]
    WindowSize49m,
    #[serde(rename = "50m")]
    WindowSize50m,
    #[serde(rename = "51m")]
    WindowSize51m,
    #[serde(rename = "52m")]
    WindowSize52m,
    #[serde(rename = "53m")]
    WindowSize53m,
    #[serde(rename = "54m")]
    WindowSize54m,
    #[serde(rename = "55m")]
    WindowSize55m,
    #[serde(rename = "56m")]
    WindowSize56m,
    #[serde(rename = "57m")]
    WindowSize57m,
    #[serde(rename = "58m")]
    WindowSize58m,
    #[serde(rename = "59m")]
    WindowSize59m,
    #[serde(rename = "1h")]
    WindowSize1h,
    #[serde(rename = "2h")]
    WindowSize2h,
    #[serde(rename = "3h")]
    WindowSize3h,
    #[serde(rename = "4h")]
    WindowSize4h,
    #[serde(rename = "5h")]
    WindowSize5h,
    #[serde(rename = "6h")]
    WindowSize6h,
    #[serde(rename = "7h")]
    WindowSize7h,
    #[serde(rename = "8h")]
    WindowSize8h,
    #[serde(rename = "9h")]
    WindowSize9h,
    #[serde(rename = "10h")]
    WindowSize10h,
    #[serde(rename = "11h")]
    WindowSize11h,
    #[serde(rename = "12h")]
    WindowSize12h,
    #[serde(rename = "13h")]
    WindowSize13h,
    #[serde(rename = "14h")]
    WindowSize14h,
    #[serde(rename = "15h")]
    WindowSize15h,
    #[serde(rename = "16h")]
    WindowSize16h,
    #[serde(rename = "17h")]
    WindowSize17h,
    #[serde(rename = "18h")]
    WindowSize18h,
    #[serde(rename = "19h")]
    WindowSize19h,
    #[serde(rename = "20h")]
    WindowSize20h,
    #[serde(rename = "21h")]
    WindowSize21h,
    #[serde(rename = "22h")]
    WindowSize22h,
    #[serde(rename = "23h")]
    WindowSize23h,
    #[serde(rename = "1d")]
    WindowSize1d,
    #[serde(rename = "2d")]
    WindowSize2d,
    #[serde(rename = "3d")]
    WindowSize3d,
    #[serde(rename = "4d")]
    WindowSize4d,
    #[serde(rename = "5d")]
    WindowSize5d,
    #[serde(rename = "6d")]
    WindowSize6d,
}

impl TickerWindowSizeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            TickerWindowSizeEnum::WindowSize1m => "1m",
            TickerWindowSizeEnum::WindowSize2m => "2m",
            TickerWindowSizeEnum::WindowSize3m => "3m",
            TickerWindowSizeEnum::WindowSize4m => "4m",
            TickerWindowSizeEnum::WindowSize5m => "5m",
            TickerWindowSizeEnum::WindowSize6m => "6m",
            TickerWindowSizeEnum::WindowSize7m => "7m",
            TickerWindowSizeEnum::WindowSize8m => "8m",
            TickerWindowSizeEnum::WindowSize9m => "9m",
            TickerWindowSizeEnum::WindowSize10m => "10m",
            TickerWindowSizeEnum::WindowSize11m => "11m",
            TickerWindowSizeEnum::WindowSize12m => "12m",
            TickerWindowSizeEnum::WindowSize13m => "13m",
            TickerWindowSizeEnum::WindowSize14m => "14m",
            TickerWindowSizeEnum::WindowSize15m => "15m",
            TickerWindowSizeEnum::WindowSize16m => "16m",
            TickerWindowSizeEnum::WindowSize17m => "17m",
            TickerWindowSizeEnum::WindowSize18m => "18m",
            TickerWindowSizeEnum::WindowSize19m => "19m",
            TickerWindowSizeEnum::WindowSize20m => "20m",
            TickerWindowSizeEnum::WindowSize21m => "21m",
            TickerWindowSizeEnum::WindowSize22m => "22m",
            TickerWindowSizeEnum::WindowSize23m => "23m",
            TickerWindowSizeEnum::WindowSize24m => "24m",
            TickerWindowSizeEnum::WindowSize25m => "25m",
            TickerWindowSizeEnum::WindowSize26m => "26m",
            TickerWindowSizeEnum::WindowSize27m => "27m",
            TickerWindowSizeEnum::WindowSize28m => "28m",
            TickerWindowSizeEnum::WindowSize29m => "29m",
            TickerWindowSizeEnum::WindowSize30m => "30m",
            TickerWindowSizeEnum::WindowSize31m => "31m",
            TickerWindowSizeEnum::WindowSize32m => "32m",
            TickerWindowSizeEnum::WindowSize33m => "33m",
            TickerWindowSizeEnum::WindowSize34m => "34m",
            TickerWindowSizeEnum::WindowSize35m => "35m",
            TickerWindowSizeEnum::WindowSize36m => "36m",
            TickerWindowSizeEnum::WindowSize37m => "37m",
            TickerWindowSizeEnum::WindowSize38m => "38m",
            TickerWindowSizeEnum::WindowSize39m => "39m",
            TickerWindowSizeEnum::WindowSize40m => "40m",
            TickerWindowSizeEnum::WindowSize41m => "41m",
            TickerWindowSizeEnum::WindowSize42m => "42m",
            TickerWindowSizeEnum::WindowSize43m => "43m",
            TickerWindowSizeEnum::WindowSize44m => "44m",
            TickerWindowSizeEnum::WindowSize45m => "45m",
            TickerWindowSizeEnum::WindowSize46m => "46m",
            TickerWindowSizeEnum::WindowSize47m => "47m",
            TickerWindowSizeEnum::WindowSize48m => "48m",
            TickerWindowSizeEnum::WindowSize49m => "49m",
            TickerWindowSizeEnum::WindowSize50m => "50m",
            TickerWindowSizeEnum::WindowSize51m => "51m",
            TickerWindowSizeEnum::WindowSize52m => "52m",
            TickerWindowSizeEnum::WindowSize53m => "53m",
            TickerWindowSizeEnum::WindowSize54m => "54m",
            TickerWindowSizeEnum::WindowSize55m => "55m",
            TickerWindowSizeEnum::WindowSize56m => "56m",
            TickerWindowSizeEnum::WindowSize57m => "57m",
            TickerWindowSizeEnum::WindowSize58m => "58m",
            TickerWindowSizeEnum::WindowSize59m => "59m",
            TickerWindowSizeEnum::WindowSize1h => "1h",
            TickerWindowSizeEnum::WindowSize2h => "2h",
            TickerWindowSizeEnum::WindowSize3h => "3h",
            TickerWindowSizeEnum::WindowSize4h => "4h",
            TickerWindowSizeEnum::WindowSize5h => "5h",
            TickerWindowSizeEnum::WindowSize6h => "6h",
            TickerWindowSizeEnum::WindowSize7h => "7h",
            TickerWindowSizeEnum::WindowSize8h => "8h",
            TickerWindowSizeEnum::WindowSize9h => "9h",
            TickerWindowSizeEnum::WindowSize10h => "10h",
            TickerWindowSizeEnum::WindowSize11h => "11h",
            TickerWindowSizeEnum::WindowSize12h => "12h",
            TickerWindowSizeEnum::WindowSize13h => "13h",
            TickerWindowSizeEnum::WindowSize14h => "14h",
            TickerWindowSizeEnum::WindowSize15h => "15h",
            TickerWindowSizeEnum::WindowSize16h => "16h",
            TickerWindowSizeEnum::WindowSize17h => "17h",
            TickerWindowSizeEnum::WindowSize18h => "18h",
            TickerWindowSizeEnum::WindowSize19h => "19h",
            TickerWindowSizeEnum::WindowSize20h => "20h",
            TickerWindowSizeEnum::WindowSize21h => "21h",
            TickerWindowSizeEnum::WindowSize22h => "22h",
            TickerWindowSizeEnum::WindowSize23h => "23h",
            TickerWindowSizeEnum::WindowSize1d => "1d",
            TickerWindowSizeEnum::WindowSize2d => "2d",
            TickerWindowSizeEnum::WindowSize3d => "3d",
            TickerWindowSizeEnum::WindowSize4d => "4d",
            TickerWindowSizeEnum::WindowSize5d => "5d",
            TickerWindowSizeEnum::WindowSize6d => "6d",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Ticker24hrTypeEnum {
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MINI")]
    Mini,
}

impl Ticker24hrTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Ticker24hrTypeEnum::Full => "FULL",
            Ticker24hrTypeEnum::Mini => "MINI",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TickerTradingDayTypeEnum {
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MINI")]
    Mini,
}

impl TickerTradingDayTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            TickerTradingDayTypeEnum::Full => "FULL",
            TickerTradingDayTypeEnum::Mini => "MINI",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UiKlinesIntervalEnum {
    #[serde(rename = "1s")]
    Interval1s,
    #[serde(rename = "1m")]
    Interval1m,
    #[serde(rename = "3m")]
    Interval3m,
    #[serde(rename = "5m")]
    Interval5m,
    #[serde(rename = "15m")]
    Interval15m,
    #[serde(rename = "30m")]
    Interval30m,
    #[serde(rename = "1h")]
    Interval1h,
    #[serde(rename = "2h")]
    Interval2h,
    #[serde(rename = "4h")]
    Interval4h,
    #[serde(rename = "6h")]
    Interval6h,
    #[serde(rename = "8h")]
    Interval8h,
    #[serde(rename = "12h")]
    Interval12h,
    #[serde(rename = "1d")]
    Interval1d,
    #[serde(rename = "3d")]
    Interval3d,
    #[serde(rename = "1w")]
    Interval1w,
    #[serde(rename = "1M")]
    Interval1M,
}

impl UiKlinesIntervalEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            UiKlinesIntervalEnum::Interval1s => "1s",
            UiKlinesIntervalEnum::Interval1m => "1m",
            UiKlinesIntervalEnum::Interval3m => "3m",
            UiKlinesIntervalEnum::Interval5m => "5m",
            UiKlinesIntervalEnum::Interval15m => "15m",
            UiKlinesIntervalEnum::Interval30m => "30m",
            UiKlinesIntervalEnum::Interval1h => "1h",
            UiKlinesIntervalEnum::Interval2h => "2h",
            UiKlinesIntervalEnum::Interval4h => "4h",
            UiKlinesIntervalEnum::Interval6h => "6h",
            UiKlinesIntervalEnum::Interval8h => "8h",
            UiKlinesIntervalEnum::Interval12h => "12h",
            UiKlinesIntervalEnum::Interval1d => "1d",
            UiKlinesIntervalEnum::Interval3d => "3d",
            UiKlinesIntervalEnum::Interval1w => "1w",
            UiKlinesIntervalEnum::Interval1M => "1M",
        }
    }
}

/// Request parameters for the [`avg_price`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`avg_price`](#method.avg_price).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AvgPriceParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
}

impl AvgPriceParams {
    /// Create a builder for [`avg_price`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> AvgPriceParamsBuilder {
        AvgPriceParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`depth`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`depth`](#method.depth).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct DepthParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Default: 100; Maximum: 5000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl DepthParams {
    /// Create a builder for [`depth`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> DepthParamsBuilder {
        DepthParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`klines`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`klines`](#method.klines).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct KlinesParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `interval` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub interval: KlinesIntervalEnum,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default: 0 (UTC)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_zone: Option<String>,
    /// Default: 100; Maximum: 5000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl KlinesParams {
    /// Create a builder for [`klines`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `interval` — String
    ///
    #[must_use]
    pub fn builder(symbol: String, interval: KlinesIntervalEnum) -> KlinesParamsBuilder {
        KlinesParamsBuilder::default()
            .symbol(symbol)
            .interval(interval)
    }
}
/// Request parameters for the [`ticker`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker`](#method.ticker).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TickerParams {
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Describe a single symbol
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub r#type: Option<TickerTypeEnum>,
    ///
    /// The `window_size` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub window_size: Option<TickerWindowSizeEnum>,
}

impl TickerParams {
    /// Create a builder for [`ticker`].
    ///
    #[must_use]
    pub fn builder() -> TickerParamsBuilder {
        TickerParamsBuilder::default()
    }
}
/// Request parameters for the [`ticker24hr`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker24hr`](#method.ticker24hr).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct Ticker24hrParams {
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Describe a single symbol
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub r#type: Option<Ticker24hrTypeEnum>,
}

impl Ticker24hrParams {
    /// Create a builder for [`ticker24hr`].
    ///
    #[must_use]
    pub fn builder() -> Ticker24hrParamsBuilder {
        Ticker24hrParamsBuilder::default()
    }
}
/// Request parameters for the [`ticker_book`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker_book`](#method.ticker_book).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TickerBookParams {
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Describe a single symbol
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
}

impl TickerBookParams {
    /// Create a builder for [`ticker_book`].
    ///
    #[must_use]
    pub fn builder() -> TickerBookParamsBuilder {
        TickerBookParamsBuilder::default()
    }
}
/// Request parameters for the [`ticker_price`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker_price`](#method.ticker_price).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TickerPriceParams {
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Describe a single symbol
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
}

impl TickerPriceParams {
    /// Create a builder for [`ticker_price`].
    ///
    #[must_use]
    pub fn builder() -> TickerPriceParamsBuilder {
        TickerPriceParamsBuilder::default()
    }
}
/// Request parameters for the [`ticker_trading_day`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker_trading_day`](#method.ticker_trading_day).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TickerTradingDayParams {
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Describe a single symbol
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
    /// Default: 0 (UTC)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_zone: Option<String>,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub r#type: Option<TickerTradingDayTypeEnum>,
}

impl TickerTradingDayParams {
    /// Create a builder for [`ticker_trading_day`].
    ///
    #[must_use]
    pub fn builder() -> TickerTradingDayParamsBuilder {
        TickerTradingDayParamsBuilder::default()
    }
}
/// Request parameters for the [`trades_aggregate`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`trades_aggregate`](#method.trades_aggregate).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TradesAggregateParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Aggregate trade ID to begin at
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from_id: Option<i32>,
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default: 100; Maximum: 5000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl TradesAggregateParams {
    /// Create a builder for [`trades_aggregate`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> TradesAggregateParamsBuilder {
        TradesAggregateParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`trades_historical`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`trades_historical`](#method.trades_historical).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TradesHistoricalParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Aggregate trade ID to begin at
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from_id: Option<i32>,
    /// Default: 100; Maximum: 5000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl TradesHistoricalParams {
    /// Create a builder for [`trades_historical`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> TradesHistoricalParamsBuilder {
        TradesHistoricalParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`trades_recent`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`trades_recent`](#method.trades_recent).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TradesRecentParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Default: 100; Maximum: 5000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl TradesRecentParams {
    /// Create a builder for [`trades_recent`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> TradesRecentParamsBuilder {
        TradesRecentParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`ui_klines`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ui_klines`](#method.ui_klines).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct UiKlinesParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `interval` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub interval: UiKlinesIntervalEnum,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default: 0 (UTC)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_zone: Option<String>,
    /// Default: 100; Maximum: 5000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl UiKlinesParams {
    /// Create a builder for [`ui_klines`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `interval` — String
    ///
    #[must_use]
    pub fn builder(symbol: String, interval: UiKlinesIntervalEnum) -> UiKlinesParamsBuilder {
        UiKlinesParamsBuilder::default()
            .symbol(symbol)
            .interval(interval)
    }
}

#[async_trait]
impl MarketApi for MarketApiClient {
    async fn avg_price(
        &self,
        params: AvgPriceParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::AvgPriceResponseResult>>> {
        let AvgPriceParams { symbol, id } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();

        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Box<models::AvgPriceResponseResult>>(
                "/avgPrice".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: false,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn depth(
        &self,
        params: DepthParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::DepthResponseResult>>> {
        let DepthParams { symbol, id, limit } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();

        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = limit {
            payload.insert("limit".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Box<models::DepthResponseResult>>(
                "/depth".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: false,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn klines(
        &self,
        params: KlinesParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<Vec<models::KlinesItemInner>>>> {
        let KlinesParams {
            symbol,
            interval,
            id,
            start_time,
            end_time,
            time_zone,
            limit,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();

        payload.insert("symbol".to_string(), serde_json::json!(symbol));

        payload.insert("interval".to_string(), serde_json::json!(interval));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = start_time {
            payload.insert("startTime".to_string(), serde_json::json!(value));
        }
        if let Some(value) = end_time {
            payload.insert("endTime".to_string(), serde_json::json!(value));
        }
        if let Some(value) = time_zone {
            payload.insert("timeZone".to_string(), serde_json::json!(value));
        }
        if let Some(value) = limit {
            payload.insert("limit".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Vec<Vec<models::KlinesItemInner>>>(
                "/klines".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: false,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn ticker(
        &self,
        params: TickerParams,
    ) -> anyhow::Result<WebsocketApiResponse<models::TickerResponse>> {
        let TickerParams {
            id,
            symbol,
            symbols,
            r#type,
            window_size,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = symbol {
            payload.insert("symbol".to_string(), serde_json::json!(value));
        }
        if let Some(value) = symbols {
            payload.insert("symbols".to_string(), serde_json::json!(value));
        }
        if let Some(value) = r#type {
            payload.insert("type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = window_size {
            payload.insert("windowSize".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<models::TickerResponse>(
                "/ticker".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: false,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn ticker24hr(
        &self,
        params: Ticker24hrParams,
    ) -> anyhow::Result<WebsocketApiResponse<models::Ticker24hrResponse>> {
        let Ticker24hrParams {
            id,
            symbol,
            symbols,
            r#type,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = symbol {
            payload.insert("symbol".to_string(), serde_json::json!(value));
        }
        if let Some(value) = symbols {
            payload.insert("symbols".to_string(), serde_json::json!(value));
        }
        if let Some(value) = r#type {
            payload.insert("type".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<models::Ticker24hrResponse>(
                "/ticker.24hr".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: false,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn ticker_book(
        &self,
        params: TickerBookParams,
    ) -> anyhow::Result<WebsocketApiResponse<models::TickerBookResponse>> {
        let TickerBookParams {
            id,
            symbol,
            symbols,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = symbol {
            payload.insert("symbol".to_string(), serde_json::json!(value));
        }
        if let Some(value) = symbols {
            payload.insert("symbols".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<models::TickerBookResponse>(
                "/ticker.book".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: false,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn ticker_price(
        &self,
        params: TickerPriceParams,
    ) -> anyhow::Result<WebsocketApiResponse<models::TickerPriceResponse>> {
        let TickerPriceParams {
            id,
            symbol,
            symbols,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = symbol {
            payload.insert("symbol".to_string(), serde_json::json!(value));
        }
        if let Some(value) = symbols {
            payload.insert("symbols".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<models::TickerPriceResponse>(
                "/ticker.price".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: false,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn ticker_trading_day(
        &self,
        params: TickerTradingDayParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<models::TickerTradingDayResponseResultInner>>>
    {
        let TickerTradingDayParams {
            id,
            symbol,
            symbols,
            time_zone,
            r#type,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = symbol {
            payload.insert("symbol".to_string(), serde_json::json!(value));
        }
        if let Some(value) = symbols {
            payload.insert("symbols".to_string(), serde_json::json!(value));
        }
        if let Some(value) = time_zone {
            payload.insert("timeZone".to_string(), serde_json::json!(value));
        }
        if let Some(value) = r#type {
            payload.insert("type".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Vec<models::TickerTradingDayResponseResultInner>>(
                "/ticker.tradingDay".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: false,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn trades_aggregate(
        &self,
        params: TradesAggregateParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<models::TradesAggregateResponseResultInner>>> {
        let TradesAggregateParams {
            symbol,
            id,
            from_id,
            start_time,
            end_time,
            limit,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();

        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = from_id {
            payload.insert("fromId".to_string(), serde_json::json!(value));
        }
        if let Some(value) = start_time {
            payload.insert("startTime".to_string(), serde_json::json!(value));
        }
        if let Some(value) = end_time {
            payload.insert("endTime".to_string(), serde_json::json!(value));
        }
        if let Some(value) = limit {
            payload.insert("limit".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Vec<models::TradesAggregateResponseResultInner>>(
                "/trades.aggregate".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: false,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn trades_historical(
        &self,
        params: TradesHistoricalParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<models::TradesHistoricalResponseResultInner>>>
    {
        let TradesHistoricalParams {
            symbol,
            id,
            from_id,
            limit,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();

        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = from_id {
            payload.insert("fromId".to_string(), serde_json::json!(value));
        }
        if let Some(value) = limit {
            payload.insert("limit".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Vec<models::TradesHistoricalResponseResultInner>>(
                "/trades.historical".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: false,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn trades_recent(
        &self,
        params: TradesRecentParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<models::TradesRecentResponseResultInner>>> {
        let TradesRecentParams { symbol, id, limit } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();

        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = limit {
            payload.insert("limit".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Vec<models::TradesRecentResponseResultInner>>(
                "/trades.recent".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: false,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn ui_klines(
        &self,
        params: UiKlinesParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<Vec<models::KlinesItemInner>>>> {
        let UiKlinesParams {
            symbol,
            interval,
            id,
            start_time,
            end_time,
            time_zone,
            limit,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();

        payload.insert("symbol".to_string(), serde_json::json!(symbol));

        payload.insert("interval".to_string(), serde_json::json!(interval));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = start_time {
            payload.insert("startTime".to_string(), serde_json::json!(value));
        }
        if let Some(value) = end_time {
            payload.insert("endTime".to_string(), serde_json::json!(value));
        }
        if let Some(value) = time_zone {
            payload.insert("timeZone".to_string(), serde_json::json!(value));
        }
        if let Some(value) = limit {
            payload.insert("limit".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Vec<Vec<models::KlinesItemInner>>>(
                "/uiKlines".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: false,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }
}

#[cfg(all(test, feature = "spot"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::common::websocket::{WebsocketApi, WebsocketConnection, WebsocketHandler};
    use crate::config::ConfigurationWebsocketApi;
    use crate::errors::WebsocketError;
    use crate::models::WebsocketApiRateLimit;
    use serde_json::{Value, json};
    use tokio::spawn;
    use tokio::sync::mpsc::{UnboundedReceiver, unbounded_channel};
    use tokio::time::{Duration, timeout};
    use tokio_tungstenite::tungstenite::Message;

    async fn setup() -> (
        Arc<WebsocketApi>,
        Arc<WebsocketConnection>,
        UnboundedReceiver<Message>,
    ) {
        let conn = WebsocketConnection::new("test-conn");
        let (tx, rx) = unbounded_channel::<Message>();
        {
            let mut conn_state = conn.state.lock().await;
            conn_state.ws_write_tx = Some(tx);
        }

        let config = ConfigurationWebsocketApi::builder()
            .api_key("key")
            .api_secret("secret")
            .build()
            .expect("Failed to build configuration");
        let ws_api = WebsocketApi::new(config, vec![conn.clone()]);
        conn.set_handler(ws_api.clone() as Arc<dyn WebsocketHandler>)
            .await;
        ws_api.clone().connect().await.unwrap();

        (ws_api, conn, rx)
    }

    #[test]
    fn avg_price_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = AvgPriceParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.avg_price(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/avgPrice".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"ddbfb65f-9ebf-42ec-8240-8f0f91de0867","status":200,"result":{"mins":5,"price":"9.35751834","closeTime":1694061154503},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":2}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Box<models::AvgPriceResponseResult> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn avg_price_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = AvgPriceParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.avg_price(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn avg_price_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = AvgPriceParams::builder("BNBUSDT".to_string())
                    .build()
                    .unwrap();
                client.avg_price(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let Message::Text(text) = sent else {
                panic!("expected Message Text")
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn depth_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = DepthParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.depth(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/depth".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"51e2affb-0aba-4821-ba75-f2625006eb43","status":200,"result":{"lastUpdateId":2731179239,"bids":[["0.01379900","3.43200000"],["0.01379800","3.24300000"],["0.01379700","10.45500000"],["0.01379600","3.82100000"],["0.01379500","10.26200000"]],"asks":[["0.01380000","5.91700000"],["0.01380100","6.01400000"],["0.01380200","0.26800000"],["0.01380300","0.33800000"],["0.01380400","0.26800000"]]},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":2}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Box<models::DepthResponseResult> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn depth_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = DepthParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.depth(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn depth_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = DepthParams::builder("BNBUSDT".to_string()).build().unwrap();
                client.depth(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let Message::Text(text) = sent else {
                panic!("expected Message Text")
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn klines_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = KlinesParams::builder("BNBUSDT".to_string(),KlinesIntervalEnum::Interval1s,).build().unwrap();
                client.klines(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/klines".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"1dbbeb56-8eea-466a-8f6e-86bdcfa2fc0b","status":200,"result":[[1655971200000,"0.01086000","0.01086600","0.01083600","0.01083800","2290.53800000",1655974799999,"24.85074442",2283,"1171.64000000","12.71225884","0"]],"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":2}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Vec<Vec<models::KlinesItemInner>> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn klines_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = KlinesParams::builder("BNBUSDT".to_string(),KlinesIntervalEnum::Interval1s,).build().unwrap();
                client.klines(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn klines_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params =
                    KlinesParams::builder("BNBUSDT".to_string(), KlinesIntervalEnum::Interval1s)
                        .build()
                        .unwrap();
                client.klines(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let Message::Text(text) = sent else {
                panic!("expected Message Text")
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn ticker_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TickerParams::builder().build().unwrap();
                client.ticker(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/ticker".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"bdb7c503-542c-495c-b797-4d2ee2e91173","status":200,"result":{"symbol":"BNBBTC","priceChange":"0.00061500","priceChangePercent":"4.735","weightedAvgPrice":"0.01368242","openPrice":"0.01298900","highPrice":"0.01418800","lowPrice":"0.01296000","lastPrice":"0.01360400","volume":"587179.23900000","quoteVolume":"8034.03382165","openTime":1659580020000,"closeTime":1660184865291,"firstId":192977765,"lastId":195365758,"count":2387994},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":4}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: models::TickerResponse = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn ticker_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = TickerParams::builder().build().unwrap();
                client.ticker(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn ticker_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TickerParams::builder().build().unwrap();
                client.ticker(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let Message::Text(text) = sent else {
                panic!("expected Message Text")
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn ticker24hr_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = Ticker24hrParams::builder().build().unwrap();
                client.ticker24hr(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/ticker.24hr".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"9fa2a91b-3fca-4ed7-a9ad-58e3b67483de","status":200,"result":{"symbol":"BNBBTC","priceChange":"0.00013900","priceChangePercent":"1.020","weightedAvgPrice":"0.01382453","prevClosePrice":"0.01362800","lastPrice":"0.01376700","lastQty":"1.78800000","bidPrice":"0.01376700","bidQty":"4.64600000","askPrice":"0.01376800","askQty":"14.31400000","openPrice":"0.01362800","highPrice":"0.01414900","lowPrice":"0.01346600","volume":"69412.40500000","quoteVolume":"959.59411487","openTime":1660014164909,"closeTime":1660100564909,"firstId":194696115,"lastId":194968287,"count":272173},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":2}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: models::Ticker24hrResponse = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn ticker24hr_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = Ticker24hrParams::builder().build().unwrap();
                client.ticker24hr(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn ticker24hr_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = Ticker24hrParams::builder().build().unwrap();
                client.ticker24hr(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let Message::Text(text) = sent else {
                panic!("expected Message Text")
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn ticker_book_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TickerBookParams::builder().build().unwrap();
                client.ticker_book(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/ticker.book".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"9d32157c-a556-4d27-9866-66760a174b57","status":200,"result":{"symbol":"BNBBTC","bidPrice":"0.01358000","bidQty":"12.53400000","askPrice":"0.01358100","askQty":"17.83700000"},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":2}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: models::TickerBookResponse = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn ticker_book_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = TickerBookParams::builder().build().unwrap();
                client.ticker_book(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn ticker_book_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TickerBookParams::builder().build().unwrap();
                client.ticker_book(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let Message::Text(text) = sent else {
                panic!("expected Message Text")
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn ticker_price_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TickerPriceParams::builder().build().unwrap();
                client.ticker_price(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/ticker.price".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"043a7cf2-bde3-4888-9604-c8ac41fcba4d","status":200,"result":{"symbol":"BNBBTC","price":"0.01361900"},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":2}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: models::TickerPriceResponse = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn ticker_price_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = TickerPriceParams::builder().build().unwrap();
                client.ticker_price(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn ticker_price_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TickerPriceParams::builder().build().unwrap();
                client.ticker_price(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let Message::Text(text) = sent else {
                panic!("expected Message Text")
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn ticker_trading_day_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TickerTradingDayParams::builder().build().unwrap();
                client.ticker_trading_day(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/ticker.tradingDay".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"f4b3b507-c8f2-442a-81a6-b2f12daa030f","status":200,"result":[{"symbol":"BNBUSDT","priceChange":"2.60000000","priceChangePercent":"1.238","weightedAvgPrice":"211.92276958","openPrice":"210.00000000","highPrice":"213.70000000","lowPrice":"209.70000000","lastPrice":"212.60000000","volume":"280709.58900000","quoteVolume":"59488753.54750000","openTime":1695686400000,"closeTime":1695772799999,"firstId":672397461,"lastId":672496158,"count":98698},{"symbol":"BTCUSDT","priceChange":"-83.13000000","priceChangePercent":"-0.317","weightedAvgPrice":"26234.58803036","openPrice":"26304.80000000","highPrice":"26397.46000000","lowPrice":"26088.34000000","lastPrice":"26221.67000000","volume":"18495.35066000","quoteVolume":"485217905.04210480","openTime":1695686400000,"closeTime":1695772799999,"firstId":3220151555,"lastId":3220849281,"count":697727}],"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":8}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Vec<models::TickerTradingDayResponseResultInner> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn ticker_trading_day_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = TickerTradingDayParams::builder().build().unwrap();
                client.ticker_trading_day(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn ticker_trading_day_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TickerTradingDayParams::builder().build().unwrap();
                client.ticker_trading_day(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let Message::Text(text) = sent else {
                panic!("expected Message Text")
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn trades_aggregate_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TradesAggregateParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.trades_aggregate(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/trades.aggregate".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"189da436-d4bd-48ca-9f95-9f613d621717","status":200,"result":[{"a":50000000,"p":"0.00274100","q":"57.19000000","f":59120167,"l":59120170,"T":1565877971222,"m":true,"M":true}],"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":2}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Vec<models::TradesAggregateResponseResultInner> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn trades_aggregate_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = TradesAggregateParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.trades_aggregate(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn trades_aggregate_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TradesAggregateParams::builder("BNBUSDT".to_string())
                    .build()
                    .unwrap();
                client.trades_aggregate(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let Message::Text(text) = sent else {
                panic!("expected Message Text")
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn trades_historical_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TradesHistoricalParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.trades_historical(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/trades.historical".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"cffc9c7d-4efc-4ce0-b587-6b87448f052a","status":200,"result":[{"id":0,"price":"0.00005000","qty":"40.00000000","quoteQty":"0.00200000","time":1500004800376,"isBuyerMaker":true,"isBestMatch":true}],"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":10}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Vec<models::TradesHistoricalResponseResultInner> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn trades_historical_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = TradesHistoricalParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.trades_historical(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn trades_historical_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TradesHistoricalParams::builder("BNBUSDT".to_string())
                    .build()
                    .unwrap();
                client.trades_historical(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let Message::Text(text) = sent else {
                panic!("expected Message Text")
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn trades_recent_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TradesRecentParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.trades_recent(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/trades.recent".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"409a20bd-253d-41db-a6dd-687862a5882f","status":200,"result":[{"id":194686783,"price":"0.01361000","qty":"0.01400000","quoteQty":"0.00019054","time":1660009530807,"isBuyerMaker":true,"isBestMatch":true}],"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":2}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Vec<models::TradesRecentResponseResultInner> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn trades_recent_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = TradesRecentParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.trades_recent(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn trades_recent_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = TradesRecentParams::builder("BNBUSDT".to_string())
                    .build()
                    .unwrap();
                client.trades_recent(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let Message::Text(text) = sent else {
                panic!("expected Message Text")
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn ui_klines_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = UiKlinesParams::builder("BNBUSDT".to_string(),UiKlinesIntervalEnum::Interval1s,).build().unwrap();
                client.ui_klines(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/uiKlines".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"b137468a-fb20-4c06-bd6b-625148eec958","status":200,"result":[[1655971200000,"0.01086000","0.01086600","0.01083600","0.01083800","2290.53800000",1655974799999,"24.85074442",2283,"1171.64000000","12.71225884","0"]],"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":2}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Vec<Vec<models::KlinesItemInner>> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn ui_klines_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = UiKlinesParams::builder("BNBUSDT".to_string(),UiKlinesIntervalEnum::Interval1s,).build().unwrap();
                client.ui_klines(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let Message::Text(text) = sent else { panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn ui_klines_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = MarketApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = UiKlinesParams::builder(
                    "BNBUSDT".to_string(),
                    UiKlinesIntervalEnum::Interval1s,
                )
                .build()
                .unwrap();
                client.ui_klines(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let Message::Text(text) = sent else {
                panic!("expected Message Text")
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }
}
