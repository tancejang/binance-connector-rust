/*
 * Binance Spot WebSocket API
 *
 * OpenAPI Specifications for the Binance Spot WebSocket API
 *
 * API documents:
 * - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)
 * - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use anyhow::Context;
use async_trait::async_trait;
use derive_builder::Builder;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::{collections::BTreeMap, sync::Arc};

use crate::common::{
    models::{ParamBuildError, WebsocketApiResponse},
    utils::remove_empty_value,
    websocket::{WebsocketApi, WebsocketMessageSendOptions},
};
use crate::spot::websocket_api::models;

#[async_trait]
pub trait TradeApi: Send + Sync {
    async fn open_orders_cancel_all(
        &self,
        params: OpenOrdersCancelAllParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<models::OpenOrdersCancelAllResponseResultInner>>>;
    async fn order_amend_keep_priority(
        &self,
        params: OrderAmendKeepPriorityParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderAmendKeepPriorityResponseResult>>>;
    async fn order_cancel(
        &self,
        params: OrderCancelParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderCancelResponseResult>>>;
    async fn order_cancel_replace(
        &self,
        params: OrderCancelReplaceParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderCancelReplaceResponseResult>>>;
    async fn order_list_cancel(
        &self,
        params: OrderListCancelParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderListCancelResponseResult>>>;
    async fn order_list_place(
        &self,
        params: OrderListPlaceParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderListPlaceResponseResult>>>;
    async fn order_list_place_oco(
        &self,
        params: OrderListPlaceOcoParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderListPlaceOcoResponseResult>>>;
    async fn order_list_place_oto(
        &self,
        params: OrderListPlaceOtoParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderListPlaceOtoResponseResult>>>;
    async fn order_list_place_otoco(
        &self,
        params: OrderListPlaceOtocoParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderListPlaceOtocoResponseResult>>>;
    async fn order_place(
        &self,
        params: OrderPlaceParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderPlaceResponseResult>>>;
    async fn order_test(
        &self,
        params: OrderTestParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderTestResponseResult>>>;
    async fn sor_order_place(
        &self,
        params: SorOrderPlaceParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<models::SorOrderPlaceResponseResultInner>>>;
    async fn sor_order_test(
        &self,
        params: SorOrderTestParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderTestResponseResult>>>;
}

pub struct TradeApiClient {
    websocket_api_base: Arc<WebsocketApi>,
}

impl TradeApiClient {
    pub fn new(websocket_api_base: Arc<WebsocketApi>) -> Self {
        Self { websocket_api_base }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelCancelRestrictionsEnum {
    #[serde(rename = "ONLY_NEW")]
    ONLY_NEW,
    #[serde(rename = "NEW")]
    NEW,
    #[serde(rename = "ONLY_PARTIALLY_FILLED")]
    ONLY_PARTIALLY_FILLED,
    #[serde(rename = "PARTIALLY_FILLED")]
    PARTIALLY_FILLED,
}

impl OrderCancelCancelRestrictionsEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelCancelRestrictionsEnum::ONLY_NEW => "ONLY_NEW",
            OrderCancelCancelRestrictionsEnum::NEW => "NEW",
            OrderCancelCancelRestrictionsEnum::ONLY_PARTIALLY_FILLED => "ONLY_PARTIALLY_FILLED",
            OrderCancelCancelRestrictionsEnum::PARTIALLY_FILLED => "PARTIALLY_FILLED",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceCancelReplaceModeEnum {
    #[serde(rename = "STOP_ON_FAILURE")]
    STOP_ON_FAILURE,
    #[serde(rename = "ALLOW_FAILURE")]
    ALLOW_FAILURE,
}

impl OrderCancelReplaceCancelReplaceModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceCancelReplaceModeEnum::STOP_ON_FAILURE => "STOP_ON_FAILURE",
            OrderCancelReplaceCancelReplaceModeEnum::ALLOW_FAILURE => "ALLOW_FAILURE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceSideEnum {
    #[serde(rename = "BUY")]
    BUY,
    #[serde(rename = "SELL")]
    SELL,
}

impl OrderCancelReplaceSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceSideEnum::BUY => "BUY",
            OrderCancelReplaceSideEnum::SELL => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceTypeEnum {
    #[serde(rename = "MARKET")]
    MARKET,
    #[serde(rename = "LIMIT")]
    LIMIT,
    #[serde(rename = "STOP_LOSS")]
    STOP_LOSS,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    STOP_LOSS_LIMIT,
    #[serde(rename = "TAKE_PROFIT")]
    TAKE_PROFIT,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TAKE_PROFIT_LIMIT,
    #[serde(rename = "LIMIT_MAKER")]
    LIMIT_MAKER,
    #[serde(rename = "NON_REPRESENTABLE")]
    NON_REPRESENTABLE,
}

impl OrderCancelReplaceTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceTypeEnum::MARKET => "MARKET",
            OrderCancelReplaceTypeEnum::LIMIT => "LIMIT",
            OrderCancelReplaceTypeEnum::STOP_LOSS => "STOP_LOSS",
            OrderCancelReplaceTypeEnum::STOP_LOSS_LIMIT => "STOP_LOSS_LIMIT",
            OrderCancelReplaceTypeEnum::TAKE_PROFIT => "TAKE_PROFIT",
            OrderCancelReplaceTypeEnum::TAKE_PROFIT_LIMIT => "TAKE_PROFIT_LIMIT",
            OrderCancelReplaceTypeEnum::LIMIT_MAKER => "LIMIT_MAKER",
            OrderCancelReplaceTypeEnum::NON_REPRESENTABLE => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceTimeInForceEnum {
    #[serde(rename = "GTC")]
    GTC,
    #[serde(rename = "IOC")]
    IOC,
    #[serde(rename = "FOK")]
    FOK,
    #[serde(rename = "NON_REPRESENTABLE")]
    NON_REPRESENTABLE,
}

impl OrderCancelReplaceTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceTimeInForceEnum::GTC => "GTC",
            OrderCancelReplaceTimeInForceEnum::IOC => "IOC",
            OrderCancelReplaceTimeInForceEnum::FOK => "FOK",
            OrderCancelReplaceTimeInForceEnum::NON_REPRESENTABLE => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    ACK,
    #[serde(rename = "RESULT")]
    RESULT,
    #[serde(rename = "FULL")]
    FULL,
    #[serde(rename = "MARKET")]
    MARKET,
    #[serde(rename = "LIMIT")]
    LIMIT,
}

impl OrderCancelReplaceNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceNewOrderRespTypeEnum::ACK => "ACK",
            OrderCancelReplaceNewOrderRespTypeEnum::RESULT => "RESULT",
            OrderCancelReplaceNewOrderRespTypeEnum::FULL => "FULL",
            OrderCancelReplaceNewOrderRespTypeEnum::MARKET => "MARKET",
            OrderCancelReplaceNewOrderRespTypeEnum::LIMIT => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    NONE,
    #[serde(rename = "EXPIRE_TAKER")]
    EXPIRE_TAKER,
    #[serde(rename = "EXPIRE_MAKER")]
    EXPIRE_MAKER,
    #[serde(rename = "EXPIRE_BOTH")]
    EXPIRE_BOTH,
    #[serde(rename = "DECREMENT")]
    DECREMENT,
    #[serde(rename = "NON_REPRESENTABLE")]
    NON_REPRESENTABLE,
}

impl OrderCancelReplaceSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceSelfTradePreventionModeEnum::NONE => "NONE",
            OrderCancelReplaceSelfTradePreventionModeEnum::EXPIRE_TAKER => "EXPIRE_TAKER",
            OrderCancelReplaceSelfTradePreventionModeEnum::EXPIRE_MAKER => "EXPIRE_MAKER",
            OrderCancelReplaceSelfTradePreventionModeEnum::EXPIRE_BOTH => "EXPIRE_BOTH",
            OrderCancelReplaceSelfTradePreventionModeEnum::DECREMENT => "DECREMENT",
            OrderCancelReplaceSelfTradePreventionModeEnum::NON_REPRESENTABLE => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceCancelRestrictionsEnum {
    #[serde(rename = "ONLY_NEW")]
    ONLY_NEW,
    #[serde(rename = "NEW")]
    NEW,
    #[serde(rename = "ONLY_PARTIALLY_FILLED")]
    ONLY_PARTIALLY_FILLED,
    #[serde(rename = "PARTIALLY_FILLED")]
    PARTIALLY_FILLED,
}

impl OrderCancelReplaceCancelRestrictionsEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceCancelRestrictionsEnum::ONLY_NEW => "ONLY_NEW",
            OrderCancelReplaceCancelRestrictionsEnum::NEW => "NEW",
            OrderCancelReplaceCancelRestrictionsEnum::ONLY_PARTIALLY_FILLED => {
                "ONLY_PARTIALLY_FILLED"
            }
            OrderCancelReplaceCancelRestrictionsEnum::PARTIALLY_FILLED => "PARTIALLY_FILLED",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderCancelReplaceOrderRateLimitExceededModeEnum {
    #[serde(rename = "DO_NOTHING")]
    DO_NOTHING,
    #[serde(rename = "CANCEL_ONLY")]
    CANCEL_ONLY,
}

impl OrderCancelReplaceOrderRateLimitExceededModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderCancelReplaceOrderRateLimitExceededModeEnum::DO_NOTHING => "DO_NOTHING",
            OrderCancelReplaceOrderRateLimitExceededModeEnum::CANCEL_ONLY => "CANCEL_ONLY",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceSideEnum {
    #[serde(rename = "BUY")]
    BUY,
    #[serde(rename = "SELL")]
    SELL,
}

impl OrderListPlaceSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceSideEnum::BUY => "BUY",
            OrderListPlaceSideEnum::SELL => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceStopLimitTimeInForceEnum {
    #[serde(rename = "GTC")]
    GTC,
    #[serde(rename = "FOK")]
    FOK,
    #[serde(rename = "IOC")]
    IOC,
}

impl OrderListPlaceStopLimitTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceStopLimitTimeInForceEnum::GTC => "GTC",
            OrderListPlaceStopLimitTimeInForceEnum::FOK => "FOK",
            OrderListPlaceStopLimitTimeInForceEnum::IOC => "IOC",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    ACK,
    #[serde(rename = "RESULT")]
    RESULT,
    #[serde(rename = "FULL")]
    FULL,
    #[serde(rename = "MARKET")]
    MARKET,
    #[serde(rename = "LIMIT")]
    LIMIT,
}

impl OrderListPlaceNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceNewOrderRespTypeEnum::ACK => "ACK",
            OrderListPlaceNewOrderRespTypeEnum::RESULT => "RESULT",
            OrderListPlaceNewOrderRespTypeEnum::FULL => "FULL",
            OrderListPlaceNewOrderRespTypeEnum::MARKET => "MARKET",
            OrderListPlaceNewOrderRespTypeEnum::LIMIT => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    NONE,
    #[serde(rename = "EXPIRE_TAKER")]
    EXPIRE_TAKER,
    #[serde(rename = "EXPIRE_MAKER")]
    EXPIRE_MAKER,
    #[serde(rename = "EXPIRE_BOTH")]
    EXPIRE_BOTH,
    #[serde(rename = "DECREMENT")]
    DECREMENT,
    #[serde(rename = "NON_REPRESENTABLE")]
    NON_REPRESENTABLE,
}

impl OrderListPlaceSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceSelfTradePreventionModeEnum::NONE => "NONE",
            OrderListPlaceSelfTradePreventionModeEnum::EXPIRE_TAKER => "EXPIRE_TAKER",
            OrderListPlaceSelfTradePreventionModeEnum::EXPIRE_MAKER => "EXPIRE_MAKER",
            OrderListPlaceSelfTradePreventionModeEnum::EXPIRE_BOTH => "EXPIRE_BOTH",
            OrderListPlaceSelfTradePreventionModeEnum::DECREMENT => "DECREMENT",
            OrderListPlaceSelfTradePreventionModeEnum::NON_REPRESENTABLE => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOcoSideEnum {
    #[serde(rename = "BUY")]
    BUY,
    #[serde(rename = "SELL")]
    SELL,
}

impl OrderListPlaceOcoSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOcoSideEnum::BUY => "BUY",
            OrderListPlaceOcoSideEnum::SELL => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOcoAboveTypeEnum {
    #[serde(rename = "STOP_LOSS_LIMIT")]
    STOP_LOSS_LIMIT,
    #[serde(rename = "STOP_LOSS")]
    STOP_LOSS,
    #[serde(rename = "LIMIT_MAKER")]
    LIMIT_MAKER,
    #[serde(rename = "TAKE_PROFIT")]
    TAKE_PROFIT,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TAKE_PROFIT_LIMIT,
}

impl OrderListPlaceOcoAboveTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOcoAboveTypeEnum::STOP_LOSS_LIMIT => "STOP_LOSS_LIMIT",
            OrderListPlaceOcoAboveTypeEnum::STOP_LOSS => "STOP_LOSS",
            OrderListPlaceOcoAboveTypeEnum::LIMIT_MAKER => "LIMIT_MAKER",
            OrderListPlaceOcoAboveTypeEnum::TAKE_PROFIT => "TAKE_PROFIT",
            OrderListPlaceOcoAboveTypeEnum::TAKE_PROFIT_LIMIT => "TAKE_PROFIT_LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOcoBelowTypeEnum {
    #[serde(rename = "STOP_LOSS")]
    STOP_LOSS,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    STOP_LOSS_LIMIT,
    #[serde(rename = "TAKE_PROFIT")]
    TAKE_PROFIT,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TAKE_PROFIT_LIMIT,
}

impl OrderListPlaceOcoBelowTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOcoBelowTypeEnum::STOP_LOSS => "STOP_LOSS",
            OrderListPlaceOcoBelowTypeEnum::STOP_LOSS_LIMIT => "STOP_LOSS_LIMIT",
            OrderListPlaceOcoBelowTypeEnum::TAKE_PROFIT => "TAKE_PROFIT",
            OrderListPlaceOcoBelowTypeEnum::TAKE_PROFIT_LIMIT => "TAKE_PROFIT_LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOcoBelowTimeInForceEnum {
    #[serde(rename = "belowType")]
    belowType,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    STOP_LOSS_LIMIT,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TAKE_PROFIT_LIMIT,
}

impl OrderListPlaceOcoBelowTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOcoBelowTimeInForceEnum::belowType => "belowType",
            OrderListPlaceOcoBelowTimeInForceEnum::STOP_LOSS_LIMIT => "STOP_LOSS_LIMIT",
            OrderListPlaceOcoBelowTimeInForceEnum::TAKE_PROFIT_LIMIT => "TAKE_PROFIT_LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOcoNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    ACK,
    #[serde(rename = "RESULT")]
    RESULT,
    #[serde(rename = "FULL")]
    FULL,
    #[serde(rename = "MARKET")]
    MARKET,
    #[serde(rename = "LIMIT")]
    LIMIT,
}

impl OrderListPlaceOcoNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOcoNewOrderRespTypeEnum::ACK => "ACK",
            OrderListPlaceOcoNewOrderRespTypeEnum::RESULT => "RESULT",
            OrderListPlaceOcoNewOrderRespTypeEnum::FULL => "FULL",
            OrderListPlaceOcoNewOrderRespTypeEnum::MARKET => "MARKET",
            OrderListPlaceOcoNewOrderRespTypeEnum::LIMIT => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOcoSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    NONE,
    #[serde(rename = "EXPIRE_TAKER")]
    EXPIRE_TAKER,
    #[serde(rename = "EXPIRE_MAKER")]
    EXPIRE_MAKER,
    #[serde(rename = "EXPIRE_BOTH")]
    EXPIRE_BOTH,
    #[serde(rename = "DECREMENT")]
    DECREMENT,
    #[serde(rename = "NON_REPRESENTABLE")]
    NON_REPRESENTABLE,
}

impl OrderListPlaceOcoSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOcoSelfTradePreventionModeEnum::NONE => "NONE",
            OrderListPlaceOcoSelfTradePreventionModeEnum::EXPIRE_TAKER => "EXPIRE_TAKER",
            OrderListPlaceOcoSelfTradePreventionModeEnum::EXPIRE_MAKER => "EXPIRE_MAKER",
            OrderListPlaceOcoSelfTradePreventionModeEnum::EXPIRE_BOTH => "EXPIRE_BOTH",
            OrderListPlaceOcoSelfTradePreventionModeEnum::DECREMENT => "DECREMENT",
            OrderListPlaceOcoSelfTradePreventionModeEnum::NON_REPRESENTABLE => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtoWorkingTypeEnum {
    #[serde(rename = "LIMIT")]
    LIMIT,
    #[serde(rename = "LIMIT_MAKER")]
    LIMIT_MAKER,
}

impl OrderListPlaceOtoWorkingTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtoWorkingTypeEnum::LIMIT => "LIMIT",
            OrderListPlaceOtoWorkingTypeEnum::LIMIT_MAKER => "LIMIT_MAKER",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtoWorkingSideEnum {
    #[serde(rename = "BUY")]
    BUY,
    #[serde(rename = "SELL")]
    SELL,
}

impl OrderListPlaceOtoWorkingSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtoWorkingSideEnum::BUY => "BUY",
            OrderListPlaceOtoWorkingSideEnum::SELL => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtoPendingTypeEnum {
    #[serde(rename = "LIMIT")]
    LIMIT,
    #[serde(rename = "MARKET")]
    MARKET,
    #[serde(rename = "STOP_LOSS")]
    STOP_LOSS,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    STOP_LOSS_LIMIT,
    #[serde(rename = "TAKE_PROFIT")]
    TAKE_PROFIT,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TAKE_PROFIT_LIMIT,
    #[serde(rename = "LIMIT_MAKER")]
    LIMIT_MAKER,
}

impl OrderListPlaceOtoPendingTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtoPendingTypeEnum::LIMIT => "LIMIT",
            OrderListPlaceOtoPendingTypeEnum::MARKET => "MARKET",
            OrderListPlaceOtoPendingTypeEnum::STOP_LOSS => "STOP_LOSS",
            OrderListPlaceOtoPendingTypeEnum::STOP_LOSS_LIMIT => "STOP_LOSS_LIMIT",
            OrderListPlaceOtoPendingTypeEnum::TAKE_PROFIT => "TAKE_PROFIT",
            OrderListPlaceOtoPendingTypeEnum::TAKE_PROFIT_LIMIT => "TAKE_PROFIT_LIMIT",
            OrderListPlaceOtoPendingTypeEnum::LIMIT_MAKER => "LIMIT_MAKER",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtoPendingSideEnum {
    #[serde(rename = "BUY")]
    BUY,
    #[serde(rename = "SELL")]
    SELL,
}

impl OrderListPlaceOtoPendingSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtoPendingSideEnum::BUY => "BUY",
            OrderListPlaceOtoPendingSideEnum::SELL => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtoNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    ACK,
    #[serde(rename = "RESULT")]
    RESULT,
    #[serde(rename = "FULL")]
    FULL,
    #[serde(rename = "MARKET")]
    MARKET,
    #[serde(rename = "LIMIT")]
    LIMIT,
}

impl OrderListPlaceOtoNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtoNewOrderRespTypeEnum::ACK => "ACK",
            OrderListPlaceOtoNewOrderRespTypeEnum::RESULT => "RESULT",
            OrderListPlaceOtoNewOrderRespTypeEnum::FULL => "FULL",
            OrderListPlaceOtoNewOrderRespTypeEnum::MARKET => "MARKET",
            OrderListPlaceOtoNewOrderRespTypeEnum::LIMIT => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtoSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    NONE,
    #[serde(rename = "EXPIRE_TAKER")]
    EXPIRE_TAKER,
    #[serde(rename = "EXPIRE_MAKER")]
    EXPIRE_MAKER,
    #[serde(rename = "EXPIRE_BOTH")]
    EXPIRE_BOTH,
    #[serde(rename = "DECREMENT")]
    DECREMENT,
    #[serde(rename = "NON_REPRESENTABLE")]
    NON_REPRESENTABLE,
}

impl OrderListPlaceOtoSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtoSelfTradePreventionModeEnum::NONE => "NONE",
            OrderListPlaceOtoSelfTradePreventionModeEnum::EXPIRE_TAKER => "EXPIRE_TAKER",
            OrderListPlaceOtoSelfTradePreventionModeEnum::EXPIRE_MAKER => "EXPIRE_MAKER",
            OrderListPlaceOtoSelfTradePreventionModeEnum::EXPIRE_BOTH => "EXPIRE_BOTH",
            OrderListPlaceOtoSelfTradePreventionModeEnum::DECREMENT => "DECREMENT",
            OrderListPlaceOtoSelfTradePreventionModeEnum::NON_REPRESENTABLE => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtoWorkingTimeInForceEnum {
    #[serde(rename = "GTC")]
    GTC,
    #[serde(rename = "IOC")]
    IOC,
    #[serde(rename = "FOK")]
    FOK,
}

impl OrderListPlaceOtoWorkingTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtoWorkingTimeInForceEnum::GTC => "GTC",
            OrderListPlaceOtoWorkingTimeInForceEnum::IOC => "IOC",
            OrderListPlaceOtoWorkingTimeInForceEnum::FOK => "FOK",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtoPendingTimeInForceEnum {
    #[serde(rename = "GTC")]
    GTC,
    #[serde(rename = "IOC")]
    IOC,
    #[serde(rename = "FOK")]
    FOK,
}

impl OrderListPlaceOtoPendingTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtoPendingTimeInForceEnum::GTC => "GTC",
            OrderListPlaceOtoPendingTimeInForceEnum::IOC => "IOC",
            OrderListPlaceOtoPendingTimeInForceEnum::FOK => "FOK",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtocoWorkingTypeEnum {
    #[serde(rename = "LIMIT")]
    LIMIT,
    #[serde(rename = "LIMIT_MAKER")]
    LIMIT_MAKER,
}

impl OrderListPlaceOtocoWorkingTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtocoWorkingTypeEnum::LIMIT => "LIMIT",
            OrderListPlaceOtocoWorkingTypeEnum::LIMIT_MAKER => "LIMIT_MAKER",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtocoWorkingSideEnum {
    #[serde(rename = "BUY")]
    BUY,
    #[serde(rename = "SELL")]
    SELL,
}

impl OrderListPlaceOtocoWorkingSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtocoWorkingSideEnum::BUY => "BUY",
            OrderListPlaceOtocoWorkingSideEnum::SELL => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtocoPendingSideEnum {
    #[serde(rename = "BUY")]
    BUY,
    #[serde(rename = "SELL")]
    SELL,
}

impl OrderListPlaceOtocoPendingSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtocoPendingSideEnum::BUY => "BUY",
            OrderListPlaceOtocoPendingSideEnum::SELL => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtocoPendingAboveTypeEnum {
    #[serde(rename = "STOP_LOSS_LIMIT")]
    STOP_LOSS_LIMIT,
    #[serde(rename = "STOP_LOSS")]
    STOP_LOSS,
    #[serde(rename = "LIMIT_MAKER")]
    LIMIT_MAKER,
    #[serde(rename = "TAKE_PROFIT")]
    TAKE_PROFIT,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TAKE_PROFIT_LIMIT,
}

impl OrderListPlaceOtocoPendingAboveTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtocoPendingAboveTypeEnum::STOP_LOSS_LIMIT => "STOP_LOSS_LIMIT",
            OrderListPlaceOtocoPendingAboveTypeEnum::STOP_LOSS => "STOP_LOSS",
            OrderListPlaceOtocoPendingAboveTypeEnum::LIMIT_MAKER => "LIMIT_MAKER",
            OrderListPlaceOtocoPendingAboveTypeEnum::TAKE_PROFIT => "TAKE_PROFIT",
            OrderListPlaceOtocoPendingAboveTypeEnum::TAKE_PROFIT_LIMIT => "TAKE_PROFIT_LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtocoNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    ACK,
    #[serde(rename = "RESULT")]
    RESULT,
    #[serde(rename = "FULL")]
    FULL,
    #[serde(rename = "MARKET")]
    MARKET,
    #[serde(rename = "LIMIT")]
    LIMIT,
}

impl OrderListPlaceOtocoNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtocoNewOrderRespTypeEnum::ACK => "ACK",
            OrderListPlaceOtocoNewOrderRespTypeEnum::RESULT => "RESULT",
            OrderListPlaceOtocoNewOrderRespTypeEnum::FULL => "FULL",
            OrderListPlaceOtocoNewOrderRespTypeEnum::MARKET => "MARKET",
            OrderListPlaceOtocoNewOrderRespTypeEnum::LIMIT => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtocoSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    NONE,
    #[serde(rename = "EXPIRE_TAKER")]
    EXPIRE_TAKER,
    #[serde(rename = "EXPIRE_MAKER")]
    EXPIRE_MAKER,
    #[serde(rename = "EXPIRE_BOTH")]
    EXPIRE_BOTH,
    #[serde(rename = "DECREMENT")]
    DECREMENT,
    #[serde(rename = "NON_REPRESENTABLE")]
    NON_REPRESENTABLE,
}

impl OrderListPlaceOtocoSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtocoSelfTradePreventionModeEnum::NONE => "NONE",
            OrderListPlaceOtocoSelfTradePreventionModeEnum::EXPIRE_TAKER => "EXPIRE_TAKER",
            OrderListPlaceOtocoSelfTradePreventionModeEnum::EXPIRE_MAKER => "EXPIRE_MAKER",
            OrderListPlaceOtocoSelfTradePreventionModeEnum::EXPIRE_BOTH => "EXPIRE_BOTH",
            OrderListPlaceOtocoSelfTradePreventionModeEnum::DECREMENT => "DECREMENT",
            OrderListPlaceOtocoSelfTradePreventionModeEnum::NON_REPRESENTABLE => {
                "NON_REPRESENTABLE"
            }
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtocoWorkingTimeInForceEnum {
    #[serde(rename = "GTC")]
    GTC,
    #[serde(rename = "IOC")]
    IOC,
    #[serde(rename = "FOK")]
    FOK,
}

impl OrderListPlaceOtocoWorkingTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtocoWorkingTimeInForceEnum::GTC => "GTC",
            OrderListPlaceOtocoWorkingTimeInForceEnum::IOC => "IOC",
            OrderListPlaceOtocoWorkingTimeInForceEnum::FOK => "FOK",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtocoPendingAboveTimeInForceEnum {
    #[serde(rename = "GTC")]
    GTC,
    #[serde(rename = "IOC")]
    IOC,
    #[serde(rename = "FOK")]
    FOK,
}

impl OrderListPlaceOtocoPendingAboveTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtocoPendingAboveTimeInForceEnum::GTC => "GTC",
            OrderListPlaceOtocoPendingAboveTimeInForceEnum::IOC => "IOC",
            OrderListPlaceOtocoPendingAboveTimeInForceEnum::FOK => "FOK",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtocoPendingBelowTypeEnum {
    #[serde(rename = "STOP_LOSS")]
    STOP_LOSS,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    STOP_LOSS_LIMIT,
    #[serde(rename = "TAKE_PROFIT")]
    TAKE_PROFIT,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TAKE_PROFIT_LIMIT,
}

impl OrderListPlaceOtocoPendingBelowTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtocoPendingBelowTypeEnum::STOP_LOSS => "STOP_LOSS",
            OrderListPlaceOtocoPendingBelowTypeEnum::STOP_LOSS_LIMIT => "STOP_LOSS_LIMIT",
            OrderListPlaceOtocoPendingBelowTypeEnum::TAKE_PROFIT => "TAKE_PROFIT",
            OrderListPlaceOtocoPendingBelowTypeEnum::TAKE_PROFIT_LIMIT => "TAKE_PROFIT_LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderListPlaceOtocoPendingBelowTimeInForceEnum {
    #[serde(rename = "GTC")]
    GTC,
    #[serde(rename = "IOC")]
    IOC,
    #[serde(rename = "FOK")]
    FOK,
}

impl OrderListPlaceOtocoPendingBelowTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderListPlaceOtocoPendingBelowTimeInForceEnum::GTC => "GTC",
            OrderListPlaceOtocoPendingBelowTimeInForceEnum::IOC => "IOC",
            OrderListPlaceOtocoPendingBelowTimeInForceEnum::FOK => "FOK",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderPlaceSideEnum {
    #[serde(rename = "BUY")]
    BUY,
    #[serde(rename = "SELL")]
    SELL,
}

impl OrderPlaceSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderPlaceSideEnum::BUY => "BUY",
            OrderPlaceSideEnum::SELL => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderPlaceTypeEnum {
    #[serde(rename = "MARKET")]
    MARKET,
    #[serde(rename = "LIMIT")]
    LIMIT,
    #[serde(rename = "STOP_LOSS")]
    STOP_LOSS,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    STOP_LOSS_LIMIT,
    #[serde(rename = "TAKE_PROFIT")]
    TAKE_PROFIT,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TAKE_PROFIT_LIMIT,
    #[serde(rename = "LIMIT_MAKER")]
    LIMIT_MAKER,
    #[serde(rename = "NON_REPRESENTABLE")]
    NON_REPRESENTABLE,
}

impl OrderPlaceTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderPlaceTypeEnum::MARKET => "MARKET",
            OrderPlaceTypeEnum::LIMIT => "LIMIT",
            OrderPlaceTypeEnum::STOP_LOSS => "STOP_LOSS",
            OrderPlaceTypeEnum::STOP_LOSS_LIMIT => "STOP_LOSS_LIMIT",
            OrderPlaceTypeEnum::TAKE_PROFIT => "TAKE_PROFIT",
            OrderPlaceTypeEnum::TAKE_PROFIT_LIMIT => "TAKE_PROFIT_LIMIT",
            OrderPlaceTypeEnum::LIMIT_MAKER => "LIMIT_MAKER",
            OrderPlaceTypeEnum::NON_REPRESENTABLE => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderPlaceTimeInForceEnum {
    #[serde(rename = "GTC")]
    GTC,
    #[serde(rename = "IOC")]
    IOC,
    #[serde(rename = "FOK")]
    FOK,
    #[serde(rename = "NON_REPRESENTABLE")]
    NON_REPRESENTABLE,
}

impl OrderPlaceTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderPlaceTimeInForceEnum::GTC => "GTC",
            OrderPlaceTimeInForceEnum::IOC => "IOC",
            OrderPlaceTimeInForceEnum::FOK => "FOK",
            OrderPlaceTimeInForceEnum::NON_REPRESENTABLE => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderPlaceNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    ACK,
    #[serde(rename = "RESULT")]
    RESULT,
    #[serde(rename = "FULL")]
    FULL,
    #[serde(rename = "MARKET")]
    MARKET,
    #[serde(rename = "LIMIT")]
    LIMIT,
}

impl OrderPlaceNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderPlaceNewOrderRespTypeEnum::ACK => "ACK",
            OrderPlaceNewOrderRespTypeEnum::RESULT => "RESULT",
            OrderPlaceNewOrderRespTypeEnum::FULL => "FULL",
            OrderPlaceNewOrderRespTypeEnum::MARKET => "MARKET",
            OrderPlaceNewOrderRespTypeEnum::LIMIT => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderPlaceSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    NONE,
    #[serde(rename = "EXPIRE_TAKER")]
    EXPIRE_TAKER,
    #[serde(rename = "EXPIRE_MAKER")]
    EXPIRE_MAKER,
    #[serde(rename = "EXPIRE_BOTH")]
    EXPIRE_BOTH,
    #[serde(rename = "DECREMENT")]
    DECREMENT,
    #[serde(rename = "NON_REPRESENTABLE")]
    NON_REPRESENTABLE,
}

impl OrderPlaceSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderPlaceSelfTradePreventionModeEnum::NONE => "NONE",
            OrderPlaceSelfTradePreventionModeEnum::EXPIRE_TAKER => "EXPIRE_TAKER",
            OrderPlaceSelfTradePreventionModeEnum::EXPIRE_MAKER => "EXPIRE_MAKER",
            OrderPlaceSelfTradePreventionModeEnum::EXPIRE_BOTH => "EXPIRE_BOTH",
            OrderPlaceSelfTradePreventionModeEnum::DECREMENT => "DECREMENT",
            OrderPlaceSelfTradePreventionModeEnum::NON_REPRESENTABLE => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SorOrderPlaceSideEnum {
    #[serde(rename = "BUY")]
    BUY,
    #[serde(rename = "SELL")]
    SELL,
}

impl SorOrderPlaceSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            SorOrderPlaceSideEnum::BUY => "BUY",
            SorOrderPlaceSideEnum::SELL => "SELL",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SorOrderPlaceTypeEnum {
    #[serde(rename = "MARKET")]
    MARKET,
    #[serde(rename = "LIMIT")]
    LIMIT,
    #[serde(rename = "STOP_LOSS")]
    STOP_LOSS,
    #[serde(rename = "STOP_LOSS_LIMIT")]
    STOP_LOSS_LIMIT,
    #[serde(rename = "TAKE_PROFIT")]
    TAKE_PROFIT,
    #[serde(rename = "TAKE_PROFIT_LIMIT")]
    TAKE_PROFIT_LIMIT,
    #[serde(rename = "LIMIT_MAKER")]
    LIMIT_MAKER,
    #[serde(rename = "NON_REPRESENTABLE")]
    NON_REPRESENTABLE,
}

impl SorOrderPlaceTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            SorOrderPlaceTypeEnum::MARKET => "MARKET",
            SorOrderPlaceTypeEnum::LIMIT => "LIMIT",
            SorOrderPlaceTypeEnum::STOP_LOSS => "STOP_LOSS",
            SorOrderPlaceTypeEnum::STOP_LOSS_LIMIT => "STOP_LOSS_LIMIT",
            SorOrderPlaceTypeEnum::TAKE_PROFIT => "TAKE_PROFIT",
            SorOrderPlaceTypeEnum::TAKE_PROFIT_LIMIT => "TAKE_PROFIT_LIMIT",
            SorOrderPlaceTypeEnum::LIMIT_MAKER => "LIMIT_MAKER",
            SorOrderPlaceTypeEnum::NON_REPRESENTABLE => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SorOrderPlaceTimeInForceEnum {
    #[serde(rename = "GTC")]
    GTC,
    #[serde(rename = "IOC")]
    IOC,
    #[serde(rename = "FOK")]
    FOK,
    #[serde(rename = "NON_REPRESENTABLE")]
    NON_REPRESENTABLE,
}

impl SorOrderPlaceTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            SorOrderPlaceTimeInForceEnum::GTC => "GTC",
            SorOrderPlaceTimeInForceEnum::IOC => "IOC",
            SorOrderPlaceTimeInForceEnum::FOK => "FOK",
            SorOrderPlaceTimeInForceEnum::NON_REPRESENTABLE => "NON_REPRESENTABLE",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SorOrderPlaceNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    ACK,
    #[serde(rename = "RESULT")]
    RESULT,
    #[serde(rename = "FULL")]
    FULL,
    #[serde(rename = "MARKET")]
    MARKET,
    #[serde(rename = "LIMIT")]
    LIMIT,
}

impl SorOrderPlaceNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            SorOrderPlaceNewOrderRespTypeEnum::ACK => "ACK",
            SorOrderPlaceNewOrderRespTypeEnum::RESULT => "RESULT",
            SorOrderPlaceNewOrderRespTypeEnum::FULL => "FULL",
            SorOrderPlaceNewOrderRespTypeEnum::MARKET => "MARKET",
            SorOrderPlaceNewOrderRespTypeEnum::LIMIT => "LIMIT",
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SorOrderPlaceSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    NONE,
    #[serde(rename = "EXPIRE_TAKER")]
    EXPIRE_TAKER,
    #[serde(rename = "EXPIRE_MAKER")]
    EXPIRE_MAKER,
    #[serde(rename = "EXPIRE_BOTH")]
    EXPIRE_BOTH,
    #[serde(rename = "DECREMENT")]
    DECREMENT,
    #[serde(rename = "NON_REPRESENTABLE")]
    NON_REPRESENTABLE,
}

impl SorOrderPlaceSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            SorOrderPlaceSelfTradePreventionModeEnum::NONE => "NONE",
            SorOrderPlaceSelfTradePreventionModeEnum::EXPIRE_TAKER => "EXPIRE_TAKER",
            SorOrderPlaceSelfTradePreventionModeEnum::EXPIRE_MAKER => "EXPIRE_MAKER",
            SorOrderPlaceSelfTradePreventionModeEnum::EXPIRE_BOTH => "EXPIRE_BOTH",
            SorOrderPlaceSelfTradePreventionModeEnum::DECREMENT => "DECREMENT",
            SorOrderPlaceSelfTradePreventionModeEnum::NON_REPRESENTABLE => "NON_REPRESENTABLE",
        }
    }
}

/// Request parameters for the [`open_orders_cancel_all`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`open_orders_cancel_all`](#method.open_orders_cancel_all).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OpenOrdersCancelAllParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OpenOrdersCancelAllParams {
    /// Create a builder for [`open_orders_cancel_all`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> OpenOrdersCancelAllParamsBuilder {
        OpenOrdersCancelAllParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`order_amend_keep_priority`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_amend_keep_priority`](#method.order_amend_keep_priority).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderAmendKeepPriorityParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// `newQty` must be greater than 0 and less than the order's quantity.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub new_qty: f32,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// `orderId`or`origClientOrderId`mustbesent
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    /// `orderId`or`origClientOrderId`mustbesent
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    /// The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderAmendKeepPriorityParams {
    /// Create a builder for [`order_amend_keep_priority`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `new_qty` — `newQty` must be greater than 0 and less than the order's quantity.
    ///
    #[must_use]
    pub fn builder(symbol: String, new_qty: f32) -> OrderAmendKeepPriorityParamsBuilder {
        OrderAmendKeepPriorityParamsBuilder::default()
            .symbol(symbol)
            .new_qty(new_qty)
    }
}
/// Request parameters for the [`order_cancel`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_cancel`](#method.order_cancel).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderCancelParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Cancel order by orderId
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i32>,
    /// `orderId`or`origClientOrderId`mustbesent
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    /// The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    ///
    /// The `cancel_restrictions` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub cancel_restrictions: Option<OrderCancelCancelRestrictionsEnum>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderCancelParams {
    /// Create a builder for [`order_cancel`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> OrderCancelParamsBuilder {
        OrderCancelParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`order_cancel_replace`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_cancel_replace`](#method.order_cancel_replace).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderCancelReplaceParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `cancel_replace_mode` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub cancel_replace_mode: OrderCancelReplaceCancelReplaceModeEnum,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: OrderCancelReplaceSideEnum,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub r#type: OrderCancelReplaceTypeEnum,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Cancel order by orderId
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub cancel_order_id: Option<i32>,
    ///
    /// The `cancel_orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub cancel_orig_client_order_id: Option<String>,
    /// New ID for the canceled order. Automatically generated if not sent
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub cancel_new_client_order_id: Option<String>,
    ///
    /// The `time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_in_force: Option<OrderCancelReplaceTimeInForceEnum>,
    ///
    /// The `price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price: Option<f32>,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quantity: Option<f32>,
    ///
    /// The `quote_order_qty` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quote_order_qty: Option<f32>,
    /// The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<OrderCancelReplaceNewOrderRespTypeEnum>,
    ///
    /// The `stop_price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_price: Option<f32>,
    /// See Trailing Stop order FAQ
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub trailing_delta: Option<f32>,
    ///
    /// The `iceberg_qty` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub iceberg_qty: Option<f32>,
    /// Arbitrary numeric value identifying the order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the order strategy.
    /// Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_type: Option<i32>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<OrderCancelReplaceSelfTradePreventionModeEnum>,
    ///
    /// The `cancel_restrictions` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub cancel_restrictions: Option<OrderCancelReplaceCancelRestrictionsEnum>,
    ///
    /// The `order_rate_limit_exceeded_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_rate_limit_exceeded_mode: Option<OrderCancelReplaceOrderRateLimitExceededModeEnum>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderCancelReplaceParams {
    /// Create a builder for [`order_cancel_replace`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `cancel_replace_mode` — String
    /// * `side` — String
    /// * `r#type` — String
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        cancel_replace_mode: OrderCancelReplaceCancelReplaceModeEnum,
        side: OrderCancelReplaceSideEnum,
        r#type: OrderCancelReplaceTypeEnum,
    ) -> OrderCancelReplaceParamsBuilder {
        OrderCancelReplaceParamsBuilder::default()
            .symbol(symbol)
            .cancel_replace_mode(cancel_replace_mode)
            .side(side)
            .r#type(r#type)
    }
}
/// Request parameters for the [`order_list_cancel`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_list_cancel`](#method.order_list_cancel).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderListCancelParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Cancel order list by orderListId
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_list_id: Option<i32>,
    ///
    /// The `list_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub list_client_order_id: Option<String>,
    /// The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderListCancelParams {
    /// Create a builder for [`order_list_cancel`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> OrderListCancelParamsBuilder {
        OrderListCancelParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`order_list_place`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_list_place`](#method.order_list_place).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderListPlaceParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: OrderListPlaceSideEnum,
    /// Price for the limit order
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub price: f32,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub quantity: f32,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    ///
    /// The `list_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub list_client_order_id: Option<String>,
    /// Arbitrary unique ID among open orders for the limit order. Automatically generated if not sent
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit_client_order_id: Option<String>,
    ///
    /// The `limit_iceberg_qty` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit_iceberg_qty: Option<f32>,
    /// Arbitrary numeric value identifying the limit order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit_strategy_id: Option<i64>,
    /// <p>Arbitrary numeric value identifying the limit order strategy.</p><p>Values smaller than `1000000` are reserved and cannot be used.</p>
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit_strategy_type: Option<i32>,
    ///
    /// The `stop_price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_price: Option<f32>,
    /// See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub trailing_delta: Option<i32>,
    /// Arbitrary unique ID among open orders for the stop order. Automatically generated if not sent
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_client_order_id: Option<String>,
    ///
    /// The `stop_limit_price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_limit_price: Option<f32>,
    ///
    /// The `stop_limit_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_limit_time_in_force: Option<OrderListPlaceStopLimitTimeInForceEnum>,
    ///
    /// The `stop_iceberg_qty` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_iceberg_qty: Option<f32>,
    /// Arbitrary numeric value identifying the stop order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_strategy_id: Option<i64>,
    /// <p>Arbitrary numeric value identifying the stop order strategy.</p><p>Values smaller than `1000000` are reserved and cannot be used.</p>
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_strategy_type: Option<i32>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<OrderListPlaceNewOrderRespTypeEnum>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<OrderListPlaceSelfTradePreventionModeEnum>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderListPlaceParams {
    /// Create a builder for [`order_list_place`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `price` — Price for the limit order
    /// * `quantity` — f32
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: OrderListPlaceSideEnum,
        price: f32,
        quantity: f32,
    ) -> OrderListPlaceParamsBuilder {
        OrderListPlaceParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .price(price)
            .quantity(quantity)
    }
}
/// Request parameters for the [`order_list_place_oco`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_list_place_oco`](#method.order_list_place_oco).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderListPlaceOcoParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: OrderListPlaceOcoSideEnum,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub quantity: f32,
    ///
    /// The `above_type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub above_type: OrderListPlaceOcoAboveTypeEnum,
    ///
    /// The `below_type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub below_type: OrderListPlaceOcoBelowTypeEnum,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    ///
    /// The `list_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub list_client_order_id: Option<String>,
    /// Arbitrary unique ID among open orders for the above order. Automatically generated if not sent
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_client_order_id: Option<String>,
    /// Note that this can only be used if `aboveTimeInForce` is `GTC`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_iceberg_qty: Option<i64>,
    /// Can be used if `aboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_price: Option<f32>,
    /// Can be used if `aboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`. <br>Either `aboveStopPrice` or `aboveTrailingDelta` or both, must be specified.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_stop_price: Option<f32>,
    /// See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_trailing_delta: Option<i64>,
    /// Required if `aboveType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_time_in_force: Option<f32>,
    /// Arbitrary numeric value identifying the above order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the above order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub above_strategy_type: Option<i32>,
    ///
    /// The `below_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_client_order_id: Option<String>,
    /// Note that this can only be used if `belowTimeInForce` is `GTC`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_iceberg_qty: Option<i64>,
    /// Can be used if `belowType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_price: Option<f32>,
    /// Can be used if `belowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT` or `TAKE_PROFIT_LIMIT`. <br>Either `belowStopPrice` or `belowTrailingDelta` or both, must be specified.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_stop_price: Option<f32>,
    /// See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_trailing_delta: Option<i64>,
    ///
    /// The `below_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_time_in_force: Option<OrderListPlaceOcoBelowTimeInForceEnum>,
    /// Arbitrary numeric value identifying the below order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the below order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub below_strategy_type: Option<i32>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<OrderListPlaceOcoNewOrderRespTypeEnum>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<OrderListPlaceOcoSelfTradePreventionModeEnum>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderListPlaceOcoParams {
    /// Create a builder for [`order_list_place_oco`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `quantity` — f32
    /// * `above_type` — String
    /// * `below_type` — String
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: OrderListPlaceOcoSideEnum,
        quantity: f32,
        above_type: OrderListPlaceOcoAboveTypeEnum,
        below_type: OrderListPlaceOcoBelowTypeEnum,
    ) -> OrderListPlaceOcoParamsBuilder {
        OrderListPlaceOcoParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .quantity(quantity)
            .above_type(above_type)
            .below_type(below_type)
    }
}
/// Request parameters for the [`order_list_place_oto`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_list_place_oto`](#method.order_list_place_oto).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderListPlaceOtoParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `working_type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_type: OrderListPlaceOtoWorkingTypeEnum,
    ///
    /// The `working_side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_side: OrderListPlaceOtoWorkingSideEnum,
    ///
    /// The `working_price` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_price: f32,
    /// Sets the quantity for the working order.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_quantity: f32,
    ///
    /// The `pending_type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub pending_type: OrderListPlaceOtoPendingTypeEnum,
    ///
    /// The `pending_side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub pending_side: OrderListPlaceOtoPendingSideEnum,
    /// Sets the quantity for the pending order.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub pending_quantity: f32,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    ///
    /// The `list_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub list_client_order_id: Option<String>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<OrderListPlaceOtoNewOrderRespTypeEnum>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<OrderListPlaceOtoSelfTradePreventionModeEnum>,
    /// Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_client_order_id: Option<String>,
    /// This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_iceberg_qty: Option<f32>,
    ///
    /// The `working_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_time_in_force: Option<OrderListPlaceOtoWorkingTimeInForceEnum>,
    /// Arbitrary numeric value identifying the working order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_strategy_type: Option<i32>,
    /// Arbitrary unique ID among open orders for the pending order.<br> Automatically generated if not sent.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_client_order_id: Option<String>,
    ///
    /// The `pending_price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_price: Option<f32>,
    ///
    /// The `pending_stop_price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_stop_price: Option<f32>,
    ///
    /// The `pending_trailing_delta` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_trailing_delta: Option<f32>,
    /// This can only be used if `pendingTimeInForce` is `GTC`, or if `pendingType` is `LIMIT_MAKER`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_iceberg_qty: Option<f32>,
    ///
    /// The `pending_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_time_in_force: Option<OrderListPlaceOtoPendingTimeInForceEnum>,
    /// Arbitrary numeric value identifying the pending order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the pending order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_strategy_type: Option<i32>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderListPlaceOtoParams {
    /// Create a builder for [`order_list_place_oto`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `working_type` — String
    /// * `working_side` — String
    /// * `working_price` — f32
    /// * `working_quantity` — Sets the quantity for the working order.
    /// * `pending_type` — String
    /// * `pending_side` — String
    /// * `pending_quantity` — Sets the quantity for the pending order.
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        working_type: OrderListPlaceOtoWorkingTypeEnum,
        working_side: OrderListPlaceOtoWorkingSideEnum,
        working_price: f32,
        working_quantity: f32,
        pending_type: OrderListPlaceOtoPendingTypeEnum,
        pending_side: OrderListPlaceOtoPendingSideEnum,
        pending_quantity: f32,
    ) -> OrderListPlaceOtoParamsBuilder {
        OrderListPlaceOtoParamsBuilder::default()
            .symbol(symbol)
            .working_type(working_type)
            .working_side(working_side)
            .working_price(working_price)
            .working_quantity(working_quantity)
            .pending_type(pending_type)
            .pending_side(pending_side)
            .pending_quantity(pending_quantity)
    }
}
/// Request parameters for the [`order_list_place_otoco`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_list_place_otoco`](#method.order_list_place_otoco).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderListPlaceOtocoParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `working_type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_type: OrderListPlaceOtocoWorkingTypeEnum,
    ///
    /// The `working_side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_side: OrderListPlaceOtocoWorkingSideEnum,
    ///
    /// The `working_price` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_price: f32,
    /// Sets the quantity for the working order.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub working_quantity: f32,
    ///
    /// The `pending_side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub pending_side: OrderListPlaceOtocoPendingSideEnum,
    /// Sets the quantity for the pending order.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub pending_quantity: f32,
    ///
    /// The `pending_above_type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub pending_above_type: OrderListPlaceOtocoPendingAboveTypeEnum,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    ///
    /// The `list_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub list_client_order_id: Option<String>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<OrderListPlaceOtocoNewOrderRespTypeEnum>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<OrderListPlaceOtocoSelfTradePreventionModeEnum>,
    /// Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_client_order_id: Option<String>,
    /// This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_iceberg_qty: Option<f32>,
    ///
    /// The `working_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_time_in_force: Option<OrderListPlaceOtocoWorkingTimeInForceEnum>,
    /// Arbitrary numeric value identifying the working order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_strategy_type: Option<i32>,
    /// Arbitrary unique ID among open orders for the pending above order.<br> Automatically generated if not sent.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_client_order_id: Option<String>,
    /// Can be used if `pendingAboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_price: Option<f32>,
    /// Can be used if `pendingAboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_stop_price: Option<f32>,
    /// See [Trailing Stop FAQ](faqs/trailing-stop-faq.md)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_trailing_delta: Option<f32>,
    /// This can only be used if `pendingAboveTimeInForce` is `GTC` or if `pendingAboveType` is `LIMIT_MAKER`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_iceberg_qty: Option<f32>,
    ///
    /// The `pending_above_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_time_in_force: Option<OrderListPlaceOtocoPendingAboveTimeInForceEnum>,
    /// Arbitrary numeric value identifying the pending above order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the pending above order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_above_strategy_type: Option<i32>,
    ///
    /// The `pending_below_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_type: Option<OrderListPlaceOtocoPendingBelowTypeEnum>,
    /// Arbitrary unique ID among open orders for the pending below order.<br> Automatically generated if not sent.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_client_order_id: Option<String>,
    /// Can be used if `pendingBelowType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT` to specify the limit price.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_price: Option<f32>,
    /// Can be used if `pendingBelowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT or TAKE_PROFIT_LIMIT`. <br>Either `pendingBelowStopPrice` or `pendingBelowTrailingDelta` or both, must be specified.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_stop_price: Option<f32>,
    ///
    /// The `pending_below_trailing_delta` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_trailing_delta: Option<f32>,
    /// This can only be used if `pendingBelowTimeInForce` is `GTC`, or if `pendingBelowType` is `LIMIT_MAKER`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_iceberg_qty: Option<f32>,
    ///
    /// The `pending_below_time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_time_in_force: Option<OrderListPlaceOtocoPendingBelowTimeInForceEnum>,
    /// Arbitrary numeric value identifying the pending below order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the pending below order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pending_below_strategy_type: Option<i32>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderListPlaceOtocoParams {
    /// Create a builder for [`order_list_place_otoco`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `working_type` — String
    /// * `working_side` — String
    /// * `working_price` — f32
    /// * `working_quantity` — Sets the quantity for the working order.
    /// * `pending_side` — String
    /// * `pending_quantity` — Sets the quantity for the pending order.
    /// * `pending_above_type` — String
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        working_type: OrderListPlaceOtocoWorkingTypeEnum,
        working_side: OrderListPlaceOtocoWorkingSideEnum,
        working_price: f32,
        working_quantity: f32,
        pending_side: OrderListPlaceOtocoPendingSideEnum,
        pending_quantity: f32,
        pending_above_type: OrderListPlaceOtocoPendingAboveTypeEnum,
    ) -> OrderListPlaceOtocoParamsBuilder {
        OrderListPlaceOtocoParamsBuilder::default()
            .symbol(symbol)
            .working_type(working_type)
            .working_side(working_side)
            .working_price(working_price)
            .working_quantity(working_quantity)
            .pending_side(pending_side)
            .pending_quantity(pending_quantity)
            .pending_above_type(pending_above_type)
    }
}
/// Request parameters for the [`order_place`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_place`](#method.order_place).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderPlaceParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: OrderPlaceSideEnum,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub r#type: OrderPlaceTypeEnum,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    ///
    /// The `time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_in_force: Option<OrderPlaceTimeInForceEnum>,
    ///
    /// The `price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price: Option<f32>,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quantity: Option<f32>,
    ///
    /// The `quote_order_qty` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quote_order_qty: Option<f32>,
    /// The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<OrderPlaceNewOrderRespTypeEnum>,
    ///
    /// The `stop_price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_price: Option<f32>,
    /// See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub trailing_delta: Option<i32>,
    ///
    /// The `iceberg_qty` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub iceberg_qty: Option<f32>,
    /// Arbitrary numeric value identifying the order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the order strategy.
    /// Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_type: Option<i32>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<OrderPlaceSelfTradePreventionModeEnum>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl OrderPlaceParams {
    /// Create a builder for [`order_place`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `r#type` — String
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: OrderPlaceSideEnum,
        r#type: OrderPlaceTypeEnum,
    ) -> OrderPlaceParamsBuilder {
        OrderPlaceParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .r#type(r#type)
    }
}
/// Request parameters for the [`order_test`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`order_test`](#method.order_test).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct OrderTestParams {
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Default: `false`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub compute_commission_rates: Option<bool>,
}

impl OrderTestParams {
    /// Create a builder for [`order_test`].
    ///
    /// Required parameters:
    ///
    ///
    #[must_use]
    pub fn builder() -> OrderTestParamsBuilder {
        OrderTestParamsBuilder::default()
    }
}
/// Request parameters for the [`sor_order_place`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`sor_order_place`](#method.sor_order_place).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct SorOrderPlaceParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: SorOrderPlaceSideEnum,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub r#type: SorOrderPlaceTypeEnum,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub quantity: f32,
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    ///
    /// The `time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_in_force: Option<SorOrderPlaceTimeInForceEnum>,
    ///
    /// The `price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price: Option<f32>,
    /// The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    ///
    /// The `new_order_resp_type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<SorOrderPlaceNewOrderRespTypeEnum>,
    ///
    /// The `iceberg_qty` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub iceberg_qty: Option<f32>,
    /// Arbitrary numeric value identifying the order within an order strategy.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    /// Arbitrary numeric value identifying the order strategy.
    /// Values smaller than 1000000 are reserved and cannot be used.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_type: Option<i32>,
    ///
    /// The `self_trade_prevention_mode` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<SorOrderPlaceSelfTradePreventionModeEnum>,
    /// The value cannot be greater than `60000`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl SorOrderPlaceParams {
    /// Create a builder for [`sor_order_place`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `r#type` — String
    /// * `quantity` — f32
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: SorOrderPlaceSideEnum,
        r#type: SorOrderPlaceTypeEnum,
        quantity: f32,
    ) -> SorOrderPlaceParamsBuilder {
        SorOrderPlaceParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .r#type(r#type)
            .quantity(quantity)
    }
}
/// Request parameters for the [`sor_order_test`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`sor_order_test`](#method.sor_order_test).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct SorOrderTestParams {
    /// Unique WebSocket request ID.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub id: Option<String>,
    /// Default: `false`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub compute_commission_rates: Option<bool>,
}

impl SorOrderTestParams {
    /// Create a builder for [`sor_order_test`].
    ///
    /// Required parameters:
    ///
    ///
    #[must_use]
    pub fn builder() -> SorOrderTestParamsBuilder {
        SorOrderTestParamsBuilder::default()
    }
}

#[async_trait]
impl TradeApi for TradeApiClient {
    async fn open_orders_cancel_all(
        &self,
        params: OpenOrdersCancelAllParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<models::OpenOrdersCancelAllResponseResultInner>>>
    {
        let OpenOrdersCancelAllParams {
            symbol,
            id,
            recv_window,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = recv_window {
            payload.insert("recv_window".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Vec<models::OpenOrdersCancelAllResponseResultInner>>(
                "/openOrders.cancelAll".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: true,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn order_amend_keep_priority(
        &self,
        params: OrderAmendKeepPriorityParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderAmendKeepPriorityResponseResult>>>
    {
        let OrderAmendKeepPriorityParams {
            symbol,
            new_qty,
            id,
            order_id,
            orig_client_order_id,
            new_client_order_id,
            recv_window,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        payload.insert("new_qty".to_string(), serde_json::json!(new_qty));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = order_id {
            payload.insert("order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = orig_client_order_id {
            payload.insert("orig_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = new_client_order_id {
            payload.insert("new_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = recv_window {
            payload.insert("recv_window".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Box<models::OrderAmendKeepPriorityResponseResult>>(
                "/order.amend.keepPriority".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: true,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn order_cancel(
        &self,
        params: OrderCancelParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderCancelResponseResult>>> {
        let OrderCancelParams {
            symbol,
            id,
            order_id,
            orig_client_order_id,
            new_client_order_id,
            cancel_restrictions,
            recv_window,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = order_id {
            payload.insert("order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = orig_client_order_id {
            payload.insert("orig_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = new_client_order_id {
            payload.insert("new_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = cancel_restrictions {
            payload.insert("cancel_restrictions".to_string(), serde_json::json!(value));
        }
        if let Some(value) = recv_window {
            payload.insert("recv_window".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Box<models::OrderCancelResponseResult>>(
                "/order.cancel".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: true,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn order_cancel_replace(
        &self,
        params: OrderCancelReplaceParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderCancelReplaceResponseResult>>> {
        let OrderCancelReplaceParams {
            symbol,
            cancel_replace_mode,
            side,
            r#type,
            id,
            cancel_order_id,
            cancel_orig_client_order_id,
            cancel_new_client_order_id,
            time_in_force,
            price,
            quantity,
            quote_order_qty,
            new_client_order_id,
            new_order_resp_type,
            stop_price,
            trailing_delta,
            iceberg_qty,
            strategy_id,
            strategy_type,
            self_trade_prevention_mode,
            cancel_restrictions,
            order_rate_limit_exceeded_mode,
            recv_window,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        payload.insert(
            "cancel_replace_mode".to_string(),
            serde_json::json!(cancel_replace_mode),
        );
        payload.insert("side".to_string(), serde_json::json!(side));
        payload.insert("r#type".to_string(), serde_json::json!(r#type));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = cancel_order_id {
            payload.insert("cancel_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = cancel_orig_client_order_id {
            payload.insert(
                "cancel_orig_client_order_id".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = cancel_new_client_order_id {
            payload.insert(
                "cancel_new_client_order_id".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = time_in_force {
            payload.insert("time_in_force".to_string(), serde_json::json!(value));
        }
        if let Some(value) = price {
            payload.insert("price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = quantity {
            payload.insert("quantity".to_string(), serde_json::json!(value));
        }
        if let Some(value) = quote_order_qty {
            payload.insert("quote_order_qty".to_string(), serde_json::json!(value));
        }
        if let Some(value) = new_client_order_id {
            payload.insert("new_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = new_order_resp_type {
            payload.insert("new_order_resp_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = stop_price {
            payload.insert("stop_price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = trailing_delta {
            payload.insert("trailing_delta".to_string(), serde_json::json!(value));
        }
        if let Some(value) = iceberg_qty {
            payload.insert("iceberg_qty".to_string(), serde_json::json!(value));
        }
        if let Some(value) = strategy_id {
            payload.insert("strategy_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = strategy_type {
            payload.insert("strategy_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = self_trade_prevention_mode {
            payload.insert(
                "self_trade_prevention_mode".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = cancel_restrictions {
            payload.insert("cancel_restrictions".to_string(), serde_json::json!(value));
        }
        if let Some(value) = order_rate_limit_exceeded_mode {
            payload.insert(
                "order_rate_limit_exceeded_mode".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = recv_window {
            payload.insert("recv_window".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Box<models::OrderCancelReplaceResponseResult>>(
                "/order.cancelReplace".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: true,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn order_list_cancel(
        &self,
        params: OrderListCancelParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderListCancelResponseResult>>> {
        let OrderListCancelParams {
            symbol,
            id,
            order_list_id,
            list_client_order_id,
            new_client_order_id,
            recv_window,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = order_list_id {
            payload.insert("order_list_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = list_client_order_id {
            payload.insert("list_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = new_client_order_id {
            payload.insert("new_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = recv_window {
            payload.insert("recv_window".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Box<models::OrderListCancelResponseResult>>(
                "/orderList.cancel".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: true,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn order_list_place(
        &self,
        params: OrderListPlaceParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderListPlaceResponseResult>>> {
        let OrderListPlaceParams {
            symbol,
            side,
            price,
            quantity,
            id,
            list_client_order_id,
            limit_client_order_id,
            limit_iceberg_qty,
            limit_strategy_id,
            limit_strategy_type,
            stop_price,
            trailing_delta,
            stop_client_order_id,
            stop_limit_price,
            stop_limit_time_in_force,
            stop_iceberg_qty,
            stop_strategy_id,
            stop_strategy_type,
            new_order_resp_type,
            self_trade_prevention_mode,
            recv_window,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        payload.insert("side".to_string(), serde_json::json!(side));
        payload.insert("price".to_string(), serde_json::json!(price));
        payload.insert("quantity".to_string(), serde_json::json!(quantity));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = list_client_order_id {
            payload.insert("list_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = limit_client_order_id {
            payload.insert(
                "limit_client_order_id".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = limit_iceberg_qty {
            payload.insert("limit_iceberg_qty".to_string(), serde_json::json!(value));
        }
        if let Some(value) = limit_strategy_id {
            payload.insert("limit_strategy_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = limit_strategy_type {
            payload.insert("limit_strategy_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = stop_price {
            payload.insert("stop_price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = trailing_delta {
            payload.insert("trailing_delta".to_string(), serde_json::json!(value));
        }
        if let Some(value) = stop_client_order_id {
            payload.insert("stop_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = stop_limit_price {
            payload.insert("stop_limit_price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = stop_limit_time_in_force {
            payload.insert(
                "stop_limit_time_in_force".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = stop_iceberg_qty {
            payload.insert("stop_iceberg_qty".to_string(), serde_json::json!(value));
        }
        if let Some(value) = stop_strategy_id {
            payload.insert("stop_strategy_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = stop_strategy_type {
            payload.insert("stop_strategy_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = new_order_resp_type {
            payload.insert("new_order_resp_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = self_trade_prevention_mode {
            payload.insert(
                "self_trade_prevention_mode".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = recv_window {
            payload.insert("recv_window".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Box<models::OrderListPlaceResponseResult>>(
                "/orderList.place".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: true,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn order_list_place_oco(
        &self,
        params: OrderListPlaceOcoParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderListPlaceOcoResponseResult>>> {
        let OrderListPlaceOcoParams {
            symbol,
            side,
            quantity,
            above_type,
            below_type,
            id,
            list_client_order_id,
            above_client_order_id,
            above_iceberg_qty,
            above_price,
            above_stop_price,
            above_trailing_delta,
            above_time_in_force,
            above_strategy_id,
            above_strategy_type,
            below_client_order_id,
            below_iceberg_qty,
            below_price,
            below_stop_price,
            below_trailing_delta,
            below_time_in_force,
            below_strategy_id,
            below_strategy_type,
            new_order_resp_type,
            self_trade_prevention_mode,
            recv_window,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        payload.insert("side".to_string(), serde_json::json!(side));
        payload.insert("quantity".to_string(), serde_json::json!(quantity));
        payload.insert("above_type".to_string(), serde_json::json!(above_type));
        payload.insert("below_type".to_string(), serde_json::json!(below_type));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = list_client_order_id {
            payload.insert("list_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = above_client_order_id {
            payload.insert(
                "above_client_order_id".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = above_iceberg_qty {
            payload.insert("above_iceberg_qty".to_string(), serde_json::json!(value));
        }
        if let Some(value) = above_price {
            payload.insert("above_price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = above_stop_price {
            payload.insert("above_stop_price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = above_trailing_delta {
            payload.insert("above_trailing_delta".to_string(), serde_json::json!(value));
        }
        if let Some(value) = above_time_in_force {
            payload.insert("above_time_in_force".to_string(), serde_json::json!(value));
        }
        if let Some(value) = above_strategy_id {
            payload.insert("above_strategy_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = above_strategy_type {
            payload.insert("above_strategy_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = below_client_order_id {
            payload.insert(
                "below_client_order_id".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = below_iceberg_qty {
            payload.insert("below_iceberg_qty".to_string(), serde_json::json!(value));
        }
        if let Some(value) = below_price {
            payload.insert("below_price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = below_stop_price {
            payload.insert("below_stop_price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = below_trailing_delta {
            payload.insert("below_trailing_delta".to_string(), serde_json::json!(value));
        }
        if let Some(value) = below_time_in_force {
            payload.insert("below_time_in_force".to_string(), serde_json::json!(value));
        }
        if let Some(value) = below_strategy_id {
            payload.insert("below_strategy_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = below_strategy_type {
            payload.insert("below_strategy_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = new_order_resp_type {
            payload.insert("new_order_resp_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = self_trade_prevention_mode {
            payload.insert(
                "self_trade_prevention_mode".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = recv_window {
            payload.insert("recv_window".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Box<models::OrderListPlaceOcoResponseResult>>(
                "/orderList.place.oco".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: true,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn order_list_place_oto(
        &self,
        params: OrderListPlaceOtoParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderListPlaceOtoResponseResult>>> {
        let OrderListPlaceOtoParams {
            symbol,
            working_type,
            working_side,
            working_price,
            working_quantity,
            pending_type,
            pending_side,
            pending_quantity,
            id,
            list_client_order_id,
            new_order_resp_type,
            self_trade_prevention_mode,
            working_client_order_id,
            working_iceberg_qty,
            working_time_in_force,
            working_strategy_id,
            working_strategy_type,
            pending_client_order_id,
            pending_price,
            pending_stop_price,
            pending_trailing_delta,
            pending_iceberg_qty,
            pending_time_in_force,
            pending_strategy_id,
            pending_strategy_type,
            recv_window,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        payload.insert("working_type".to_string(), serde_json::json!(working_type));
        payload.insert("working_side".to_string(), serde_json::json!(working_side));
        payload.insert(
            "working_price".to_string(),
            serde_json::json!(working_price),
        );
        payload.insert(
            "working_quantity".to_string(),
            serde_json::json!(working_quantity),
        );
        payload.insert("pending_type".to_string(), serde_json::json!(pending_type));
        payload.insert("pending_side".to_string(), serde_json::json!(pending_side));
        payload.insert(
            "pending_quantity".to_string(),
            serde_json::json!(pending_quantity),
        );
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = list_client_order_id {
            payload.insert("list_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = new_order_resp_type {
            payload.insert("new_order_resp_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = self_trade_prevention_mode {
            payload.insert(
                "self_trade_prevention_mode".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = working_client_order_id {
            payload.insert(
                "working_client_order_id".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = working_iceberg_qty {
            payload.insert("working_iceberg_qty".to_string(), serde_json::json!(value));
        }
        if let Some(value) = working_time_in_force {
            payload.insert(
                "working_time_in_force".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = working_strategy_id {
            payload.insert("working_strategy_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = working_strategy_type {
            payload.insert(
                "working_strategy_type".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_client_order_id {
            payload.insert(
                "pending_client_order_id".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_price {
            payload.insert("pending_price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = pending_stop_price {
            payload.insert("pending_stop_price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = pending_trailing_delta {
            payload.insert(
                "pending_trailing_delta".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_iceberg_qty {
            payload.insert("pending_iceberg_qty".to_string(), serde_json::json!(value));
        }
        if let Some(value) = pending_time_in_force {
            payload.insert(
                "pending_time_in_force".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_strategy_id {
            payload.insert("pending_strategy_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = pending_strategy_type {
            payload.insert(
                "pending_strategy_type".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = recv_window {
            payload.insert("recv_window".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Box<models::OrderListPlaceOtoResponseResult>>(
                "/orderList.place.oto".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: true,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn order_list_place_otoco(
        &self,
        params: OrderListPlaceOtocoParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderListPlaceOtocoResponseResult>>> {
        let OrderListPlaceOtocoParams {
            symbol,
            working_type,
            working_side,
            working_price,
            working_quantity,
            pending_side,
            pending_quantity,
            pending_above_type,
            id,
            list_client_order_id,
            new_order_resp_type,
            self_trade_prevention_mode,
            working_client_order_id,
            working_iceberg_qty,
            working_time_in_force,
            working_strategy_id,
            working_strategy_type,
            pending_above_client_order_id,
            pending_above_price,
            pending_above_stop_price,
            pending_above_trailing_delta,
            pending_above_iceberg_qty,
            pending_above_time_in_force,
            pending_above_strategy_id,
            pending_above_strategy_type,
            pending_below_type,
            pending_below_client_order_id,
            pending_below_price,
            pending_below_stop_price,
            pending_below_trailing_delta,
            pending_below_iceberg_qty,
            pending_below_time_in_force,
            pending_below_strategy_id,
            pending_below_strategy_type,
            recv_window,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        payload.insert("working_type".to_string(), serde_json::json!(working_type));
        payload.insert("working_side".to_string(), serde_json::json!(working_side));
        payload.insert(
            "working_price".to_string(),
            serde_json::json!(working_price),
        );
        payload.insert(
            "working_quantity".to_string(),
            serde_json::json!(working_quantity),
        );
        payload.insert("pending_side".to_string(), serde_json::json!(pending_side));
        payload.insert(
            "pending_quantity".to_string(),
            serde_json::json!(pending_quantity),
        );
        payload.insert(
            "pending_above_type".to_string(),
            serde_json::json!(pending_above_type),
        );
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = list_client_order_id {
            payload.insert("list_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = new_order_resp_type {
            payload.insert("new_order_resp_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = self_trade_prevention_mode {
            payload.insert(
                "self_trade_prevention_mode".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = working_client_order_id {
            payload.insert(
                "working_client_order_id".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = working_iceberg_qty {
            payload.insert("working_iceberg_qty".to_string(), serde_json::json!(value));
        }
        if let Some(value) = working_time_in_force {
            payload.insert(
                "working_time_in_force".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = working_strategy_id {
            payload.insert("working_strategy_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = working_strategy_type {
            payload.insert(
                "working_strategy_type".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_above_client_order_id {
            payload.insert(
                "pending_above_client_order_id".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_above_price {
            payload.insert("pending_above_price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = pending_above_stop_price {
            payload.insert(
                "pending_above_stop_price".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_above_trailing_delta {
            payload.insert(
                "pending_above_trailing_delta".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_above_iceberg_qty {
            payload.insert(
                "pending_above_iceberg_qty".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_above_time_in_force {
            payload.insert(
                "pending_above_time_in_force".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_above_strategy_id {
            payload.insert(
                "pending_above_strategy_id".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_above_strategy_type {
            payload.insert(
                "pending_above_strategy_type".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_below_type {
            payload.insert("pending_below_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = pending_below_client_order_id {
            payload.insert(
                "pending_below_client_order_id".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_below_price {
            payload.insert("pending_below_price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = pending_below_stop_price {
            payload.insert(
                "pending_below_stop_price".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_below_trailing_delta {
            payload.insert(
                "pending_below_trailing_delta".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_below_iceberg_qty {
            payload.insert(
                "pending_below_iceberg_qty".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_below_time_in_force {
            payload.insert(
                "pending_below_time_in_force".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_below_strategy_id {
            payload.insert(
                "pending_below_strategy_id".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = pending_below_strategy_type {
            payload.insert(
                "pending_below_strategy_type".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = recv_window {
            payload.insert("recv_window".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Box<models::OrderListPlaceOtocoResponseResult>>(
                "/orderList.place.otoco".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: true,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn order_place(
        &self,
        params: OrderPlaceParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderPlaceResponseResult>>> {
        let OrderPlaceParams {
            symbol,
            side,
            r#type,
            id,
            time_in_force,
            price,
            quantity,
            quote_order_qty,
            new_client_order_id,
            new_order_resp_type,
            stop_price,
            trailing_delta,
            iceberg_qty,
            strategy_id,
            strategy_type,
            self_trade_prevention_mode,
            recv_window,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        payload.insert("side".to_string(), serde_json::json!(side));
        payload.insert("r#type".to_string(), serde_json::json!(r#type));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = time_in_force {
            payload.insert("time_in_force".to_string(), serde_json::json!(value));
        }
        if let Some(value) = price {
            payload.insert("price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = quantity {
            payload.insert("quantity".to_string(), serde_json::json!(value));
        }
        if let Some(value) = quote_order_qty {
            payload.insert("quote_order_qty".to_string(), serde_json::json!(value));
        }
        if let Some(value) = new_client_order_id {
            payload.insert("new_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = new_order_resp_type {
            payload.insert("new_order_resp_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = stop_price {
            payload.insert("stop_price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = trailing_delta {
            payload.insert("trailing_delta".to_string(), serde_json::json!(value));
        }
        if let Some(value) = iceberg_qty {
            payload.insert("iceberg_qty".to_string(), serde_json::json!(value));
        }
        if let Some(value) = strategy_id {
            payload.insert("strategy_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = strategy_type {
            payload.insert("strategy_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = self_trade_prevention_mode {
            payload.insert(
                "self_trade_prevention_mode".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = recv_window {
            payload.insert("recv_window".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Box<models::OrderPlaceResponseResult>>(
                "/order.place".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: true,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn order_test(
        &self,
        params: OrderTestParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderTestResponseResult>>> {
        let OrderTestParams {
            id,
            compute_commission_rates,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = compute_commission_rates {
            payload.insert(
                "compute_commission_rates".to_string(),
                serde_json::json!(value),
            );
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Box<models::OrderTestResponseResult>>(
                "/order.test".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: true,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn sor_order_place(
        &self,
        params: SorOrderPlaceParams,
    ) -> anyhow::Result<WebsocketApiResponse<Vec<models::SorOrderPlaceResponseResultInner>>> {
        let SorOrderPlaceParams {
            symbol,
            side,
            r#type,
            quantity,
            id,
            time_in_force,
            price,
            new_client_order_id,
            new_order_resp_type,
            iceberg_qty,
            strategy_id,
            strategy_type,
            self_trade_prevention_mode,
            recv_window,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        payload.insert("symbol".to_string(), serde_json::json!(symbol));
        payload.insert("side".to_string(), serde_json::json!(side));
        payload.insert("r#type".to_string(), serde_json::json!(r#type));
        payload.insert("quantity".to_string(), serde_json::json!(quantity));
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = time_in_force {
            payload.insert("time_in_force".to_string(), serde_json::json!(value));
        }
        if let Some(value) = price {
            payload.insert("price".to_string(), serde_json::json!(value));
        }
        if let Some(value) = new_client_order_id {
            payload.insert("new_client_order_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = new_order_resp_type {
            payload.insert("new_order_resp_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = iceberg_qty {
            payload.insert("iceberg_qty".to_string(), serde_json::json!(value));
        }
        if let Some(value) = strategy_id {
            payload.insert("strategy_id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = strategy_type {
            payload.insert("strategy_type".to_string(), serde_json::json!(value));
        }
        if let Some(value) = self_trade_prevention_mode {
            payload.insert(
                "self_trade_prevention_mode".to_string(),
                serde_json::json!(value),
            );
        }
        if let Some(value) = recv_window {
            payload.insert("recv_window".to_string(), serde_json::json!(value));
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Vec<models::SorOrderPlaceResponseResultInner>>(
                "/sor.order.place".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: true,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }

    async fn sor_order_test(
        &self,
        params: SorOrderTestParams,
    ) -> anyhow::Result<WebsocketApiResponse<Box<models::OrderTestResponseResult>>> {
        let SorOrderTestParams {
            id,
            compute_commission_rates,
        } = params;

        let mut payload: BTreeMap<String, Value> = BTreeMap::new();
        if let Some(value) = id {
            payload.insert("id".to_string(), serde_json::json!(value));
        }
        if let Some(value) = compute_commission_rates {
            payload.insert(
                "compute_commission_rates".to_string(),
                serde_json::json!(value),
            );
        }
        let payload = remove_empty_value(payload);

        self.websocket_api_base
            .send_message::<Box<models::OrderTestResponseResult>>(
                "/sor.order.test".trim_start_matches('/'),
                payload,
                WebsocketMessageSendOptions {
                    is_signed: true,
                    with_api_key: false,
                },
            )
            .await
            .map_err(anyhow::Error::from)
    }
}

#[cfg(all(test, feature = "spot"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::common::websocket::{WebsocketApi, WebsocketConnection, WebsocketHandler};
    use crate::config::ConfigurationWebsocketApi;
    use crate::errors::WebsocketError;
    use crate::models::WebsocketApiRateLimit;
    use serde_json::{Value, json};
    use tokio::spawn;
    use tokio::sync::mpsc::{UnboundedReceiver, unbounded_channel};
    use tokio::time::{Duration, timeout};
    use tokio_tungstenite::tungstenite::Message;

    async fn setup() -> (
        Arc<WebsocketApi>,
        Arc<WebsocketConnection>,
        UnboundedReceiver<Message>,
    ) {
        let conn = WebsocketConnection::new("test-conn");
        let (tx, rx) = unbounded_channel::<Message>();
        {
            let mut conn_state = conn.state.lock().await;
            conn_state.ws_write_tx = Some(tx);
        }

        let config = ConfigurationWebsocketApi::builder()
            .api_key("key")
            .api_secret("secret")
            .build()
            .expect("Failed to build configuration");
        let ws_api = WebsocketApi::new(config, vec![conn.clone()]);
        conn.set_handler(ws_api.clone() as Arc<dyn WebsocketHandler>)
            .await;
        ws_api.clone().connect().await.unwrap();

        (ws_api, conn, rx)
    }

    #[test]
    fn open_orders_cancel_all_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OpenOrdersCancelAllParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.open_orders_cancel_all(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/openOrders.cancelAll".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"778f938f-9041-4b88-9914-efbf64eeacc8","status":200,"result":[{"orderListId":19431,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"iuVNVJYYrByz6C4yGOPPK0","transactionTime":1660803702431,"symbol":"BTCUSDT","orders":[{"symbol":"BTCUSDT","orderId":12569099454,"clientOrderId":"Tnu2IP0J5Y4mxw3IATBfmW"},{"symbol":"BTCUSDT","orderId":12569099453,"clientOrderId":"bX5wROblo6YeDwa9iTLeyY"}],"orderReports":[{"symbol":"BTCUSDT","origClientOrderId":"Tnu2IP0J5Y4mxw3IATBfmW","orderId":12569099454,"orderListId":19431,"clientOrderId":"OFFXQtxVFZ6Nbcg4PgE2DA","transactTime":1684804350068,"price":"23400.00000000","origQty":"0.00850000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","selfTradePreventionMode":"NONE"},{"symbol":"BTCUSDT","origClientOrderId":"bX5wROblo6YeDwa9iTLeyY","orderId":12569099453,"orderListId":19431,"clientOrderId":"OFFXQtxVFZ6Nbcg4PgE2DA","transactTime":1684804350068,"price":"23450.50000000","origQty":"0.00850000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"BUY","stopPrice":"23430.00000000","selfTradePreventionMode":"NONE"}]},{"symbol":"BTCUSDT","origClientOrderId":"4d96324ff9d44481926157","orderId":12569099453,"orderListId":-1,"clientOrderId":"91fe37ce9e69c90d6358c0","transactTime":1684804350068,"price":"23416.10000000","origQty":"0.00847000","executedQty":"0.00001000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.23416100","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"SELL","stopPrice":"0.00000000","trailingDelta":0,"trailingTime":-1,"icebergQty":"0.00000000","strategyId":37463720,"strategyType":1000000,"selfTradePreventionMode":"NONE"}],"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":1}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Vec<models::OpenOrdersCancelAllResponseResultInner> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn open_orders_cancel_all_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = OpenOrdersCancelAllParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.open_orders_cancel_all(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn open_orders_cancel_all_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OpenOrdersCancelAllParams::builder("BNBUSDT".to_string())
                    .build()
                    .unwrap();
                client.open_orders_cancel_all(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let text = match sent {
                Message::Text(t) => t,
                _ => panic!("expected Message Text"),
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn order_amend_keep_priority_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderAmendKeepPriorityParams::builder("BNBUSDT".to_string(),1.0,).build().unwrap();
                client.order_amend_keep_priority(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/order.amend.keepPriority".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"56374b46-3061-486b-a311-89ee972eb648","status":200,"result":{"transactTime":1741924229819,"executionId":60,"amendedOrder":{"symbol":"BTUCSDT","orderId":23,"orderListId":4,"origClientOrderId":"my_pending_order","clientOrderId":"xbxXh5SSwaHS7oUEOCI88B","price":"1.00000000","qty":"5.00000000","executedQty":"0.00000000","preventedQty":"0.00000000","quoteOrderQty":"0.00000000","cumulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"LIMIT","side":"BUY","workingTime":1741924204920,"selfTradePreventionMode":"NONE"},"listStatus":{"orderListId":4,"contingencyType":"OTO","listOrderStatus":"EXECUTING","listClientOrderId":"8nOGLLawudj1QoOiwbroRH","symbol":"BTCUSDT","orders":[{"symbol":"BTCUSDT","orderId":23,"clientOrderId":"xbxXh5SSwaHS7oUEOCI88B"},{"symbol":"BTCUSDT","orderId":22,"clientOrderId":"g04EWsjaackzedjC9wRkWD"},{"symbol":"BTCUSDT","orderId":23,"clientOrderId":"xbxXh5SSwaHS7oUEOCI88B"},{"symbol":"BTCUSDT","orderId":22,"clientOrderId":"g04EWsjaackzedjC9wRkWD"}]}},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":1}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Box<models::OrderAmendKeepPriorityResponseResult> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn order_amend_keep_priority_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = OrderAmendKeepPriorityParams::builder("BNBUSDT".to_string(),1.0,).build().unwrap();
                client.order_amend_keep_priority(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn order_amend_keep_priority_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderAmendKeepPriorityParams::builder("BNBUSDT".to_string(), 1.0)
                    .build()
                    .unwrap();
                client.order_amend_keep_priority(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let text = match sent {
                Message::Text(t) => t,
                _ => panic!("expected Message Text"),
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn order_cancel_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderCancelParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.order_cancel(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/order.cancel".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"16eaf097-bbec-44b9-96ff-e97e6e875870","status":200,"result":{"symbol":"BTCUSDT","origClientOrderId":"4d96324ff9d44481926157","orderId":12569099453,"orderListId":19431,"clientOrderId":"91fe37ce9e69c90d6358c0","transactTime":1684804350068,"price":"23416.10000000","origQty":"0.00847000","executedQty":"0.00001000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.23416100","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"SELL","stopPrice":"0.00000000","trailingDelta":0,"icebergQty":"0.00000000","strategyId":37463720,"strategyType":1000000,"selfTradePreventionMode":"NONE","contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"iuVNVJYYrByz6C4yGOPPK0","transactionTime":1660803702431,"orders":[{"symbol":"BTCUSDT","orderId":12569099454,"clientOrderId":"Tnu2IP0J5Y4mxw3IATBfmW"},{"symbol":"BTCUSDT","orderId":12569099453,"clientOrderId":"bX5wROblo6YeDwa9iTLeyY"},{"symbol":"BTCUSDT","orderId":12569099454,"clientOrderId":"Tnu2IP0J5Y4mxw3IATBfmW"},{"symbol":"BTCUSDT","orderId":12569099453,"clientOrderId":"bX5wROblo6YeDwa9iTLeyY"}],"orderReports":[{"symbol":"BTCUSDT","origClientOrderId":"Tnu2IP0J5Y4mxw3IATBfmW","orderId":12569099454,"orderListId":19431,"clientOrderId":"OFFXQtxVFZ6Nbcg4PgE2DA","transactTime":1684804350068,"price":"23400.00000000","origQty":"0.00850000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","selfTradePreventionMode":"NONE"},{"symbol":"BTCUSDT","origClientOrderId":"bX5wROblo6YeDwa9iTLeyY","orderId":12569099453,"orderListId":19431,"clientOrderId":"OFFXQtxVFZ6Nbcg4PgE2DA","transactTime":1684804350068,"price":"23450.50000000","origQty":"0.00850000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"BUY","stopPrice":"23430.00000000","selfTradePreventionMode":"NONE"},{"symbol":"BTCUSDT","origClientOrderId":"Tnu2IP0J5Y4mxw3IATBfmW","orderId":12569099454,"orderListId":19431,"clientOrderId":"OFFXQtxVFZ6Nbcg4PgE2DA","transactTime":1684804350068,"price":"23400.00000000","origQty":"0.00850000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","selfTradePreventionMode":"NONE"},{"symbol":"BTCUSDT","origClientOrderId":"bX5wROblo6YeDwa9iTLeyY","orderId":12569099453,"orderListId":19431,"clientOrderId":"OFFXQtxVFZ6Nbcg4PgE2DA","transactTime":1684804350068,"price":"23450.50000000","origQty":"0.00850000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"BUY","stopPrice":"23430.00000000","selfTradePreventionMode":"NONE"}]},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":1}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Box<models::OrderCancelResponseResult> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn order_cancel_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = OrderCancelParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.order_cancel(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn order_cancel_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderCancelParams::builder("BNBUSDT".to_string())
                    .build()
                    .unwrap();
                client.order_cancel(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let text = match sent {
                Message::Text(t) => t,
                _ => panic!("expected Message Text"),
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn order_cancel_replace_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderCancelReplaceParams::builder("BNBUSDT".to_string(),OrderCancelReplaceCancelReplaceModeEnum::STOP_ON_FAILURE,OrderCancelReplaceSideEnum::BUY,OrderCancelReplaceTypeEnum::MARKET,).build().unwrap();
                client.order_cancel_replace(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/order.cancelReplace".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"99de1036-b5e2-4e0f-9b5c-13d751c93a1a","status":200,"result":{"cancelResult":"SUCCESS","newOrderResult":"SUCCESS","cancelResponse":{"symbol":"BTCUSDT","origClientOrderId":"4d96324ff9d44481926157","orderId":125690984230,"orderListId":-1,"clientOrderId":"91fe37ce9e69c90d6358c0","transactTime":1684804350068,"price":"23450.00000000","origQty":"0.00847000","executedQty":"0.00001000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.23450000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"SELL","selfTradePreventionMode":"NONE"},"newOrderResponse":{"symbol":"BTCUSDT","orderId":12569099453,"orderListId":-1,"clientOrderId":"bX5wROblo6YeDwa9iTLeyY","transactTime":1660813156959,"price":"23416.10000000","origQty":"0.00847000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"LIMIT","side":"SELL","selfTradePreventionMode":"NONE"}},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":1},{"rateLimitType":"ORDERS","interval":"DAY","intervalNum":1,"limit":160000,"count":1},{"rateLimitType":"ORDERS","interval":"SECOND","intervalNum":10,"limit":50,"count":1}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Box<models::OrderCancelReplaceResponseResult> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn order_cancel_replace_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = OrderCancelReplaceParams::builder("BNBUSDT".to_string(),OrderCancelReplaceCancelReplaceModeEnum::STOP_ON_FAILURE,OrderCancelReplaceSideEnum::BUY,OrderCancelReplaceTypeEnum::MARKET,).build().unwrap();
                client.order_cancel_replace(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn order_cancel_replace_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderCancelReplaceParams::builder(
                    "BNBUSDT".to_string(),
                    OrderCancelReplaceCancelReplaceModeEnum::STOP_ON_FAILURE,
                    OrderCancelReplaceSideEnum::BUY,
                    OrderCancelReplaceTypeEnum::MARKET,
                )
                .build()
                .unwrap();
                client.order_cancel_replace(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let text = match sent {
                Message::Text(t) => t,
                _ => panic!("expected Message Text"),
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn order_list_cancel_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderListCancelParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.order_list_cancel(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/orderList.cancel".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"c5899911-d3f4-47ae-8835-97da553d27d0","status":200,"result":{"orderListId":1274512,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"6023531d7edaad348f5aff","transactionTime":1660801720215,"symbol":"BTCUSDT","orders":[{"symbol":"BTCUSDT","orderId":12569138902,"clientOrderId":"jLnZpj5enfMXTuhKB1d0us"},{"symbol":"BTCUSDT","orderId":12569138901,"clientOrderId":"BqtFCj5odMoWtSqGk2X9tU"}],"orderReports":[{"symbol":"BTCUSDT","orderId":12569138902,"orderListId":1274512,"clientOrderId":"jLnZpj5enfMXTuhKB1d0us","transactTime":1660801720215,"price":"23420.00000000","origQty":"0.00650000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"SELL","selfTradePreventionMode":"NONE"},{"symbol":"BTCUSDT","orderId":12569138901,"orderListId":1274512,"clientOrderId":"BqtFCj5odMoWtSqGk2X9tU","transactTime":1660801720215,"price":"23410.00000000","origQty":"0.00650000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"SELL","stopPrice":"23405.00000000","selfTradePreventionMode":"NONE"}]},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":1}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Box<models::OrderListCancelResponseResult> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn order_list_cancel_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = OrderListCancelParams::builder("BNBUSDT".to_string(),).build().unwrap();
                client.order_list_cancel(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn order_list_cancel_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderListCancelParams::builder("BNBUSDT".to_string())
                    .build()
                    .unwrap();
                client.order_list_cancel(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let text = match sent {
                Message::Text(t) => t,
                _ => panic!("expected Message Text"),
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn order_list_place_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderListPlaceParams::builder("BNBUSDT".to_string(),OrderListPlaceSideEnum::BUY,1.0,1.0,).build().unwrap();
                client.order_list_place(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/orderList.place".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"57833dc0-e3f2-43fb-ba20-46480973b0aa","status":200,"result":{"orderListId":1274512,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"08985fedd9ea2cf6b28996","transactionTime":1660801713793,"symbol":"BTCUSDT","orders":[{"symbol":"BTCUSDT","orderId":12569138902,"clientOrderId":"jLnZpj5enfMXTuhKB1d0us"},{"symbol":"BTCUSDT","orderId":12569138901,"clientOrderId":"BqtFCj5odMoWtSqGk2X9tU"}],"orderReports":[{"symbol":"BTCUSDT","orderId":12569138902,"orderListId":1274512,"clientOrderId":"jLnZpj5enfMXTuhKB1d0us","transactTime":1660801713793,"price":"23420.00000000","origQty":"0.00650000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"SELL","workingTime":1660801713793,"selfTradePreventionMode":"NONE"},{"symbol":"BTCUSDT","orderId":12569138901,"orderListId":1274512,"clientOrderId":"BqtFCj5odMoWtSqGk2X9tU","transactTime":1660801713793,"price":"23410.00000000","origQty":"0.00650000","executedQty":"0.00000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"SELL","stopPrice":"23405.00000000","workingTime":-1,"selfTradePreventionMode":"NONE"}]},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":1},{"rateLimitType":"ORDERS","interval":"DAY","intervalNum":1,"limit":160000,"count":2},{"rateLimitType":"ORDERS","interval":"SECOND","intervalNum":10,"limit":50,"count":2}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Box<models::OrderListPlaceResponseResult> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn order_list_place_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = OrderListPlaceParams::builder("BNBUSDT".to_string(),OrderListPlaceSideEnum::BUY,1.0,1.0,).build().unwrap();
                client.order_list_place(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn order_list_place_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderListPlaceParams::builder(
                    "BNBUSDT".to_string(),
                    OrderListPlaceSideEnum::BUY,
                    1.0,
                    1.0,
                )
                .build()
                .unwrap();
                client.order_list_place(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let text = match sent {
                Message::Text(t) => t,
                _ => panic!("expected Message Text"),
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn order_list_place_oco_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderListPlaceOcoParams::builder("BNBUSDT".to_string(),OrderListPlaceOcoSideEnum::BUY,1.0,OrderListPlaceOcoAboveTypeEnum::STOP_LOSS_LIMIT,OrderListPlaceOcoBelowTypeEnum::STOP_LOSS,).build().unwrap();
                client.order_list_place_oco(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/orderList.place.oco".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"56374a46-3261-486b-a211-99ed972eb648","status":200,"result":{"orderListId":2,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"cKPMnDCbcLQILtDYM4f4fX","transactionTime":1711062760648,"symbol":"LTCBNB","orders":[{"symbol":"LTCBNB","orderId":3,"clientOrderId":"Z2IMlR79XNY5LU0tOxrWyW"},{"symbol":"LTCBNB","orderId":2,"clientOrderId":"0m6I4wfxvTUrOBSMUl0OPU"}],"orderReports":[{"symbol":"LTCBNB","orderId":3,"orderListId":2,"clientOrderId":"Z2IMlR79XNY5LU0tOxrWyW","transactTime":1711062760648,"price":"1.49999999","origQty":"1.000000","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","workingTime":1711062760648,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBNB","orderId":2,"orderListId":2,"clientOrderId":"0m6I4wfxvTUrOBSMUl0OPU","transactTime":1711062760648,"price":"1.50000000","origQty":"1.000000","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.00000000","status":"NEW","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"BUY","stopPrice":"1.50000001","workingTime":-1,"selfTradePreventionMode":"NONE"}]},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":1},{"rateLimitType":"ORDERS","interval":"DAY","intervalNum":1,"limit":160000,"count":2},{"rateLimitType":"ORDERS","interval":"SECOND","intervalNum":10,"limit":50,"count":2}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Box<models::OrderListPlaceOcoResponseResult> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn order_list_place_oco_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = OrderListPlaceOcoParams::builder("BNBUSDT".to_string(),OrderListPlaceOcoSideEnum::BUY,1.0,OrderListPlaceOcoAboveTypeEnum::STOP_LOSS_LIMIT,OrderListPlaceOcoBelowTypeEnum::STOP_LOSS,).build().unwrap();
                client.order_list_place_oco(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn order_list_place_oco_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderListPlaceOcoParams::builder(
                    "BNBUSDT".to_string(),
                    OrderListPlaceOcoSideEnum::BUY,
                    1.0,
                    OrderListPlaceOcoAboveTypeEnum::STOP_LOSS_LIMIT,
                    OrderListPlaceOcoBelowTypeEnum::STOP_LOSS,
                )
                .build()
                .unwrap();
                client.order_list_place_oco(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let text = match sent {
                Message::Text(t) => t,
                _ => panic!("expected Message Text"),
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn order_list_place_oto_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderListPlaceOtoParams::builder("BNBUSDT".to_string(),OrderListPlaceOtoWorkingTypeEnum::LIMIT,OrderListPlaceOtoWorkingSideEnum::BUY,1.0,1.0,OrderListPlaceOtoPendingTypeEnum::LIMIT,OrderListPlaceOtoPendingSideEnum::BUY,1.0,).build().unwrap();
                client.order_list_place_oto(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/orderList.place.oto".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"1712544395950","status":200,"result":{"orderListId":626,"contingencyType":"OTO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"KA4EBjGnzvSwSCQsDdTrlf","transactionTime":1712544395981,"symbol":"1712544378871","orders":[{"symbol":"LTCBNB","orderId":14,"clientOrderId":"9MxJSE1TYkmyx5lbGLve7R"},{"symbol":"LTCBNB","orderId":13,"clientOrderId":"YiAUtM9yJjl1a2jXHSp9Ny"}],"orderReports":[{"symbol":"LTCBNB","orderId":14,"orderListId":626,"clientOrderId":"9MxJSE1TYkmyx5lbGLve7R","transactTime":1712544395981,"price":"0.000000","origQty":"1.000000","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"PENDING_NEW","timeInForce":"GTC","type":"MARKET","side":"BUY","workingTime":-1,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBNB","orderId":13,"orderListId":626,"clientOrderId":"YiAUtM9yJjl1a2jXHSp9Ny","transactTime":1712544395981,"price":"1.000000","origQty":"1.000000","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"LIMIT","side":"SELL","workingTime":1712544395981,"selfTradePreventionMode":"NONE"}]},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":1000,"count":38},{"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":10000000,"count":10}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Box<models::OrderListPlaceOtoResponseResult> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn order_list_place_oto_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = OrderListPlaceOtoParams::builder("BNBUSDT".to_string(),OrderListPlaceOtoWorkingTypeEnum::LIMIT,OrderListPlaceOtoWorkingSideEnum::BUY,1.0,1.0,OrderListPlaceOtoPendingTypeEnum::LIMIT,OrderListPlaceOtoPendingSideEnum::BUY,1.0,).build().unwrap();
                client.order_list_place_oto(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn order_list_place_oto_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderListPlaceOtoParams::builder(
                    "BNBUSDT".to_string(),
                    OrderListPlaceOtoWorkingTypeEnum::LIMIT,
                    OrderListPlaceOtoWorkingSideEnum::BUY,
                    1.0,
                    1.0,
                    OrderListPlaceOtoPendingTypeEnum::LIMIT,
                    OrderListPlaceOtoPendingSideEnum::BUY,
                    1.0,
                )
                .build()
                .unwrap();
                client.order_list_place_oto(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let text = match sent {
                Message::Text(t) => t,
                _ => panic!("expected Message Text"),
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn order_list_place_otoco_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderListPlaceOtocoParams::builder("BNBUSDT".to_string(),OrderListPlaceOtocoWorkingTypeEnum::LIMIT,OrderListPlaceOtocoWorkingSideEnum::BUY,1.0,1.0,OrderListPlaceOtocoPendingSideEnum::BUY,1.0,OrderListPlaceOtocoPendingAboveTypeEnum::STOP_LOSS_LIMIT,).build().unwrap();
                client.order_list_place_otoco(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/orderList.place.otoco".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"1712544408508","status":200,"result":{"orderListId":629,"contingencyType":"OTO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"GaeJHjZPasPItFj4x7Mqm6","transactionTime":1712544408537,"symbol":"1712544378871","orders":[{"symbol":"LTCBNB","orderId":25,"clientOrderId":"ilpIoShcFZ1ZGgSASKxMPt"},{"symbol":"LTCBNB","orderId":24,"clientOrderId":"YcCPKCDMQIjNvLtNswt82X"},{"symbol":"LTCBNB","orderId":23,"clientOrderId":"OVQOpKwfmPCfaBTD0n7e7H"}],"orderReports":[{"symbol":"LTCBNB","orderId":25,"orderListId":629,"clientOrderId":"ilpIoShcFZ1ZGgSASKxMPt","transactTime":1712544408537,"price":"5.000000","origQty":"5.000000","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"PENDING_NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"SELL","workingTime":-1,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBNB","orderId":24,"orderListId":629,"clientOrderId":"YcCPKCDMQIjNvLtNswt82X","transactTime":1712544408537,"price":"0.000000","origQty":"5.000000","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"PENDING_NEW","timeInForce":"GTC","type":"STOP_LOSS","side":"SELL","stopPrice":"0.500000","workingTime":-1,"selfTradePreventionMode":"NONE"},{"symbol":"LTCBNB","orderId":23,"orderListId":629,"clientOrderId":"OVQOpKwfmPCfaBTD0n7e7H","transactTime":1712544408537,"price":"1.500000","origQty":"1.000000","executedQty":"0.000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"LIMIT","side":"BUY","workingTime":1712544408537,"selfTradePreventionMode":"NONE"}]},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":1000,"count":65},{"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":10000000,"count":18}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Box<models::OrderListPlaceOtocoResponseResult> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn order_list_place_otoco_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = OrderListPlaceOtocoParams::builder("BNBUSDT".to_string(),OrderListPlaceOtocoWorkingTypeEnum::LIMIT,OrderListPlaceOtocoWorkingSideEnum::BUY,1.0,1.0,OrderListPlaceOtocoPendingSideEnum::BUY,1.0,OrderListPlaceOtocoPendingAboveTypeEnum::STOP_LOSS_LIMIT,).build().unwrap();
                client.order_list_place_otoco(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn order_list_place_otoco_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderListPlaceOtocoParams::builder(
                    "BNBUSDT".to_string(),
                    OrderListPlaceOtocoWorkingTypeEnum::LIMIT,
                    OrderListPlaceOtocoWorkingSideEnum::BUY,
                    1.0,
                    1.0,
                    OrderListPlaceOtocoPendingSideEnum::BUY,
                    1.0,
                    OrderListPlaceOtocoPendingAboveTypeEnum::STOP_LOSS_LIMIT,
                )
                .build()
                .unwrap();
                client.order_list_place_otoco(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let text = match sent {
                Message::Text(t) => t,
                _ => panic!("expected Message Text"),
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn order_place_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderPlaceParams::builder("BNBUSDT".to_string(),OrderPlaceSideEnum::BUY,OrderPlaceTypeEnum::MARKET,).build().unwrap();
                client.order_place(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/order.place".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"56374a46-3061-486b-a311-99ee972eb648","status":200,"result":{"symbol":"BTCUSDT","orderId":12569099453,"orderListId":-1,"clientOrderId":"4d96324ff9d44481926157ec08158a40","transactTime":1660801715793,"price":"23416.10000000","origQty":"0.00847000","executedQty":"0.00847000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"198.33521500","status":"FILLED","timeInForce":"GTC","type":"LIMIT","side":"SELL","workingTime":1660801715793,"selfTradePreventionMode":"NONE","fills":[{"price":"23416.50000000","qty":"0.00212000","commission":"0.000000","commissionAsset":"BNB","tradeId":1650422482},{"price":"23416.10000000","qty":"0.00635000","commission":"0.000000","commissionAsset":"BNB","tradeId":1650422481},{"price":"23416.50000000","qty":"0.00212000","commission":"0.000000","commissionAsset":"BNB","tradeId":1650422482},{"price":"23416.10000000","qty":"0.00635000","commission":"0.000000","commissionAsset":"BNB","tradeId":1650422481}]},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":1},{"rateLimitType":"ORDERS","interval":"DAY","intervalNum":1,"limit":160000,"count":1},{"rateLimitType":"ORDERS","interval":"SECOND","intervalNum":10,"limit":50,"count":1}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Box<models::OrderPlaceResponseResult> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn order_place_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = OrderPlaceParams::builder("BNBUSDT".to_string(),OrderPlaceSideEnum::BUY,OrderPlaceTypeEnum::MARKET,).build().unwrap();
                client.order_place(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn order_place_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderPlaceParams::builder(
                    "BNBUSDT".to_string(),
                    OrderPlaceSideEnum::BUY,
                    OrderPlaceTypeEnum::MARKET,
                )
                .build()
                .unwrap();
                client.order_place(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let text = match sent {
                Message::Text(t) => t,
                _ => panic!("expected Message Text"),
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn order_test_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderTestParams::builder().build().unwrap();
                client.order_test(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/order.test".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"6ffebe91-01d9-43ac-be99-57cf062e0e30","status":200,"result":{"standardCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"taxCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"discount":{"enabledForAccount":true,"enabledForSymbol":true,"discountAsset":"BNB","discount":"0.25000000"}},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":1}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Box<models::OrderTestResponseResult> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn order_test_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = OrderTestParams::builder().build().unwrap();
                client.order_test(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn order_test_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = OrderTestParams::builder().build().unwrap();
                client.order_test(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let text = match sent {
                Message::Text(t) => t,
                _ => panic!("expected Message Text"),
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn sor_order_place_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = SorOrderPlaceParams::builder("BNBUSDT".to_string(),SorOrderPlaceSideEnum::BUY,SorOrderPlaceTypeEnum::MARKET,1.0,).build().unwrap();
                client.sor_order_place(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/sor.order.place".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"3a4437e2-41a3-4c19-897c-9cadc5dce8b6","status":200,"result":[{"symbol":"BTCUSDT","orderId":2,"orderListId":-1,"clientOrderId":"sBI1KM6nNtOfj5tccZSKly","transactTime":1689149087774,"price":"31000.00000000","origQty":"0.50000000","executedQty":"0.50000000","origQuoteOrderQty":"0.000000","cummulativeQuoteQty":"14000.00000000","status":"FILLED","timeInForce":"GTC","type":"LIMIT","side":"BUY","workingTime":1689149087774,"fills":[{"matchType":"ONE_PARTY_TRADE_REPORT","price":"28000.00000000","qty":"0.50000000","commission":"0.00000000","commissionAsset":"BTC","tradeId":-1,"allocId":0}],"workingFloor":"SOR","selfTradePreventionMode":"NONE","usedSor":true}],"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":1}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Vec<models::SorOrderPlaceResponseResultInner> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn sor_order_place_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = SorOrderPlaceParams::builder("BNBUSDT".to_string(),SorOrderPlaceSideEnum::BUY,SorOrderPlaceTypeEnum::MARKET,1.0,).build().unwrap();
                client.sor_order_place(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn sor_order_place_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = SorOrderPlaceParams::builder(
                    "BNBUSDT".to_string(),
                    SorOrderPlaceSideEnum::BUY,
                    SorOrderPlaceTypeEnum::MARKET,
                    1.0,
                )
                .build()
                .unwrap();
                client.sor_order_place(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let text = match sent {
                Message::Text(t) => t,
                _ => panic!("expected Message Text"),
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }

    #[test]
    fn sor_order_test_success() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = SorOrderTestParams::builder().build().unwrap();
                client.sor_order_test(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.expect("send should occur").expect("channel closed");
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap();
            assert_eq!(v["method"], "/sor.order.test".trim_start_matches('/'));

            let mut resp_json: Value = serde_json::from_str(r#"{"id":"3a4437e2-41a3-4c19-897c-9cadc5dce8b6","status":200,"result":{"standardCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"taxCommissionForOrder":{"maker":"0.00000112","taker":"0.00000114"},"discount":{"enabledForAccount":true,"enabledForSymbol":true,"discountAsset":"BNB","discount":"0.25"}},"rateLimits":[{"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000,"count":1}]}"#).unwrap();
            resp_json["id"] = id.into();

            let raw_data = resp_json.get("result").or_else(|| resp_json.get("response")).expect("no response in JSON");
            let expected_data: Box<models::OrderTestResponseResult> = serde_json::from_value(raw_data.clone()).expect("should parse raw response");
            let empty_array = Value::Array(vec![]);
            let raw_rate_limits = resp_json.get("rateLimits").unwrap_or(&empty_array);
            let expected_rate_limits: Option<Vec<WebsocketApiRateLimit>> =
                match raw_rate_limits.as_array() {
                    Some(arr) if arr.is_empty() => None,
                    Some(_) => Some(serde_json::from_value(raw_rate_limits.clone()).expect("should parse rateLimits array")),
                    None => None,
                };

            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let response = timeout(Duration::from_secs(1), handle).await.expect("task done").expect("no panic").expect("no error");

            let response_rate_limits = response.rate_limits.clone();
            let response_data = response.data().expect("deserialize data");

            assert_eq!(response_rate_limits, expected_rate_limits);
            assert_eq!(response_data, expected_data);
        });
    }

    #[test]
    fn sor_order_test_error_response() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = tokio::spawn(async move {
                let params = SorOrderTestParams::builder().build().unwrap();
                client.sor_order_test(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv()).await.unwrap().unwrap();
            let text = match sent { Message::Text(t) => t, _ => panic!() };
            let v: Value = serde_json::from_str(&text).unwrap();
            let id = v["id"].as_str().unwrap().to_string();

            let resp_json = json!({
                "id": id,
                "status": 400,
                    "error": {
                        "code": -2010,
                        "msg": "Account has insufficient balance for requested action.",
                    },
                    "rateLimits": [
                        {
                            "rateLimitType": "ORDERS",
                            "interval": "SECOND",
                            "intervalNum": 10,
                            "limit": 50,
                            "count": 13
                        },
                    ],
            });
            WebsocketHandler::on_message(&*ws_api, resp_json.to_string(), conn.clone()).await;

            let join = timeout(Duration::from_secs(1), handle).await.unwrap();
            match join {
                Ok(Err(e)) => {
                    let msg = e.to_string();
                    assert!(
                        msg.contains("Server‐side response error (code -2010): Account has insufficient balance for requested action."),
                        "Expected error msg to contain server error, got: {msg}"
                    );
                }
                Ok(Ok(_)) => panic!("Expected error"),
                Err(_) => panic!("Task panicked"),
            }
        });
    }

    #[test]
    fn sor_order_test_request_timeout() {
        TOKIO_SHARED_RT.block_on(async {
            let (ws_api, _conn, mut rx) = setup().await;
            let client = TradeApiClient::new(ws_api.clone());

            let handle = spawn(async move {
                let params = SorOrderTestParams::builder().build().unwrap();
                client.sor_order_test(params).await
            });

            let sent = timeout(Duration::from_secs(1), rx.recv())
                .await
                .expect("send should occur")
                .expect("channel closed");
            let text = match sent {
                Message::Text(t) => t,
                _ => panic!("expected Message Text"),
            };

            let _: Value = serde_json::from_str(&text).unwrap();

            let result = handle.await.expect("task completed");
            match result {
                Err(e) => {
                    if let Some(inner) = e.downcast_ref::<WebsocketError>() {
                        assert!(matches!(inner, WebsocketError::Timeout));
                    } else {
                        panic!("Unexpected error type: {:?}", e);
                    }
                }
                Ok(_) => panic!("Expected timeout error"),
            }
        });
    }
}
